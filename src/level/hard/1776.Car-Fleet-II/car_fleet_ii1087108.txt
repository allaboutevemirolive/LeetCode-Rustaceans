// https://leetcode.com/problems/car-fleet-ii/solutions/1087108/rust-stack-solution/
impl Solution {
    pub fn get_collision_times(cars: Vec<Vec<i32>>) -> Vec<f64> {
        let mut cars = cars;
        cars.reverse();
        #[derive(Default)]
        struct Entry(i32, i32, f64);
        let mut res: Vec<f64> = Vec::new();
        let mut stack: Vec<Entry> = Vec::new();
        for car in cars {
            let (pos, speed) = (car[0], car[1]);
            while !stack.is_empty()
                && (speed <= stack.last().unwrap().1
                    || (stack.last().unwrap().0 - pos) as f64
                        / (speed - stack.last().unwrap().1) as f64
                        >= stack.last().unwrap().2)
            {
                stack.pop();
            }
            if stack.is_empty() {
                stack.push(Entry(pos, speed, std::f64::MAX));
                res.push(-1.0);
            } else {
                let last = stack.last().unwrap();
                let time = (last.0 - pos) as f64 / (speed - last.1) as f64;
                stack.push(Entry(pos, speed, time));
                res.push(time);
            }
        }
        res.reverse();
        res
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_solution() {
        let cars = vec![vec![1, 2], vec![2, 1], vec![4, 3], vec![7, 2]];
        let expected: Vec<f64> = vec![1.0, -1.0, 3.0, -1.0];
        assert_eq!(expected, Solution::get_collision_times(cars));
        let cars = vec![vec![3, 4], vec![5, 4], vec![6, 3], vec![9, 1]];
        let expected: Vec<f64> = vec![2.0, 1.0, 1.5, -1.0];
        assert_eq!(expected, Solution::get_collision_times(cars));
    }
}