// https://leetcode.com/problems/collect-coins-in-a-tree/solutions/3343854/rust-trimming-tree-leaves/
use std::collections::HashSet;

impl Solution {
    pub fn collect_the_coins(coins: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {
        let n = coins.len();
        let mut graph = vec![HashSet::new(); n];

        for e in edges {
            let (u, v) = (e[0] as usize, e[1] as usize);
            graph[u].insert(v);
            graph[v].insert(u);
        }
        
        // picking up leaf nodes without coins
        let mut stack = vec![];
        for i in 0 .. n {
            if graph[i].len() == 1 && coins[i] == 0 { stack.push(i); }
        }
  
        // DFS removing leaf nodes without coins
        let mut count = n as i32 - 1;
        while let Some(u) = stack.pop() {
            if graph[u].is_empty() { continue }
            count -= 1; 
            let v = *graph[u].iter().next().unwrap();
            graph[u].remove(&v);
            graph[v].remove(&u);

            if coins[v] == 0 && graph[v].len() == 1 { stack.push(v); }
        }

        // all leaf nodes all have coins, picking them up 
        let mut flag = vec![2; n];
        for i in 0 .. n {
            if graph[i].len() == 1 { stack.push(i); }
        }

        // removing nodes two steps inward
        while let Some(u) = stack.pop() {
            if graph[u].is_empty() { continue }
            count -= 1;
            let v = *graph[u].iter().next().unwrap();
            flag[v] = flag[v].min(flag[u] - 1);
            graph[u].remove(&v);
            graph[v].remove(&u);

            if flag[v] > 0 && graph[v].len() == 1 { stack.push(v); }
        }
        2 * count
    }
}