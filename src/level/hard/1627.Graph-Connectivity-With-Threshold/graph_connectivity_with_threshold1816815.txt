// https://leetcode.com/problems/graph-connectivity-with-threshold/solutions/1816815/rust-unionfind/
use std::cmp::max;

struct DisjointSet {
    map: Vec<usize>,
}

impl DisjointSet {
    fn new(capacity: usize) -> Self {
        Self {
            map: (0..capacity).collect(),
        }
    }

    fn union(&mut self, x: usize, y: usize) -> bool {
        let x = self.find(x);
        let y = self.find(y);

        if x != y {
            self.map[x] = x;
            self.map[y] = x;
            return true;
        }

        false
    }

    fn find(&mut self, x: usize) -> usize {
        if self.map[x] != x {
            self.map[x] = self.find(self.map[x])
        }

        self.map[x]
    }
}

impl Solution {
    pub fn are_connected(n: i32, threshold: i32, queries: Vec<Vec<i32>>) -> Vec<bool> {
        let mut dsu = DisjointSet::new((n + 1) as usize);

        let n = n as usize;
        let threshold = threshold as usize;

        for x in threshold + 1..n + 1 {
            for y in (2 * x..n + 1).step_by(max(x, 1)) {
                dsu.union(x, y);
            }
        }

        queries
            .iter()
            .map(|v| dsu.find(v[0] as usize) == dsu.find(v[1] as usize))
            .collect()
    }
}
