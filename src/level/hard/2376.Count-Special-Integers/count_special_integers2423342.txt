// https://leetcode.com/problems/count-special-integers/solutions/2423342/digit-dp-solution-in-rust/
fn f(i: usize, bm: usize, t: usize, dp:&mut Vec<Vec<Vec<i32>>>, m: usize, a:& Vec<char>) -> i32 {
    if i == m {
        return 1;
    } else {
        let mut ans = dp[i][bm][t];
        if ans != -1 {
            return ans;
        }
        ans = 0;
        if t == 1 {
            let mut st: usize = 0;
            if bm == 0 {
                st = 1;
            }
            for j in st..((a[i] as usize) - ('0' as usize) + 1) {
                if (bm & (1 << j)) == 0 && j == (a[i] as usize) - ('0' as usize) {
                    ans += f(i + 1, bm | (1 << j), 1, dp, m, a);
                } else if (bm & (1 << j)) == 0 {
                    ans += f(i + 1, bm | (1 << j), 0, dp, m, a);
                }
            }
        } else {
            let mut st: usize = 0;
            if bm == 0 {
                st = 1;
            }
            for j in st..10 {
                if (bm & (1 << j)) == 0 {
                    ans += f(i + 1, bm | (1 << j), 0, dp, m, a);
                }
            }
        }
        dp[i][bm][t] = ans;
        return ans;
    }
}

impl Solution {
    pub fn count_special_numbers(n: i32) -> i32 {
        let s: String = n.to_string();
        let m = s.chars().count();
        let s: Vec<char> = s.chars().collect();
        let mut dp = vec![vec![vec![-1 as i32; 2]; (1 << 10) + 1]; m];
        let mut ans: i32 = 0;
        for i in 0..m {
            if i == 0 {
                ans += f(i, 0, 1, &mut dp, m, &s);
            } else {
                ans += f(i, 0, 0, &mut dp, m, &s);
            }
        }
        return ans;
    }
}