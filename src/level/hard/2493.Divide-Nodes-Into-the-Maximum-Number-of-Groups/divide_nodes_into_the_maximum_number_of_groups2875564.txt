// https://leetcode.com/problems/divide-nodes-into-the-maximum-number-of-groups/solutions/2875564/rust-dfs-bfs/
use std::collections::HashSet;

impl Solution {
    pub fn magnificent_sets(n: i32, edges: Vec<Vec<i32>>) -> i32 {
        let n = n as usize;
        let mut g = vec![vec![]; n + 1];
        for e in edges {
            let (u, v) = (e[0] as usize, e[1] as usize);
            g[u].push(v);
            g[v].push(u);
        }

        let mut flag = vec![0; n + 1];
        let mut ret = 0;

        for k in 1 ..= n {
            if flag[k] == 1 { continue }
            
            // find all nodes in the same connected component
            let mut s = HashSet::from([k]);
            Self::dfs(&g, &mut s, k);

            // perform a BFS to find the max path length
            // on every node in the component as the starting node
            let mut mx = 0;
            for it in s.into_iter() {
                flag[it] = 1;
                let mut q = vec![it];
                let mut cnt = 0;
                let mut dist = vec![n; n + 1];
                dist[it] = 0;

                while (q.is_empty() == false) {
                    cnt += 1;
                    let mut temp = vec![];
                    while let Some(u) = q.pop() {
                        for v in &g[u] {
                            // If u is connected to a node in the 
                            // same leve of u, there is a cycle
                            // of odd length 
                            if dist[*v] == dist[u] { return -1 }
                            if dist[*v] != n { continue }
                            dist[*v] = dist[u] + 1;
                            temp.push(*v);
                        }
                    }
                    q = temp;
                }
                mx = mx.max(cnt);
            }
            ret += mx;
        }
        ret
    }

    fn dfs(g: &Vec<Vec<usize>>, s: &mut HashSet<usize>, u: usize) {
        for v in &g[u] {
            if s.contains(v) { continue }
            s.insert(*v);
            Self::dfs(g, s, *v);
        }
    }
}