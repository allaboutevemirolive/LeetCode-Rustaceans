// https://leetcode.com/problems/minimum-time-to-finish-the-race/solutions/2638040/rust-dp-unbounded-knapsack-problem-solution/
use std::collections::*;

impl Solution {
	pub fn minimum_finish_time(tires: Vec<Vec<i32>>, change_time: i32, num_laps: i32) -> i32 {
		let mut a: BTreeMap<usize, i32> = BTreeMap::new();
		for t in &tires {
			let (mut f, r, mut c, mut i) = (t[0], t[1], t[0], 0_usize);
			while c < 1000000 {
				if !a.contains_key(&i) || a[&i] > c { a.insert(i, c); }
				f *= r; c += f; i += 1;
			}
		}
		let a: Vec<_> = a.iter().map(|(_, x)| x).collect();
		let mut dp = vec![i32::MAX; num_laps as usize + 1];
		dp[0] = 0;
		for i in 0..a.len() {
			for j in (i + 1)..dp.len() {
				dp[j] = dp[j].min(dp[j - i - 1] + a[i] + change_time);
			}
		}
		dp[num_laps as usize] - change_time
	}
}