// https://leetcode.com/problems/minimum-total-distance-traveled/solutions/2785090/rust-dp-solution/
impl Solution {
    pub fn minimum_total_distance(robot: Vec<i32>, factory: Vec<Vec<i32>>) -> i64 {
        let (m, n) = (factory.len(), robot.len());
        let (mut factory, mut robot) = (factory, robot);
        let mut sum = vec![0; m + 1];
        let mut dp = vec![vec![i64::MAX; m]; n];

        factory.sort();
        robot.sort();
        for i in 0 .. m { sum[i + 1] = sum[i] + factory[i][1] as i64; }
        
        for i in 0 .. n {
            for j in 0 .. m {
                if i as i64 + 1 > sum[j + 1] { continue }
                if j == 0 {
                    dp[i][j] = 0;
                    for k in 0 ..= i {
                        dp[i][j] += i64::abs(factory[j][0] as i64 - robot[k] as i64);
                    }  
                    continue
                }
                
                let mut temp = 0;
                for k in 0 ..= factory[j][1] as usize {
                    if k > i + 1 { break }
                    if k > 0 {  temp += i64::abs(factory[j][0] as i64 - robot[i - k + 1] as i64); }
                    
                    if k <= i && dp[i - k][j - 1] == i64::MAX { continue }
                    let mut extra = 0;
                    if k <= i { extra = dp[i - k][j - 1]; }
                    dp[i][j] = dp[i][j].min(temp + extra);
                }
            }
        }
        
        dp[n - 1][m - 1]
    }
}