// https://leetcode.com/problems/build-a-matrix-with-conditions/solutions/2493425/rust-topological-sort/
impl Solution {
    pub fn build_matrix(k: i32, row_conditions: Vec<Vec<i32>>, col_conditions: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let row_order = Self::find_order(k, &row_conditions);
        let col_order = Self::find_order(k, &col_conditions);
		
        if row_order.is_empty() || col_order.is_empty() {
            return Vec::new(); 
        }
        
        let k = k as usize;
        let mut ret = vec![vec![0; k]; k];
        for i in 0..k {
            for j in 0..k {
                if row_order[i] == col_order[j] { ret[i][j] = row_order[i]; }
            }
        }
        
        ret
    }
    
	// this is a solution to problem #210
    fn find_order(k: i32, conditions: &Vec<Vec<i32>>) -> Vec<i32> {
        let n = k as usize;
        let mut graph = vec![vec![]; n];
        let mut in_degree = vec![0i32; n];
        
        for p in conditions {
            let (u, v) = (p[0] as usize - 1, p[1] as usize - 1);
            in_degree[u] += 1;
            graph[v].push(u);
        }
        
        let (mut sk, mut ret) = (vec![], vec![]);
        for u in 0..n {
            if in_degree[u] > 0 { continue; }  
            ret.push(u as i32 + 1);
            sk.push(u);
        }
        
        while sk.is_empty() == false {
            let u = sk.pop().unwrap();
            for v in &graph[u] {
                in_degree[*v] -= 1;
                if in_degree[*v] > 0 { continue; }
                sk.push(*v);
                ret.push(*v as i32 + 1);
            }
        }
        
        if ret.len() < n { return vec![] }
        ret.reverse();
        
        ret
    }
}