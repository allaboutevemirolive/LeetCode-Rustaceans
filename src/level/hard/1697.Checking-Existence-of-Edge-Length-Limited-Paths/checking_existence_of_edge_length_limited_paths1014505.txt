// https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/solutions/1014505/rust-union-find/
impl Solution {
    pub fn distance_limited_paths_exist(n: i32, edge_list: Vec<Vec<i32>>, queries: Vec<Vec<i32>>) -> Vec<bool> {
        Distance::new(n as usize, queries).go(edge_list)
    }
}

type Triple = (usize, usize, u64);

fn sorted_with<A, B: Ord>(mut it: Vec<A>, f: impl Fn(&A) -> B) -> Vec<A> {
    it.sort_by_key(f);
    it
}

fn triple(v: Vec<i32>) -> Triple { (v[0] as usize, v[1] as usize, v[2] as u64) }

fn from_vec(v: Vec<Vec<i32>>) -> Vec<Triple> { v.into_iter().map(triple).collect() }

#[derive(Debug)]
struct Distance { du: DisjointUnion, good: Vec<bool>, queries: Vec<(usize, Triple)> }

impl Distance {
    fn new(n: usize, queries: Vec<Vec<i32>>) -> Self {
        let mut queries: Vec<_> = queries.into_iter().map(triple).enumerate().collect();
        queries.sort_by_key(|(_, (_, _, cost))| std::cmp::Reverse(*cost));
        Distance { du: DisjointUnion::new(n), good: vec![false; queries.len()], queries }
    }
    fn finalize(&mut self, bound: u64) {
        while self.queries.last().iter().any(|(_, (_, _, cost))| *cost <= bound) {
            if let Some((p, (x, y, _))) = self.queries.pop() {
                self.good[p] = self.du.joined(x, y);
            }
        }
    }
    fn go(mut self, edge_list: Vec<Vec<i32>>) -> Vec<bool> {
        for (a, b, cost) in sorted_with(from_vec(edge_list), |v| v.2) {
            self.finalize(cost);
            self.du.join(a, b);
        }
        self.finalize(std::u64::MAX);
        self.good
    }
}

#[derive(Clone, Copy, Debug)]
enum DU { Parent(usize), Size(usize) }

#[derive(Clone, Debug)]
pub struct DisjointUnion { du: Vec<DU> }

impl DisjointUnion {
    pub fn new(size: usize) -> Self { DisjointUnion { du: vec![DU::Size(1); size] } }

    pub fn root(&mut self, i: usize) -> (usize, usize) {
        match self.du[i] {
            DU::Parent(p) => {
                let (r, s) = self.root(p);
                if p != r { self.du[i] = DU::Parent(r) }
                (r, s)
            }
            DU::Size(s) => (i, s)
        }
    }
    pub fn joined(&mut self, i: usize, j: usize) -> bool{
        self.root(i).0 == self.root(j).0
    }

    pub fn join(&mut self, i: usize, j: usize) {
        let (ir, is) = self.root(i);
        let (jr, js) = self.root(j);
        if ir == jr { return; }
        let (win, loose) = if is < js { (jr, ir) } else { (ir, jr) };
        self.du[loose] = DU::Parent(win);
        self.du[win] = DU::Size(is + js);
    }
}