// https://leetcode.com/problems/number-of-good-paths/solutions/3052457/rust-union-find/
impl Solution {
    pub fn number_of_good_paths(vals: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {
        use std::collections::{BTreeMap, HashMap};

        let n = vals.len();

        // only build connection from big val -> small val
        let mut adj = vec![vec![]; n];
        for edge in edges {
            if vals[edge[0] as usize] >= vals[edge[1] as usize] {
                adj[edge[0] as usize].push(edge[1] as usize);
            } else {
                adj[edge[1] as usize].push(edge[0] as usize);
            }
        }

        // a sorted map for all node binding with same value
        let mut val_to_idx: BTreeMap<i32, Vec<usize>> = BTreeMap::new();
        for (i, val) in vals.into_iter().enumerate() {
            val_to_idx.entry(val).or_insert(vec![]).push(i);
        }

        // union find stuff
        let mut uf: Vec<_> = (0..n).into_iter().collect();
        fn uf_find(uf: &mut Vec<usize>, a: usize) -> usize {
            let mut b = a;
            while uf[b] != b {
                b = uf[b];
            }
            uf[a] = b;
            b
        }
        fn uf_union(uf: &mut Vec<usize>, mut a: usize, mut b: usize) {
            a = uf_find(uf, a);
            b = uf_find(uf, b);
            uf[a] = b;
        }

        let mut ret = n;
        for (val, idx_arr) in val_to_idx {
            // add new nodes into union
            for &idx in &idx_arr {
                for &node in &adj[idx] {
                    uf_union(&mut uf, idx, node);
                }
            }

            // count path in each group
            let mut group: HashMap<usize, usize> = HashMap::new();
            for idx in idx_arr {
                group.entry(uf_find(&mut uf, idx)).and_modify(|count| *count += 1).or_insert(1);
            }
            for (_, count) in group {
                ret += count * (count - 1) / 2;
            }
        }
        ret as _
    }
}