// https://leetcode.com/problems/number-of-good-paths/solutions/3056404/rust-sadd-same-algo-different-developer/
use std::collections::BTreeMap;

impl Solution {
    pub fn number_of_good_paths(vals: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {
        let     n      = vals.len();
        let mut v2node = BTreeMap::new();
        let mut adjmap = vec![None; n];
        let mut unions = UnionFind::new(n);

        let mut counts = vec![0; n];

        for edge in edges {
            let (n1, n2) = (edge[0] as usize, edge[1] as usize);
            adjmap[n1].get_or_insert_with(Vec::new).push(n2);
            adjmap[n2].get_or_insert_with(Vec::new).push(n1);
        }

        for (v, n) in vals.iter().copied().zip(0..) {
            v2node.entry(v).or_insert_with(Vec::new).push(n);
        }

        for (_, nodes) in v2node {
            for &node in &nodes {
                if let Some(adjlist) = adjmap[node].take() {
                    for adjnode in adjlist {
                        if vals[node] >= vals[adjnode] {
                            unions.union(node, adjnode);
                        }
                    }
                }
            }

            for node in nodes {
                counts[unions.find(node)] += 1;
            }
        }

        counts.into_iter().map(|c| c * (c + 1) / 2).sum::<i32>()
    }
}


pub struct UnionFind {
    link : Vec<usize>,
    size : Vec<usize>,
}

impl UnionFind {
    pub fn new(n : usize) -> Self {
        Self { link: (0..n).collect(), size: vec![0; n] }
    }
    pub fn find(&mut self, v : usize) -> usize {
        let mut v_root = v;
        while v_root != self.link[v_root] { 
            v_root = self.link[v_root]; 
        }
        self.link[v] = v_root; // Compress.
        v_root
    }
    pub fn union(&mut self, u: usize, v: usize) {
        let u_root = self.find(u);
        let v_root = self.find(v);
        if u_root != v_root {
            if self.size[u_root] < self.size[v_root] {
                self.link[u_root] = v_root; 
                self.size[v_root] += self.size[u_root];
            } else {
                self.link[v_root] = u_root;
                self.size[u_root] += self.size[v_root];
            }
        }
    }
}