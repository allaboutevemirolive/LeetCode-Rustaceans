// https://leetcode.com/problems/number-of-good-paths/solutions/3056412/rust-union-find-solution/
use std::collections::HashMap;

impl Solution {
    pub fn number_of_good_paths(vals: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {
        let mut adj = vec![Vec::new(); vals.len()];
        for v in edges.iter() {
            adj[v[0] as usize].push(v[1] as usize);
            adj[v[1] as usize].push(v[0] as usize);
        }
        let mut parent: Vec<usize> = (0..vals.len()).collect();
        let mut asc: Vec<usize> = (0..vals.len()).collect();
        asc.sort_unstable_by_key(|&i| (vals[i], i));
        asc.push(usize::MAX);
        let mut ans = 0;
        let mut done = 0;
        let mut hash = HashMap::new();
        for curr in 0..asc.len() {
            if curr == asc.len() - 1 || (curr > 0 && vals[asc[curr]] > vals[asc[curr - 1]]) {
                for pos in done..curr {
                    let root = Self::find_set(asc[pos], &mut parent);
                    *hash.entry(root).or_insert(0) += 1;
                }
                for (_, count) in hash.drain() {
                    ans += count * (count + 1) / 2;
                }
                done = curr;
            }
            if curr == asc.len() - 1 {
                break;
            }
            let i = asc[curr];
            for &j in adj[i].iter().filter(|&&j| vals[j] <= vals[i]) {
                let root_i = Self::find_set(i, &mut parent);
                let root_j = Self::find_set(j, &mut parent);
                parent[root_i.max(root_j)] = root_i.min(root_j);
            }
        }
        ans
    }

    fn find_set(i: usize, parent: &mut Vec<usize>) -> usize {
        if parent[i] != i {
            parent[i] = Self::find_set(parent[i], parent);
        }
        parent[i]
    }
}