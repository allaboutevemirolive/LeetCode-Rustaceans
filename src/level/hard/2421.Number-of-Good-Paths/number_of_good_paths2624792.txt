// https://leetcode.com/problems/number-of-good-paths/solutions/2624792/rust-kruskal-like-approach-using-union-find/
impl Solution {
    pub fn number_of_good_paths(vals: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {
        let n = vals.len();
        let mut data = vec![];
        
        for e in edges {
            let (u, v) = (e[0] as usize, e[1] as usize);
            data.push((vals[u].max(vals[v]), u, v));
        }
        data.sort();
    
        let mut parent: Vec<_> = (0..n).collect();
        let mut counts = vec![];
        let mut ret = n;
        for u in 0..n { counts.push((vals[u], 1)); }
        
        for (val, u, v) in data {
            let (i, j) = (Self::find(u, &mut parent), Self::find(v, &mut parent));
            let c1 = if counts[i].0 == val { counts[i].1 } else { 0 };
            let c2 = if counts[j].0 == val { counts[j].1 } else { 0 };
            ret += c1 * c2;
            parent[i] = j;
            if c2 > 0 { counts[j].1 += c1; }
            else { counts[j] = (val, c1); }
        }

        ret as _
    }
    
    fn find(i: usize, parent: &mut Vec<usize>) -> usize {
        if parent[i] == i { return i }
        parent[i] = Self::find(parent[i], parent);
        parent[i]
    }
}