// https://leetcode.com/problems/get-the-maximum-score/solutions/2764236/rust-o-n-time-in-place-similar-algorithm-to-merging-sorted-arrays/
use std::cmp::max;

impl Solution {
    pub fn max_sum(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
        let mut i1 = 0;
        let mut i2 = 0;
        let mut i1_sum = 0 as u64;
        let mut i2_sum = 0 as u64;
        let mut total_sum = 0 as u64;
        let len1 = nums1.len();
        let len2 = nums2.len();
        while i1 < len1 && i2 < len2 {
            let val1 = nums1[i1];
            let val2 = nums2[i2];
            if val1 < val2 {
                i1_sum += val1 as u64;
                i1 += 1;
            } else if val1 > val2 {
                i2_sum += val2 as u64;
                i2 += 1;
            } else {
                total_sum = (total_sum + max(i1_sum, i2_sum) + val1 as u64) % 1_000_000_007;
                i1_sum = 0;
                i2_sum = 0;
                i1 += 1;
                i2 += 1;
            }
        }
        while i1 < len1 {
            i1_sum += nums1[i1] as u64;
            i1 += 1;
        }
        while i2 < len2 {
            i2_sum += nums2[i2] as u64;
            i2 += 1;
        }
        total_sum = (total_sum + max(i1_sum, i2_sum)) % 1_000_000_007;
        return total_sum as i32;
    }
}
