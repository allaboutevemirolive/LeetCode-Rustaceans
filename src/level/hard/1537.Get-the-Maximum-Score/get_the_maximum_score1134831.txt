// https://leetcode.com/problems/get-the-maximum-score/solutions/1134831/boring-rust-solution-beats-100-100/
use std::cmp::{max, Ordering};

const MOD: usize = 1_000_000_007;
const INF: i32 = 100_000_000;

impl Solution {
    pub fn max_sum(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
        let mut i1 = nums1.iter().chain([INF].iter()).peekable();
        let mut i2 = nums2.iter().chain([INF].iter()).peekable();
        let mut t1 = 0;
        let mut t2 = 0;
        let mut ans = 0;
        
        loop {
            let &&x1 = i1.peek().unwrap();
            let &&x2 = i2.peek().unwrap();
            
            match x1.cmp(&x2) {
                Ordering::Less => {
                    t1 += x1 as usize;
                    i1.next();
                },
                Ordering::Greater => {
                    t2 += x2 as usize;
                    i2.next();
                },
                Ordering::Equal => {
                    ans += max(t1, t2);
                    if x1 == INF {
                        break (ans % MOD) as i32;
                    };
                    ans += x1 as usize;
                    t1 = 0;
                    t2 = 0;
                    i1.next();
                    i2.next();
                },
            }
        }
    }
}