// https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/solutions/2615728/rust-binary-search-mitm/
fn combinations(nums: &Vec<i32>, k: usize) -> Vec<Vec<i32>> {
    if k == 0 {
        return vec![vec![0]];
    }
    let mut result = Vec::new();
    let mut stack = Vec::new();
    let mut i = 0;
    while i < nums.len() {
        stack.push(nums[i]);
        if stack.len() == k {
            result.push(stack.clone());
            stack.pop();
        }
        i += 1;
        while stack.len() > 0 && i == nums.len() {
            i = nums.iter().position(|&x| x == stack[stack.len() - 1]).unwrap() + 1;
            while i < nums.len() && nums[i] == nums[i - 1] {
                i += 1;
            }
            stack.pop();
        }
    }
    result
}

impl Solution {
    pub fn minimum_difference(nums: Vec<i32>) -> i32 {
        let mut nums = nums;
        nums.sort_unstable();
        let n = nums.len() / 2;
        let mut target: f64 = 0.0;
        for i in 0..nums.len() {
            target += nums[i] as f64;
        }
        target /= 2.0;
        let (l, r) = nums.split_at(n);
        let mut ans: f64 = std::f64::MAX;
        for k in 0..n {
            let mut big_sums: Vec<i32> = combinations(&r.to_vec(), n - k).iter().map(|v| v.iter().sum()).collect();
            big_sums.sort_unstable();
            for small_sum in combinations(&l.to_vec(), k).iter().map(|v| v.iter().sum::<i32>()) {
                let i = big_sums.binary_search(&((target - small_sum as f64) as i32)).unwrap_or_else(|e| e);
                if i != big_sums.len() {
                    ans = ans.min((target - big_sums[i] as f64 - small_sum as f64).abs());
                }
            }
        }
        (ans * 2.0) as i32
    }
}