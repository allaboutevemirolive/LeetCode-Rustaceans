// https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/solutions/1973766/rust-answer/
type Target = i32;
type UseValue = i32;
fn lower_bound(arr: &Vec<Target>, x: &UseValue) -> usize {
    let mut low = 0;
    let mut high = arr.len();
    while low != high {
        let mid = (low + high) / 2;
        // NEEDS TO EDIT
        match arr[mid].cmp(x) {
            std::cmp::Ordering::Less => {
                low = mid + 1;
            }
            std::cmp::Ordering::Equal | std::cmp::Ordering::Greater => {
                high = mid;
            }
        }
    }
    low
}

fn helper(arr:Vec<i32>) -> Vec<Vec<i32>> {
  let n = arr.len();
  let mut result = vec![vec![];n+1];

  let limit = 1usize << n;
  for i in 0..limit {
    let mut temp = 0;
    for j in 0..n {
      if i >> j & 1 == 1 {
        temp += arr[j];
      }
    }
    result[i.count_ones() as usize].push(temp);
  }

  for i in 0..n {
    result[i].sort();
  }

  result
}

impl Solution {
  pub fn minimum_difference(nums: Vec<i32>) -> i32 {
    let n = nums.len() / 2;
    let tot = nums.iter().sum::<i32>();
    let mut ba = vec![0;n];
    let mut bb = vec![0;n];
    for i in 0..n {
      ba[i] = nums[i];
      bb[i] = nums[2*n-1-i];
    }

    let hv = tot / 2;
    let half1 = helper(ba);
    let half2 = helper(bb);
    let mut result = i32::max_value();
    for i in 0..=n {
      for v1 in &half1[i] {
          let v = hv - v1;
          let ti = lower_bound(&half2[n-i], &v);
          let mi = ti.saturating_sub(1);
          let mx = std::cmp::min(ti+1, half2[n-i].len()-1);
          for j in mi..=mx {
            let v2 = half2[n-i][j];
            let v = v1 + v2;
            let v = (2 * v - tot).abs();
            result = std::cmp::min (result, v);
          }
      }
    }

    result
  }
}