// https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3423318/rust-dp-memo/
impl Solution {
    pub fn num_ways(words: Vec<String>, target: String) -> i32 {
        let (n, m) = (target.len(), words[0].len());
        let mut chars = vec![[0; 26]; m];
        let mut memo = vec![vec![None; m + 1]; n + 1];

        for i in 0..=n { memo[i][0] = Some(0) }
        for j in 0..=m { memo[0][j] = Some(1) }

        for word in words {
            let word = word.into_bytes();
            for i in 0..m {
                chars[i][(word[i] - b'a') as usize] += 1;
            }
        }
        let target = target.into_bytes().into_iter().map(|b| (b - b'a') as usize).collect::<Vec<usize>>();

        dp(n, &target, m, &chars, &mut memo) as i32
    }
}
const MOD: i64 = 1000_000_007;

fn dp(i: usize, t: &[usize], j: usize, chars: &[[i64; 26]], memo: &mut [Vec<Option<i64>>]) -> i64 {
    if i > j { return 0 }
    if let Some(v) = memo[i][j] { return v }

    let mut ans = dp(i, t, j - 1, chars, memo) + chars[j - 1][t[i - 1]] * dp(i - 1, t, j - 1, chars, memo) % MOD;
    ans %= MOD;
    memo[i][j] = Some(ans);
    ans
}