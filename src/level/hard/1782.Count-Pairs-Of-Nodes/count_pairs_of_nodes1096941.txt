// https://leetcode.com/problems/count-pairs-of-nodes/solutions/1096941/rust-2-pointer-hashmap-solution-o-q-n-e/
use std::collections::HashMap;
impl Solution {
    pub fn count_pairs(n: i32, edges: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {
        let n = n as usize;
        let mut count = vec![0; n + 1];
        let mut shared_count: Vec<HashMap<usize, i32>> = vec![HashMap::new(); n + 1];
        for edge in edges {
            let (small, large) = (
                std::cmp::min(edge[0], edge[1]) as usize,
                std::cmp::max(edge[0], edge[1]) as usize,
            );
            count[small] += 1;
            count[large] += 1;
            *shared_count[small].entry(large).or_insert(0) += 1;
        }
        let mut sorted_count = count.clone();
        sorted_count.sort();
        let mut res: Vec<i32> = vec![0; queries.len()];
        for (k, q) in queries.iter().enumerate() {
            let (mut i, mut j) = (1, sorted_count.len() - 1);
            while i < j {
                if sorted_count[i] + sorted_count[j] > *q {
                    res[k] += j as i32 - i as i32;
                    j -= 1;
                } else {
                    i += 1;
                }
            }
            for i in 1..=n {
                let shared = shared_count[i].clone();
                for (j, sh) in shared.into_iter() {
                    if count[i] + count[j] > *q && count[i] + count[j] - sh <= *q {
                        res[k] -= 1;
                    }
                }
            }
        }
        res
    }
}