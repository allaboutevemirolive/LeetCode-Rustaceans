// https://leetcode.com/problems/maximum-segment-sum-after-removals/solutions/2455464/rust-solution-using-btreeset-hashset/
// The idea is 
// 1) to use s as an order set for tracking the  segments
// 2) to use the ordered set cuts is for tracking all the cuts made so far. 
// Therefore, for a new cut, we can easily determine which segment gets cut
//  what new segments are created
  
use std::collections::BTreeSet;
use std::collections::HashMap;

impl Solution {
    pub fn maximum_segment_sum(nums: Vec<i32>, remove_queries: Vec<i32>) -> Vec<i64> {
        let n = nums.len();
        let mut sum = vec![0i64; n + 1];
        for i in 0..n {
            sum[i + 1] = sum[i] + nums[i] as i64;
        }
		
		let mut cuts = BTreeSet::<i32>::new();
        let mut s = BTreeSet::<(i64, i32, i32)>::new();
        let mut ret: Vec<i64> = vec![];
		
        cuts.insert(-1);
        cuts.insert(n as i32);
        s.insert((sum[n], -1, n as i32));
        
        for r in remove_queries {
            let left = if let Some(a) = cuts.range(..r).rev().next() { *a } else { 0 };
            let right = if let Some(a) = cuts.range(r..).next() { *a } else { n as i32 };
            let total = sum[right as usize] - sum[(left + 1) as  usize];
            
            //println!["r: {}, left: {}, right: {}. total: {}", r, left, right, total];  
            s.remove(&(total, left,  right));
            cuts.insert(r);
            
            if left + 1 < r {
                let total = sum[r as usize] - sum[left as usize + 1];
                s.insert((total, left, r));
            }
            
            if r + 1 < right {
                let total = sum[right as usize] - sum[r as usize + 1];
                s.insert((total, r, right));
            }
            
            if let Some((val, _, _)) = s.iter().next_back() {
                ret.push(*val);
            } else {
                ret.push(0);
            }
        }
        
        ret
    }
}