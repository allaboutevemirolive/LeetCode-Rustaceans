// https://leetcode.com/problems/longest-cycle-in-a-graph/solutions/2359226/rust-dfs-recursive/
/// @author: Leon
/// https://leetcode.com/problems/longest-cycle-in-a-graph/
/// Time Complexity:    O(V + E) ~ O(`len_vs`)
/// Space Complexity:   O(V + E) ~ O(`len_vs`)
impl Solution {
    const NOT_VISITED: u8 = 0;
    const VISITING: u8 = 1;
    const VISITED: u8 = 2;
    const NOT_CYCLIC: i32 = -1;
    pub fn longest_cycle(edges: Vec<i32>) -> i32 {
        let len_vs: usize = edges.len();
        let mut visited: Vec<u8> = vec![Self::NOT_VISITED; len_vs];
        let mut path: Vec<usize> = vec![0; len_vs];
        let mut longest: i32 = Self::NOT_CYCLIC;
        for vertex in 0..len_vs {
            if visited[vertex] == Self::NOT_VISITED {
                let len = Self::dfs(vertex, &mut visited, &mut path, &edges);
                longest = std::cmp::max(longest, len as i32);
            }
        }
        longest
    }
    fn dfs(cur: usize, visited: &mut Vec<u8>, path: &mut Vec<usize>, edges: &Vec<i32>) -> i32 {
        if visited[cur] == Self::VISITING {
            // to construct the cycle
            let mut len: i32 = 1;
            let mut c = cur;
            while path[c] != cur {
                c = path[c];
                len += 1;
            }
            return len;
        }
        if visited[cur] == Self::VISITED {
            return Self::NOT_CYCLIC;
        }
        visited[cur] = Self::VISITING;
        if edges[cur] == -1 {
            visited[cur] = Self::VISITED;
            return Self::NOT_CYCLIC;
        }
        let nxt: usize = edges[cur] as usize;
        path[nxt] = cur;
        let len = Self::dfs(nxt, visited, path, edges);
        visited[cur] = Self::VISITED;
        path[nxt] = 0;
        len
    }
}