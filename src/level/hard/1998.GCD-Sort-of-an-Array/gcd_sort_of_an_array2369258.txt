// https://leetcode.com/problems/gcd-sort-of-an-array/solutions/2369258/rust-solution-using-union-find/
use std::collections::*;
fn size(parents: &mut Vec<i32>, i: i32) -> i32 {
    let ii = find(parents, i) as usize;
    -1 * parents[ii]
}

fn find(parents: &mut Vec<i32>, i: i32) -> i32 {
    let ii = i as usize;
    if parents[ii] < 0 {
        i
    } else {
        parents[ii] = find(parents, parents[ii]);
        parents[ii]
    }
}

fn connect(
    parents: &mut Vec<i32>,
    a: i32,
    b: i32
) -> bool {
    let mut pa = find(parents, a);
    let mut pb = find(parents, b);
    
    if pa == pb { return false }
    
    if size(parents, pa) < size(parents, pb) {
        let temp = pa;
        pa = pb;
        pb = temp;
    }
    
    let paa = pa as usize;
    let pbb = pb as usize;
    parents[paa] += parents[pbb];
    parents[pbb] = pa;
    
    true
}

impl Solution {
    pub fn gcd_sort(mut nums: Vec<i32>) -> bool {
        let mut original = nums.clone();
        let n = nums.len();
        let mut parents = vec![-1;n];

        let inf = 1_000_000_000;
        let max = 10usize.pow(5)+10;
        let mut memo = vec![inf;max+1];
        for i in 0..n {
            let j = nums[i] as usize;
            if memo[j] == inf {
                memo[j] = i;
            } else {
                connect(&mut parents, memo[j] as i32, i as i32);
            }
        }

        let mut is_prime = vec![true;max+1];
        for i in 2..=max {
            if is_prime[i] {
                is_prime[i] = false;
                
                let mut last = if memo[i] != inf {
                    Some(memo[i])
                } else {
                    None
                };
                
                for j in 2..=max/i {
                    let ni = i * j;
                    is_prime[ni] = false;
                    if memo[ni] == inf { continue }
                    let bi = memo[ni];

                    if let Some(ci) = last {
                        connect(&mut parents, ci as i32, bi as i32);
                    } else {
                        last = Some(bi);
                    };

                }
            }
        }

        let mut map = HashMap::new();
        for i in 0..n {
            let pi = find(&mut parents, i as i32);
            if pi < 0 {
                map.entry(i).or_insert(vec![]).push(i);
            } else {
                let ti = pi as usize;
                map.entry(ti).or_insert(vec![]).push(i);
            }
        }

        for (_, mut arr) in map {
            let ori = arr.clone();
            arr.sort_by(|a, b| nums[*a].cmp(&nums[*b]));
            for i in 0..arr.len() {
                let j = arr[i];
                nums[ori[i]] = original[j];
            }
        }

        original.sort();
        for i in 0..n {
            if nums[i] != original[i] {
                return false
            }
        }
        true
    }
}