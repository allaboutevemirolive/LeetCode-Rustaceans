// https://leetcode.com/problems/design-a-text-editor/solutions/2211866/rust-2-vecdeque/
use std::{
    cell::RefCell,
    cmp::Ordering,
    collections::hash_map::Entry::Occupied,
    collections::{hash_map::Entry::Vacant, BTreeSet},
    collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque},
    rc::Rc,
};


#[derive(Debug)]
struct TextEditor {
    // text on the left of the cursor
    left: VecDeque<char>,
    // text on the right of the cursor
    right: VecDeque<char>,
}

impl TextEditor {
    fn new() -> Self {
        TextEditor {
            left: VecDeque::new(),
            right: VecDeque::new(),
        }
    }

    fn add_text(&mut self, text: String) {
        text.chars().for_each(|c| self.left.push_back(c));
    }

    fn delete_text(&mut self, mut k: i32) -> i32 {
        let mut deleted_count = 0;
        for _ in 0..k {
            match self.left.pop_back() {
                Some(_) => deleted_count += 1,
                None => break,
            }
        }
        deleted_count
    }

    fn cursor_left(&mut self, k: i32) -> String {
        for _ in 0..k {
            match self.left.pop_back() {
                Some(c) => self.right.push_front(c),
                None => break,
            }
        }

        self.print()
    }

    fn cursor_right(&mut self, k: i32) -> String {
        for _ in 0..k {
            match self.right.pop_front() {
                Some(c) => self.left.push_back(c),
                None => break,
            }
        }

        self.print()
    }

    fn print(&self) -> String {
        let text = self.left.as_slices().0;
        let slice: &[char] = &text[std::cmp::max(text.len() as i32 - 10, 0) as usize..];
        slice.into_iter().collect()
    }
}
