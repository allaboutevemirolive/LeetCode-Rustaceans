// https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/solutions/1360357/rust-n-3/
use std::cmp::{max, min};

impl Solution {
        pub fn min_trio_degree(n: i32, edges: Vec<Vec<i32>>) -> i32 {
        let size = n as usize;
        let mut graph = vec![vec![0; size]; size];

        // println!("{:?}", graph);

        let mut in_degrees = vec![0; size];
        for i in edges {
            let f_node = (i[0] - 1) as usize;
            let s_node = (i[1] - 1) as usize;
            in_degrees[f_node] += 1;
            in_degrees[s_node] += 1;
            graph[f_node][s_node] = 1;
            graph[s_node][f_node] = 1;
        }
        let mut min_degree = std::i32::MAX;
        for i in 0..size {
            for j in 0..size {
                for k in 0..size {
                    if graph[i][j] == 1 && graph[i][k] == 1 && graph[j][k] == 1 {
                        min_degree = min(min_degree, (in_degrees[i] + in_degrees[j] + in_degrees[k] - 6));
                    }
                }
            }
        }
        if min_degree == std::i32::MAX {
            return -1;
        }
        min_degree
    }
} 