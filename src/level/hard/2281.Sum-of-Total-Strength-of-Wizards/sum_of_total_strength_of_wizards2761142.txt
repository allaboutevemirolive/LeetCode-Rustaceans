// https://leetcode.com/problems/sum-of-total-strength-of-wizards/solutions/2761142/rust-came-in-clutch-for-me-with-128-bit-types-and-panic-on-overflow-o-n-solution/
struct StackObj {
    strength:           u64,
    n:                  usize,
}

impl StackObj {
    fn new(k: u64, iteration: usize) -> Self {
        Self {
            strength:   k,
            n:          iteration,
        }
    }
}

fn handle_stack(wizard: u64, stack: &mut Vec<StackObj>, sums: &Vec<u64>,
        cardinal_sums: &Vec<u128>, last_diff: u128, multiplicand: &mut u64,
        n: usize) -> u128 {

    let mut prev_diff = last_diff;
    let mut n_before = n - 1;
    loop {
        let len = stack.len();
        if wizard > stack[len - 1].strength {
            stack.push(StackObj::new(wizard, (n_before + 1) as usize));
            break;
        } else if wizard == stack[len - 1].strength {
            break;
        } else {
            let popped = stack.pop().unwrap();
            let p_len = n_before - popped.n + 1;
            let strength_diff = popped.strength - wizard;

            let stuff_multiplied = cardinal_sums[n_before]
                - (cardinal_sums[popped.n - 1] + (popped.n as u128 - 1)
                   * (sums[n_before] - sums[popped.n - 1]) as u128)
                + p_len as u128 * (sums[n - 1] - sums[n_before]) as u128;

            let mut moddif = prev_diff as i128
                - (stuff_multiplied * strength_diff as u128)as i128;
            if moddif < 0 {
                let x = 1 + -moddif / 1000000007;
                moddif += x * 1000000007;
                moddif %= 1000000007;
            }
            prev_diff = moddif as u128;
            *multiplicand -= p_len as u64 * strength_diff;
            n_before = popped.n - 1;
        }
    }
    *multiplicand += wizard;
    return prev_diff
}

impl Solution {
    pub fn total_strength(strength: Vec<i32>) -> i32 {
        let len = strength.len();
        let mut stack:          Vec<StackObj> = Vec::new();
        let mut sums:           Vec<u64> = vec![0; len + 1];
        let mut cardinal_sums:  Vec<u128> = vec![0; len + 1];
        let mut prev_diff:      u128 = 0; 
        let mut multiplicand:   u64 = 0;
        let mut total_strength: u128 = 0;

        stack.push(StackObj::new(0, 0));
        
        for n in 1..=strength.len() {
            let wizard = strength[n - 1] as u64;
            sums[n] = sums[n - 1] + wizard;
            cardinal_sums[n] = cardinal_sums[n - 1] + (wizard * n as u64) as u128;

            let mod_diff = handle_stack(wizard, &mut stack, &sums,
                &cardinal_sums, prev_diff, &mut multiplicand, n);
            let diff = (mod_diff + (multiplicand as u128 * wizard as u128) as u128) % 1000000007;
            total_strength = (total_strength + diff) % 1000000007;
            prev_diff = diff;
        } 
        return total_strength as i32
    }
}