// https://leetcode.com/problems/maximum-xor-with-an-element-from-array/solutions/997203/rust-btreeset-o-q-log-n-with-explanation/
impl Solution {
    pub fn maximize_xor(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {
        let vals: std::collections::BTreeSet<_> = nums.into_iter().collect();
        let res = |x: i32, m: i32| {
            let mut pref = 0;
            for i in (0..30).rev() {
                let scope = 1 << i;
                let bit = (x & scope) ^ scope;
                let rbit = bit ^ scope;
                let check = |b: i32| {
                    let lower = pref + b;
					let upper = (lower + scope).min(m + 1);
					return upper >= lower && vals.range(lower..upper).next().is_some();
                };
                pref += if check(bit) { bit } else if check(rbit) { rbit } else { return -1; }
            }
            pref ^ x
        };
        queries.into_iter().map(|v| res(v[0], v[1])).collect()
    }
}