// https://leetcode.com/problems/number-of-increasing-paths-in-a-grid/solutions/2244000/rust-divide-and-merge-memo-o-rows-cols/
use std::collections::HashMap;
const MOD:i64 = 1000000000 + 7;

impl Solution {
    pub fn count_paths(grid: Vec<Vec<i32>>) -> i32 {
        let (rows, cols) = (grid.len(), grid[0].len());
        let mut ans: i64 = 0;
        // let MOD = 1000000000 + 7;
        let mut f: HashMap<(usize, usize), i64> = HashMap::new(); 
        for r in 0..rows {
            for c in 0..cols {
                ans += dp(r, c, &grid, 0, &mut f);
                ans %= MOD;
            }
        }
        ans as i32
    }
}

pub fn dp(r:usize, c:usize, grid: &Vec<Vec<i32>>, pre:i32, mut f: &mut HashMap<(usize, usize), i64>) -> i64 {
    let (rows, cols) = (grid.len(), grid[0].len());
    if !(0 <= r && r < rows && 0 <= c && c < cols) || grid[r][c] <= pre {
        return 0;
    }
    if f.contains_key(&(r, c)) {
        return f[&(r,c)];
    }
    let mut ans:i64 = 1;
    ans += dp(r+1, c, grid, grid[r][c], f);
    if r > 0 {
        ans += dp(r-1, c, grid, grid[r][c], f);
    }
    ans += dp(r, c+1, grid, grid[r][c], f);
    if c > 0 {
        ans += dp(r, c-1, grid, grid[r][c], f);
    }
    f.insert((r, c), ans);
    ans % MOD
}