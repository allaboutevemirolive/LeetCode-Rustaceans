// https://leetcode.com/problems/maximum-number-of-robots-within-budget/solutions/2526318/rust-segment-tree-binary-search/
impl Solution {
    pub fn maximum_robots(charge_times: Vec<i32>, running_costs: Vec<i32>, budget: i64) -> i32 {
        let n = charge_times.len();
        let (mut tree, mut sum) = (vec![0; 4 * n], vec![0; n + 1]);
        
        for i in 0..n {
            Self::add(&mut tree, 1, 0, n - 1, i, charge_times[i]);
            sum[i + 1] = sum[i] + running_costs[i] as i64;
        }
        
        let (mut lo, mut hi) = (0, n);
        while lo < hi {
            let md = hi - (hi - lo) / 2;
            let mut good = false;
            for i in 0..=n - md {
                let mut temp = (sum[md + i] - sum[i]) * md as i64;
                temp += Self::get(&tree, 1, 0, n - 1, i, i + md - 1) as i64;
                if temp <= budget {
                    good = true;
                    break
                } 
            }
            if good { lo = md; }
            else    { hi = md - 1; }
        }
        lo as i32
    }
    
    fn add(tree: &mut Vec<i32>, u: usize, left: usize, right: usize, i: usize, val: i32) {
        if left == right {
            tree[u] = val;
            return
        }
        
        let mid = left + (right - left) / 2;
        
        if i <= mid { Self::add(tree, 2 * u,     left,    mid,   i, val); }
        else        { Self::add(tree, 2 * u + 1, mid + 1, right, i, val); }
        
        tree[u] = i32::max(tree[2 * u], tree[2 * u + 1]);
    }
    
    fn get(tree: &Vec<i32>, u: usize, left: usize, right: usize, l: usize, r: usize) -> i32 {
        if left > r || right < l { return 0 }
        if left >= l && right <= r { return tree[u]; }
        
        let mid = left + (right - left) / 2;
        
        let t1 = Self::get(tree, 2 * u,    left,     mid,   l, r);
        let t2 = Self::get(tree, 2 * u + 1, mid + 1, right, l, r);
        
        i32::max(t1, t2)
    }
}