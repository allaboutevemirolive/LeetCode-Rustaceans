// https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/solutions/1411975/rust-kruskal/
impl Solution {
    pub fn max_num_edges_to_remove(n: i32, edges: Vec<Vec<i32>>) -> i32 {

        fn find(x : usize, parent : &mut Vec<i32>) -> i32 {
            if parent[x] == -1 {
                return x as i32;
            }
            parent[x] = find(parent[x] as usize, parent);
            return parent[x];
        }

        fn union(x : usize, y : usize, rank :&mut Vec<i32>, parent : &mut Vec<i32>) -> bool {
            let s1 = find(x, parent);
            let s2 = find(y, parent);
            if s1 != s2 {
                if rank[s1 as usize] > rank[s2 as usize] {
                    rank[s1 as usize] = rank[s2 as usize];
                    parent[s2 as usize] = s1;
                } else {
                    rank[s2 as usize] = rank[s1 as usize];
                    parent[s1 as usize] = s2;
                }
                return true;
            }
            return false;
        }
        
        let heads_up = 1;
        let nodes_count = (n + heads_up) as usize;

        let mut parent_a = vec![-1; nodes_count];
        let mut rank_a = vec![1; nodes_count];

        let mut parent_b = vec![-1; nodes_count];
        let mut rank_b = vec![1; nodes_count];


        let mut input = edges.clone();
        input.sort_by(|a, b| b[0].partial_cmp(&a[0]).unwrap());

        let mut removable_path_count = 0;
        let mut merged_nodes_a_count = heads_up;
        let mut merged_nodes_b_count = heads_up;
        for ele in input.iter() {
            match ele[0] {
                1 => {
                    let a_merged = union(ele[1] as usize, ele[2] as usize,&mut rank_a, &mut parent_a);
                    if a_merged {
                        merged_nodes_a_count += 1;
                    } else {
                        removable_path_count += 1;
                    }
                }, 
                2 => {
                    let b_merged = union(ele[1] as usize, ele[2] as usize ,&mut rank_b,&mut parent_b);
                    if b_merged {
                        merged_nodes_b_count += 1;
                    } else {
                        removable_path_count += 1;
                    }
                },
                3 => {
                    let a_merged = union(ele[1] as usize, ele[2] as usize, &mut rank_a,&mut parent_a);
                    let b_merged = union(ele[1] as usize, ele[2] as usize,&mut rank_b,&mut parent_b);

                    if  a_merged && b_merged {
                        merged_nodes_a_count += 1;
                        merged_nodes_b_count += 1;
                    } else if !a_merged && !b_merged {
                        removable_path_count += 1;
                    }
                }
                _ => {}
            }
        }

        if merged_nodes_b_count == n && merged_nodes_a_count == n {
            return removable_path_count;
        }
        return -1;
    }
}