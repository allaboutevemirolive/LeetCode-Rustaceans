// https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/solutions/837213/rust-translated-76ms-100/
impl Solution {
    pub fn max_num_edges_to_remove(n: i32, mut edges: Vec<Vec<i32>>) -> i32 {
        fn find(mut i: i32, roots: &mut [i32]) -> i32 {
            let j = i;
            while roots[i as usize] != i {
                i = roots[i as usize];
            }
            roots[j as usize] = i;
            i
        }

        edges.sort_by_key(|x| -x[0]);
        let mut roots1 = (0..n + 1).collect::<Vec<i32>>();
        let mut roots2 = roots1.to_vec();
        let mut n1 = n;
        let mut n2 = n;
        let mut res = 0;
        for e in edges {
            if e[0] == 1 {
                let root_a = find(e[1], &mut roots1);
                let root_b = find(e[2], &mut roots1);
                if root_a == root_b {
                    // If roots are the same, then this is a redundant edge and can be removed.
                    res += 1;
                } else {
                    roots1[root_a as usize] = root_b; // If roots are different, we connect two different components.
                    n1 -= 1;
                }
            } else if e[0] == 2 {
                let root_a = find(e[1], &mut roots2);
                let root_b = find(e[2], &mut roots2);
                if root_a == root_b {
                    res += 1;
                } else {
                    roots2[root_a as usize] = root_b;
                    n2 -= 1;
                }
            } else {
                let root_a1 = find(e[1], &mut roots1);
                let root_b1 = find(e[2], &mut roots1);
                let root_a2 = find(e[1], &mut roots2);
                let root_b2 = find(e[2], &mut roots2);
                if root_a1 != root_b1 {
                    roots1[root_a1 as usize] = root_b1;
                    n1 -= 1;
                }
                if root_a2 != root_b2 {
                    roots2[root_a2 as usize] = root_b2;
                    n2 -= 1;
                }
                if root_a1 == root_b1 && root_a2 == root_b2 {
                    res += 1;
                }
            }
        }
        if n1 != 1 || n2 != 1 {
            return -1; // If total number of components is not one for either players, return -1.}
        }
        res
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_max_num_edges_to_remove() {
        assert_eq!(
            Solution::max_num_edges_to_remove(
                4,
                vec![
                    vec![3, 1, 2],
                    vec![3, 2, 3],
                    vec![1, 1, 3],
                    vec![1, 2, 4],
                    vec![1, 1, 2],
                    vec![2, 3, 4]
                ]
            ),
            2
        );
    }

    #[test]
    fn test_max_num_edges_to_remove_02() {
        assert_eq!(
            Solution::max_num_edges_to_remove(
                4,
                vec![vec![3, 1, 2], vec![3, 2, 3], vec![1, 1, 4], vec![2, 1, 4]]
            ),
            0
        );
    }

    #[test]
    fn test_max_num_edges_to_remove_03() {
        assert_eq!(
            Solution::max_num_edges_to_remove(4, vec![vec![3, 1, 2], vec![1, 1, 2], vec![2, 3, 4]]),
            -1
        );
    }
}