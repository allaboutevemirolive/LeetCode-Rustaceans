// https://leetcode.com/problems/selling-pieces-of-wood/solutions/2168389/rust-memoization/
use std::{
    cell::RefCell,
    cmp::Ordering,
    collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque},
    rc::Rc,
    vec,
};



impl Solution {
    pub fn selling_wood(m: i32, n: i32, prices: Vec<Vec<i32>>) -> i64 {
        let mut p: HashMap<(i32, i32), (i128, bool)> = HashMap::new();

        p.insert((0, 0), (0, true));
        p.insert((1, 0), (0, true));
        p.insert((0, 1), (0, true));
        p.insert((1, 1), (0, true));

        for price in &prices {
            let l = price[0];
            let h = price[1];
            let v = price[2] as i128;
            p.insert((l, h), (v, false));
        }

        let mut prices = p;

        // println!("{:?}", prices);


        fn helper(
            m: i32,
            n: i32,
            prices: &mut HashMap<(i32, i32), (i128, bool)>,
        ) -> i128 {
            // println!("HELPER CALL m {} n {}", m, n);

            let mut res = 0;
            if let Some((r, finalized)) = prices.get(&(m, n)) {
                if *finalized {
                    return *r;
                }
                res = *r;
            }

            // split m
            for i in 1..=(m - 1) {
                let sub_0 = helper(i, n, prices);
                let sub_1 = helper(m - i, n, prices);
                res = std::cmp::max(res, sub_0 + sub_1);
            }

            // split n
            for i in 1..=(n - 1) {
                let sub_0 = helper(m, i, prices);
                let sub_1 = helper(m, n - i, prices);
                res = std::cmp::max(res, sub_0 + sub_1);
            }

            // println!("HEPER m {} n {} res {} price {:?}", m, n, res, &prices);

            prices.insert((m, n), (res, true));
            res
        }

        // println!("{:?}", &prices);

        helper(m, n, &mut prices) as i64
    }
}
