// https://leetcode.com/problems/minimize-deviation-in-array/solutions/3224922/rust-30ms-3mb-pretreatment-sorting-optimizing/
impl Solution {
    pub fn minimum_deviation(mut nums: Vec<i32>) -> i32 {
        let n = nums.len();

        // use all possible *2 operations
        let mut min = i32::MAX;
        for i in 0..n {
            if nums[i] % 2 == 1 {
                nums[i] = nums[i] * 2;
            }
            min = i32::min(min, nums[i]);
        }

        // at this point we can do only /2 operations
        let mut max = i32::MIN;
        for i in 0..n {
            while nums[i] % 2 == 0 && nums[i] / 2 >= min {
                nums[i] = nums[i] / 2;
            }
            max = i32::max(max, nums[i]);
        }

        let mut best = max - min;
        // early return in case we can't optimize the solution
        if max % 2 == 1 {
            return best;
        }

        // lowest to highest with the propriety that highest/2 < lowest
        nums.sort();

        // otimize solution until we find an odd number
        let mut i = n - 1;
        while nums[i] % 2 == 0 {
            nums[i] = nums[i] / 2;

            min = nums[i];
            max = if i == 0 { nums [n - 1] } else { nums[i - 1] };
            best = i32::min(best, max - min);
            i = (i + n - 1) % n;
        }

        best
    }
}