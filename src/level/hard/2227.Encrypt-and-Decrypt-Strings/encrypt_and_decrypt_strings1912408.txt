// https://leetcode.com/problems/encrypt-and-decrypt-strings/solutions/1912408/rust-translated-from-lee215-s-solution/

use std::{
    cmp::{Ordering, Reverse},
    collections::{BinaryHeap, HashMap, HashSet},
    fmt::Binary,
    hash::Hash,
};

struct Encrypter {
    encode: HashMap<char, String>,
    count: HashMap<String, i32>,
}

impl Encrypter {
    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {
        let mut encode = HashMap::new();
        for i in 0..keys.len() {
            encode.insert(keys[i], values[i].clone());
        }

        let mut count = HashMap::new();
        let mut encrypter = Encrypter { encode, count };

        for w in dictionary {
            let encoded = Self::encrypt(&encrypter, w);
            *encrypter.count.entry(encoded).or_insert(0) += 1;
        }

        encryptera
    }

    fn encrypt(&self, word1: String) -> String {
        let mut res = String::new();
        for c in word1.chars() {
            let value = self.encode.get(&c).unwrap();
            res.push_str(value.as_str())
        }
        res
    }

    fn decrypt(&self, word2: String) -> i32 {
        match self.count.get(&word2) {
            Some(res) => *res,
            None => 0,
        }
    }
}

