// https://leetcode.com/problems/encrypt-and-decrypt-strings/solutions/2779845/rust-solution-with-hashmap-28-ms-6-3-mb/
use std::collections::HashMap;

struct Encrypter {
    value_map : [String; 26],
    dict_map : HashMap<String, i32>
}


impl Encrypter {
    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {
        let mut value_map : [String; 26] = Default::default();
        
        keys
		.into_iter()
		.zip(values.into_iter())
		.for_each(
			#[inline]
			|(key, value)| 
			value_map[(key as u8 - b'a') as usize] = value
		);
        
        let mut res = Self{
            value_map,
            dict_map : HashMap::with_capacity(5)
        };
        
        for word in dictionary {
            let key = res.encrypt(word);
            *res.dict_map.entry(key).or_insert(0) += 1;
        }
        
        res
    }
    
    fn encrypt(&self, word1: String) -> String {
        let mut res : String = String::with_capacity(word1.len() * 2);
        
        for b in word1.into_bytes() {
            if !self.value_map[(b - b'a') as usize].is_empty(){
                res.push_str(&self.value_map[(b - b'a') as usize]);
            } else {
                return String::new()
            }
        }
        
        res
    }
    
    fn decrypt(&self, word2: String) -> i32 {
        *self.dict_map.get(&word2).unwrap_or(&0)
    }
}