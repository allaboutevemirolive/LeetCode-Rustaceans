// https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/solutions/2593276/rust-dijkstra-easy/
use std::cmp::Reverse;
use std::collections::BinaryHeap;

const DIR: [(isize, isize); 4] = [(-1, 0), (0, -1), (0, 1), (1, 0)];

pub fn minimum_obstacles(grid: Vec<Vec<i32>>) -> i32 {
    let rows = grid.len();
    assert!(rows >= 1);

    let cols = grid[0].len();
    assert!(cols >= 1);

    let mut visited = vec![vec![i32::MAX; cols]; rows];
    visited[0][0] = grid[0][0];

    let mut pq = BinaryHeap::new();
    pq.push((Reverse(grid[0][0]), 0, 0));

    while let Some((Reverse(obs), r, c)) = pq.pop() {
        if r == rows - 1 && c == cols - 1 {
            return obs;
        }

        for (dr, dc) in DIR {
            let rx = r as isize + dr;
            let cx = c as isize + dc;
            if rx < 0 || cx < 0 {
                continue;
            }

            let rx = rx as usize;
            let cx = cx as usize;
            if rx >= rows || cx >= cols {
                continue;
            }

            let next_obs = obs + grid[rx][cx];
            if visited[rx][cx] <= next_obs {
                continue;
            }
            visited[rx][cx] = next_obs;

            pq.push((Reverse(next_obs), rx, cx));
        }
    }

    unreachable!()
}