// https://leetcode.com/problems/count-all-possible-routes/solutions/835382/rust-translated-44ms-100/
impl Solution {
    pub fn count_routes(locations: Vec<i32>, start: i32, dest: i32, fuel: i32) -> i32 {
        const MOD: i32 = 1_000_000_007;
        fn dfs(dp: &mut Vec<Vec<i32>>, loc: &[i32], from: i32, fuel: i32, dest: i32) -> i32 {
            if fuel < 0 {
                return 0;
            }
            if dp[from as usize][fuel as usize] > -1 {
                return dp[from as usize][fuel as usize];
            }
            let mut ans = if from == dest { 1 } else { 0 };
            for i in 0..loc.len() {
                if i as i32 == from {
                    continue;
                }
                ans =
                    (ans + dfs(
                        dp,
                        loc,
                        i as i32,
                        fuel - (loc[i] - loc[from as usize]).abs(),
                        dest,
                    )) % MOD;
            }
            dp[from as usize][fuel as usize] = ans;
            dp[from as usize][fuel as usize]
        }

        let mut dp = vec![vec![-1; fuel as usize + 1]; locations.len()];
        dfs(&mut dp, &locations, start, fuel, dest)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_count_routes() {
        assert_eq!(Solution::count_routes(vec![2, 3, 6, 8, 4], 1, 3, 5), 4);
    }

    #[test]
    fn test_count_routes_02() {
        assert_eq!(Solution::count_routes(vec![4, 3, 1], 1, 0, 6), 5);
    }

    #[test]
    fn test_count_routes_03() {
        assert_eq!(Solution::count_routes(vec![5, 2, 1], 0, 2, 3), 0);
    }

    #[test]
    fn test_count_routes_04() {
        assert_eq!(Solution::count_routes(vec![2, 1, 5], 0, 0, 3), 2);
    }

    #[test]
    fn test_count_routes_05() {
        assert_eq!(Solution::count_routes(vec![1, 2, 3], 0, 2, 40), 615088286);
    }
}