// https://leetcode.com/problems/string-compression-ii/solutions/2707474/rust-top-down-dp-with-comments/

use std::collections::HashMap;

pub fn get_length_of_optimal_compression(s: impl AsRef<[u8]>, k: i32) -> i32 {
    assert!(k >= 0);
    let k = k as usize;
    let s = s.as_ref();

    // Fast path: nothing to compress, because the string is empty,
    // or we have deleted everything
    if s.is_empty() || s.len() == k {
        return 0;
    }

    let mut cache = HashMap::new();
    solve(&s, &mut cache, (0, 0), 0, k)
}

fn solve(
    s: &[u8],
    cache: &mut HashMap<(usize, usize, (u8, i32)), i32>,
    state: (u8, i32),
    idx: usize,
    k: usize,
) -> i32 {
    if idx == s.len() {
        return 0;
    }

    // Do not recompute already computed results
    if let Some(count) = cache.get(&(k, idx, state)).copied() {
        return count;
    }

    let chr = s[idx];
    let next;
    let inc;

    if chr == state.0 {
        // If the previous character was the same, then update its count
        next = (state.0, state.1 + 1);
        // And check if it would lead to an increase in the string length
        // A count from 1 to 2, or 9 to 10, or 99 to 100, etc, lead to an 
        // increase by 1 character
        inc = len(next.1) - len(state.1);
    } else {
        // If the character is different, then set its initial count and 
        // length increment
        next = (chr, 1);
        inc = 1;
    }

    // Keep the current character
    let mut length = inc + solve(s, cache, next, idx + 1, k);

    // Delete the current character. If this character does not lead to
    // an increase in the length, then there is no need to try deleting it
    if k > 0 && inc > 0 {
        length = length.min(solve(s, cache, state, idx + 1, k - 1));
    }

    // Do not recompute already computed results
    cache.insert((k, idx, state), length);

    length
}

fn len(count: i32) -> i32 {
    match count {
        1 => 1,
        2..=9 => 2,
        10..=99 => 3,
        100..=999 => 4,
        1000..=9999 => 5,
        _ => panic!("invalid input: {}", count),
    }
}