// https://leetcode.com/problems/maximum-good-people-based-on-statements/solutions/1768345/rust-backtracking/
impl Solution {
    pub fn maximum_good(statements: Vec<Vec<i32>>) -> i32 {
        let mut res = 0;
        let mut assumptions = vec![];

        Solution::dfs(&statements, &mut assumptions, 0, 0, &mut res);

        res
    }

    fn dfs(
        statements: &Vec<Vec<i32>>,
        assumptions: &mut Vec<i32>,
        index: usize,
        count: i32,
        res: &mut i32,
    ) {
        // End of tree
        if index == statements.len() {
            if Solution::is_valid(statements, assumptions) {
                *res = std::cmp::max(*res, count);
            }
            return 
        }

        // Assuming good
        assumptions.push(1);
        Solution::dfs(statements, assumptions, index + 1, count + 1, res);
        assumptions.pop();

        // Assuming bad
        assumptions.push(0);
        Solution::dfs(statements, assumptions, index + 1, count, res);
        assumptions.pop();
    }

    fn is_valid(statements: &Vec<Vec<i32>>, assumptions: &Vec<i32>) -> bool {
        for i in 0..assumptions.len() {
            if assumptions[i] == 1 {
                for j in 0..assumptions.len() {
                    if statements[i][j] != 2 && statements[i][j] != assumptions[j] {
                        return false;
                    }
                }
            }
        }

        true
    }
}