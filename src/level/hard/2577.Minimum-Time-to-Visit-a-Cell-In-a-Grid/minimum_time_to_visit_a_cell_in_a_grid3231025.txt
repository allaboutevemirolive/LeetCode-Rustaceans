// https://leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/solutions/3231025/rust-djackstra/
use std::cmp::Reverse;
use std::collections::BinaryHeap;

impl Solution {
    pub fn minimum_time(grid: Vec<Vec<i32>>) -> i32 {
        let (m, n) = (grid.len(), grid[0].len());
        let mut pq = BinaryHeap::<Reverse<(i32, usize, usize)>>::new();
        let mut dist = vec![vec![i32::MAX; n]; m];

        if grid[0][1] <= 1 {
            dist[0][1] = 1;
            pq.push(Reverse((1, 0, 1)));
        }
        
        if grid[1][0] <= 1 {
            dist[1][0] = 1;
            pq.push(Reverse((1, 1, 0)));
        }
        
        let dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]];
        
        while let Some(Reverse((t, i, j))) = pq.pop() {
            if i == m - 1 && j == n - 1 { return t }
            if dist[i][j] < t { continue }
            for d in &dirs {
                let (u, v) = (i as i32 + d[0], j as i32 + d[1]);
                if u < 0 || u == m as i32 || v < 0 || v == n as i32 { continue }
                let (u, v) = (u as usize, v as usize);
                if dist[u][v] <= t + 1 { continue }
                
                let mut tm = t + 1;
                if tm < grid[u][v] { tm += (grid[u][v] - tm + 1) / 2 * 2; }
                dist[u][v] = tm;
                pq.push(Reverse((tm, u, v)));
            }
        }
        
        -1
    }
}