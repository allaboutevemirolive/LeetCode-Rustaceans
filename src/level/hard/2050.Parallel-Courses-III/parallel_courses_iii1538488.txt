// https://leetcode.com/problems/parallel-courses-iii/solutions/1538488/rust-solution/
impl Solution {
    pub fn minimum_time(n: i32, relations: Vec<Vec<i32>>, time: Vec<i32>) -> i32 {
        let n = n as usize;
        let mut graph = vec![vec![]; n];
        for r in relations {
            graph[(r[1] - 1) as usize].push((r[0] - 1) as usize);
        }
        let mut depth = vec![-1; n];
        (0..n)
            .map(|i| Solution::dfs(i, &mut depth, &graph, &time))
            .max()
            .unwrap()
    }

    fn dfs(i: usize, depth: &mut [i32], graph: &[Vec<usize>], time: &[i32]) -> i32 {
        if depth[i] == -1 {
            depth[i] = graph[i]
                .iter()
                .map(|&next| Solution::dfs(next, depth, graph, time))
                .max()
                .unwrap_or(0)
                + time[i];
        }
        depth[i]
    }
}