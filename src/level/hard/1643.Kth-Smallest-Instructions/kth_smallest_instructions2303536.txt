// https://leetcode.com/problems/kth-smallest-instructions/solutions/2303536/c-rust-recursive-combination/
impl Solution {
	fn comb(n: i32, r: i32) -> i32 {
		if r>n{return 0;}
		(1..=r).fold(1, |acc, i| acc*(n-i+1)/i)
	}
	pub fn kth_smallest_path(destination: Vec<i32>, k: i32) -> String {
		let (V,H) = (destination[0], destination[1]);
		if V==0 || H==0 || k==1 {
			let mut s = String::with_capacity((H+V)as usize);
			for _  in 0..H {s.push('H')};
			for _  in 0..V {s.push('V')};
			return s
		}
		let count = Self::comb(V+H-1, V);
		if k<= count {
			let destination: Vec<i32> = vec![V,H-1];
			return "H".to_string() + Self::kth_smallest_path(destination, k).as_str();
		}
		let destination: Vec<i32> = vec![V-1,H];
		"V".to_string() + Self::kth_smallest_path(destination, k - count).as_str()
	}
}