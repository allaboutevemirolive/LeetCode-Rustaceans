// https://leetcode.com/problems/count-ways-to-build-rooms-in-an-ant-colony/solutions/2948028/rust-solution/
const MOD: i64 = 1e9 as i64 + 7;

struct Combination {
    fact: Vec<i64>,
    infact: Vec<i64>
}

impl Combination {
    const N: usize = 1e5 as usize + 10;

    fn qpow(mut x: i64, mut n: i64) -> i64 {
        let mut res = 1;
        while n > 0 {
            if n & 1 == 1 {
                res = res * x % MOD;
            }
            x = x * x % MOD;
            n >>= 1;
        }
        res
    }

    pub fn new() -> Self {
        let mut fact = vec![0; Self::N];
        let mut infact = vec![0; Self::N];
        fact[0] = 1;
        infact[0] = 1;
        for i in 1..Self::N {
            fact[i] = fact[i - 1] * i as i64 % MOD;
            infact[i] = infact[i - 1] * Self::qpow(i as i64, MOD - 2) % MOD;
        }
        Combination {
            fact,
            infact
        }
    }

    // get C(a, b)
    pub fn get(&self, a: i64, b: i64) -> i64 {
        let (a, b) = (a as usize, b as usize);
        self.fact[a] * self.infact[a - b] % MOD * self.infact[b] % MOD
    }
}


impl Solution {
    // solve recursively
    // first return value is op steps, second is number of ways
    fn solve(u: i64,  edges: &Vec<Vec<i64>>, combination: &Combination) -> (i64, i64) {
        let mut ul: i64 = 0;
        let mut uw: i64 = 1;
        for v in edges[u as usize].iter() {
            let (vl, vw) = Self::solve(*v, &edges, &combination);
            ul += vl;
            // if this is the first subtree
            if uw == 0 {
                uw = vw;
            } else {
                uw = uw * vw % MOD * combination.get(ul, vl) % MOD;
            }
        }
        // add one step: the root
        ul += 1;
        (ul, uw)
    }

    pub fn ways_to_build_rooms(prev_room: Vec<i32>) -> i32 {
        // build edges
        let combination = Combination::new();
        let n = prev_room.len();
        let mut edges = vec![vec![]; n];
        for i in 1..n {
            edges[prev_room[i] as usize].push(i as i64);
        }
        let (_, rw) = Self::solve(0, &edges, &combination);
        rw as i32
    }
}