// https://leetcode.com/problems/rearranging-fruits/solutions/3145749/btreemap-and-two-ways-to-swap-approach-in-rust/
impl Solution {
    pub fn min_cost(basket1: Vec<i32>, basket2: Vec<i32>) -> i64 {
        let costs = std::collections::BTreeMap::<i32, i32>::new();
        let costs = basket1.iter().fold(costs, |mut costs, &cost| { *costs.entry(cost).or_insert(0) += 1; costs });
        let costs = basket2.iter().fold(costs, |mut costs, &cost| { *costs.entry(cost).or_insert(0) -= 1; costs });
        let mut swaps = Vec::<i32>::new();
        for (cost, count) in costs.iter().map(|(&cost, &count)| (cost, count.abs() as usize)) {
            if count & 1 > 0 {
                return -1;
            }
            swaps.extend(std::iter::repeat(cost).take(count >> 1));
        }
        let mut cost = 0;
        if let Some(small) = costs.keys().next().map(|&val| val as i64) {
            for swap in swaps.iter().take(swaps.len() >> 1).map(|&val| val as i64) {
                cost += swap.min(2 * small);
            }
        }

        cost
    }
}