// https://leetcode.com/problems/longest-increasing-subsequence-ii/solutions/2561915/rust-segment-tree/
impl Solution {
    pub fn length_of_lis(nums: Vec<i32>, k: i32) -> i32 {
        let n = *nums.iter().max().unwrap() as usize + 1;
        let mut tree = vec![0; 4 * n];
        let mut ret = 1;
        
        for a in nums {
            let temp = Self::find(&tree, 1, 0, n - 1, i32::max(0, a - k) as usize, a as usize - 1);
            ret = ret.max(temp + 1);
            Self::update(&mut tree, 1, 0, n - 1, a as usize, temp + 1);
        }
        
        ret
    }
    
    fn find(tree: &Vec<i32>, u: usize, left: usize, right: usize, l: usize, r: usize) -> i32 {
        if l > right || r < left { return 0 }
        if left == right { return tree[u] }
        if left >= l && right <= r { return tree[u] }
        
        let mid = left + (right - left) / 2;
        
        let ret1 = Self::find(tree, 2 * u, left, mid, l, r);
        let ret2 = Self::find(tree, 2 * u + 1, mid + 1, right, l, r);
        
        ret1.max(ret2)
    }
    
    fn update(tree: &mut Vec<i32>, u: usize, left: usize, right: usize, i: usize, val: i32) {
        if left == right {
            tree[u] = val;
            return
        }
        
        let mid = left + (right - left) / 2;
		
        if i <= mid { Self::update(tree, 2 * u, left, mid, i, val); }
        else        { Self::update(tree, 2 * u + 1, mid + 1, right, i, val); }
        
        tree[u] = i32::max(tree[2 * u], tree[2 * u + 1]);
    }
}