// https://leetcode.com/problems/maximum-height-by-stacking-cuboids/solutions/2837460/rust-o-n-2-dp-sorting-with-comments/
impl Solution {
    pub fn max_height(mut cuboids: Vec<Vec<i32>>) -> i32 {
        // sort inner dimensions
        cuboids = cuboids.into_iter().map(|mut v| {
            v.sort_by(|a, b| b.cmp(&a));
            v
        }).collect::<Vec<Vec<i32>>>();
        
        // sort cuboids by largest dimension
        cuboids.sort_by(|a, b| b.cmp(&a));
        
        // d[i] == optimal solution ending with cuboid i
        //
        // just set to largest dimension - this is just assuming we are
        // only consider each cuboid on its own
        let mut dp: Vec<i32> = cuboids.clone()
                                    .into_iter()
                                    .map(|v| v[0])
                                    .collect::<Vec<i32>>();
        
        let mut max = 0;
        
        for (i, c1) in cuboids.iter().enumerate() {
            for (j, c2) in cuboids.iter().enumerate() {
                // break if c2 is smaller than c1 (can't be placed under)
                if i == j { break; }
                // make sure that c2 can be placed under c1
                //
                // these rules have been provided to us in the problem statement.
                // this would be much more difficult if it only required two
                // dimensions to be less to place on top (i.e., just area) :)
                if c2[0] >= c1[0] && c2[1] >= c1[1] && c2[2] >= c1[2] {
                    // check if new height (that ending in c2) + c1's
                    // max dimension is optimal for c1!
                    dp[i] = std::cmp::max(dp[i], dp[j] + c1[0]);
                }
            }
            max = std::cmp::max(max, dp[i]);
        }
        
        max
    }
}