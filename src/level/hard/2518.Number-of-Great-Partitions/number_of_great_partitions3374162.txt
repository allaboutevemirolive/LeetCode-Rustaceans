// https://leetcode.com/problems/number-of-great-partitions/solutions/3374162/o-n-k-solution-in-rust/
impl Solution {
    pub fn count_partitions(nums: Vec<i32>, k: i32) -> i32 {
        let m = 1000000007_u32;
        let n = nums.len();
        let k = k as usize;
        if nums.iter().map(|&v| v as usize).sum::<usize>() < k * 2 {
            0
        } else {
            let mut dp = vec![vec![0_u32; k]; n];
            for i in 0..k {
                dp[0][i] = 1 + u32::from((nums[0] as usize) <= i);
            }
            for i in 1..n {
                for j in 0..k {
                    if j >= nums[i] as usize {
                        dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - nums[i] as usize]) % m;
                    } else {
                        dp[i][j] = dp[i - 1][j];
                    }
                }
            }
            (((0..n).fold(1, |y, _| y * 2 % m) + m * 2 - dp[n - 1][k - 1] * 2) % m) as i32
        }
    }
}
