// https://leetcode.com/problems/number-of-pairs-satisfying-inequality/solutions/2648017/rust-solution-using-segment-tree/
use std::collections::BTreeMap;

impl Solution {
    pub fn number_of_pairs(nums1: Vec<i32>, nums2: Vec<i32>, diff: i32) -> i64 {
        let n = nums1.len();
        let mut mp = BTreeMap::<i32, i32>::new();

        for i in 0..n {
            *mp.entry(nums1[i] - nums2[i]).or_default() += 1;
        }

        let  m = mp.len();
        let mut tree = vec![0; m * 4];
        let mut index = vec![];

        for (key, val) in mp {
            let i = index.len();
            Self::add(1, 0,  m - 1, i, val as usize, &mut tree);
            index.push(key);
        }

        let mut ret = 0;
        for i in (0..n).rev() {
            let j = Self::binary_search(&index, nums1[i] - nums2[i]);
            Self::remove(1, 0,  m - 1, j, &mut tree);
            let k = Self::binary_search(&index, nums1[i] - nums2[i] +  diff + 1);
            ret += i as i64 - Self::get(1, 0, m - 1, k, &tree) as i64;  
        }
        
        ret
    }

    fn binary_search(index: &Vec<i32>, val: i32) -> usize {
        let m  = index.len();
        if index[m - 1] < val { return m }

        let (mut left, mut right) = (0, m - 1);

        while left < right {
            let mid = left + (right - left) / 2;
            
            if index[mid] >= val {right = mid; }
            else { left = mid + 1; }
        }

        left
    }

    fn add(u: usize, left: usize, right: usize, i: usize,  val: usize, tree: &mut Vec<usize>) {
        if i < left || i > right { return }
        if left == right {
            tree[u] += val;
            return
        } 

        let mid = left + (right - left) / 2;

        if i <= mid { Self::add(2 * u, left, mid, i, val, tree); }
        else        { Self::add(2 * u + 1, mid + 1, right, i, val, tree); }

        tree[u] = tree[2 * u] + tree[2 * u + 1];
    }

    fn remove(u: usize, left: usize, right: usize, i: usize, tree: &mut Vec<usize>) {
        if i < left || i > right { return }
        if left == right {
            tree[u] -= 1;
            return
        }

        let mid = left + (right - left) / 2;
        if i <= mid { Self::remove(2 * u, left, mid, i, tree); }
        else         { Self::remove(2 * u + 1, mid + 1, right, i,  tree); }

        tree[u] = tree[2 * u] + tree[2 * u + 1];
    }

    fn get(u: usize, left: usize, right: usize, i: usize, tree: &Vec<usize>) -> i32 {
        if i > right { return 0 }
        if i <= left { return tree[u] as i32; }

        let mid = left + (right - left) / 2;

        Self::get(2 * u, left, mid, i, tree) + Self::get(2 * u + 1, mid + 1, right, i,tree)
    }
}