// https://leetcode.com/problems/meeting-rooms-iii/solutions/2545322/rust-45-ms-fastest-100-solution-with-two-priority-queues-with-detailed-comments/
use std::{collections::BinaryHeap, cmp::Reverse};

impl Solution 
{
    pub fn most_booked(n: i32, mut meetings: Vec<Vec<i32>>) -> i32 
    {
        let n = n as usize;
        // [1] sort meetings by start time (in place);
        //     all start times are unique, thus, can safely apply unstable sort
        meetings.sort_unstable_by_key(|m| m[0]);
        
        // [2] priority queue for busy rooms (with preallocated capacity)
        let mut busy_rooms: BinaryHeap<Reverse<(u64,usize)>> = BinaryHeap::with_capacity(n);
        
        // [3] priority queue for free rooms (with preallocated capacity)
        let mut free_rooms: BinaryHeap<Reverse<usize>>       = BinaryHeap::with_capacity(n);
        
        // [4] meetings count (initialized with 0's)
        let mut n_meetings: Vec<usize> = vec![0;n];
        
        // [5] all rooms are free in the beginning
        for i in 0..n { free_rooms.push(Reverse(i)); }

        // [6] iterate over meetings
        let mut start : u64;
        let mut end   : u64;
        
        for m in meetings
        {
            start = m[0] as u64;
            end   = m[1] as u64;
            
            // [7] move all rooms with ended meetings into free rooms
            while let Some(&Reverse((room_end, room))) = busy_rooms.peek()
            {
                if room_end <= start
                {
                    free_rooms.push(Reverse(room));
                    busy_rooms.pop();
                } else { break; }
            }
            
            // [8] if there are free rooms available, pick one with the lowest number
            let (new_room_end, room) = if (!free_rooms.is_empty())
            {
                let Reverse(room) = free_rooms.pop().unwrap();
                (end, room)
            }
            // [9] if there are no free rooms, pick one with the lowest end time
            else
            {
                let Reverse((room_end, room)) = busy_rooms.pop().unwrap();
                (room_end + end - start, room)
            };
            
            // [10] update room
            busy_rooms.push(Reverse((new_room_end, room)));
            n_meetings[room] += 1;
        }
        
        // [11] find minimal index of maximal element
        n_meetings
            .into_iter()
            .enumerate()
            .max_by_key(|x| (x.1, Reverse(x.0)))
            .unwrap().0 as i32

    }
}