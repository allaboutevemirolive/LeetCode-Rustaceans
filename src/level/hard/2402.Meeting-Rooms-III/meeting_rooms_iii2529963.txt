// https://leetcode.com/problems/meeting-rooms-iii/solutions/2529963/rust-solution-using-binaryheap/
use std::collections::BinaryHeap;
use std::cmp::Reverse;

impl Solution {
    pub fn most_booked(n: i32, meetings: Vec<Vec<i32>>) -> i32 {
        let n = n as usize;
        let mut cnt = vec![0; n];
        let mut pq = BinaryHeap::<Reverse<(usize, i64)>>::new();
        let mut wait = BinaryHeap::<Reverse<(i64, usize)>>::new();
        let mut time = 0i64;
        let mut meetings = meetings;
        
        for i in 0..n {
            pq.push(Reverse((i, 0)));
        }
        
        meetings.sort();
        for m in meetings {
            if pq.is_empty() {
                let Reverse((v, i)) = wait.peek().unwrap();
                time = time.max(*v); 
            }
            time = time.max(m[0] as i64);
            while let Some(Reverse((v, i))) = wait.peek() {
                if *v > time { break }
                pq.push(Reverse((*i, *v)));
                wait.pop();
            }
            let Reverse((i, _)) = pq.pop().unwrap();
            cnt[i] += 1;
            wait.push(Reverse((time + (m[1] - m[0]) as i64, i)));
        }
        
        let (mut ret, mut mx) = (n - 1, cnt[n - 1]);
        for i in (0..n - 1).rev() {
            if cnt[i] < mx { continue }
            ret = i;
            mx = cnt[i];
        }
        
        ret as i32
    }
}