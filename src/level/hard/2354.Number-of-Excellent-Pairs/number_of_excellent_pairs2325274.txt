// https://leetcode.com/problems/number-of-excellent-pairs/solutions/2325274/rust-sorting-binary-searching/
//One important observation is that: 
// number of set bits in a&b + number of set bits in a|b  = number of set bits in a + number of set bits in b. 
//Therefore, we just need to sort the numbers based on the number of set bits and 
// use binary searching to find the answer. 

use std::collections::HashSet;
impl Solution {
    pub fn count_excellent_pairs(nums: Vec<i32>, k: i32) -> i64 {
        let mut s: HashSet<i32> = HashSet::new();
        let mut v = vec![];
        
        for a in nums {
            if s.contains(&a) { continue; }
            s.insert(a);
            let mut cnt = 0;
            for i in 0..32 {
                if (a & (1 << i)) > 0 { cnt += 1; }
            }
            v.push(cnt);
        }
        v.sort();
        
        let mut ret: i64 = 0;
        for a in &v {
            ret += Self::binary_search(&v, k - *a);
        }
        
        ret
    }
    
    fn binary_search(v: &Vec<i32>, a: i32) -> i64 {
        let (mut left, mut right) = (0, v.len() - 1);
        if a > v[v.len() - 1] { return 0i64 }
        
        while (left < right) {
            let mid = left + (right - left) / 2;
            if v[mid] < a { left = mid + 1; }
            else { right = mid; }
        }
        
        (v.len() - left) as i64
    }
}