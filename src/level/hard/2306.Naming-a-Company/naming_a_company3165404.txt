// https://leetcode.com/problems/naming-a-company/solutions/3165404/rust-grouping-by-letters/
impl Solution {
    pub fn distinct_names(ideas: Vec<String>) -> i64 {
        distinct_names(ideas)
    }
}



use std::collections::HashSet;

const ASCII_LEN: usize = (b'z' - b'a' + 1) as usize;

pub fn distinct_names(ideas: Vec<String>) -> i64 {
    let mut words = HashSet::new();
    let mut letters = 0u32;

    for word in ideas.iter().map(|w| w.as_bytes()) {
        words.insert(word);
        letters |= 1 << (word[0] - b'a');
    }

    // Track how many words starting with letter X
    // can be converted to words starting with letter Y
    let mut words_by_letter = [[0; ASCII_LEN]; ASCII_LEN];

    // A buffer to store the current word. We can reuse
    // this buffer in order to avoid unnecessary allocations
    let mut buf = Vec::with_capacity(10);

    for word in ideas.iter().map(|w| w.as_bytes()) {
        buf.clear();
        buf.extend_from_slice(word);

        for x in b'a'..=b'z' {
            if x == word[0] {
                // Cannot replace the first letter with the same letter
                continue;
            }

            // In the `ideas` list there are no words that start with X
            // thus we can skip checking if such word exist. Also there
            // is no need to count this combination, because it will end
            // up multiplied by 0, thus resulting in a 0.
            if letters & 1 << (x - b'a') == 0 {
                continue;
            }

            buf[0] = x;
            if words.contains(buf.as_slice()) {
                continue;
            }

            words_by_letter[(word[0] - b'a') as usize][(x - b'a') as usize] += 1;
        }
    }

    let mut answer = 0;
    for i in 0..words_by_letter.len() {
        for j in i + 1..words_by_letter.len() {
            answer += words_by_letter[i][j] * words_by_letter[j][i] * 2;
        }
    }

    answer
}