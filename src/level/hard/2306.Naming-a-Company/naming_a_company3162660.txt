// https://leetcode.com/problems/naming-a-company/solutions/3162660/rust-disjoint-suffixes-in-normal-form/
use std::collections::HashMap;
use std::collections::HashSet;

impl Solution {
    pub fn distinct_names(ideas: Vec<String>) -> i64 {
        let index = Self::index_by_first_letter(&ideas);
        // println!("Index: {index:?}");
        let mut retval = 0;
        for i in 1 .. index.len() {
            for j in 0 .. i {
                // For each key pair, we want card(A \ B) * card(B \ A)
                let left = index[i].len();
                let right = index[j].len();
                if left == 0 || right == 0 {  // shortcut
                    continue;
                }
                let shared = index[i].intersection(&index[j]).count();
                let new_pairs = (left - shared) * (right - shared);
                retval += (new_pairs as i64);
            }
        }
        // The problem counts both "A B" and "B A" separately.
        retval * 2
    }

    fn index_by_first_letter(ideas: &[String]) -> [HashSet<usize>; 26] {
        // Time: O(n); space: O(n)
        let mut retval: [HashSet<usize>; 26] = Default::default();
        // A database would call this "normalised form".
        // We only use equality, so the actual "strings" are safely discarded.
        let mut literal_pool: HashMap<&[u8], usize> = HashMap::new();
        let mut autoinc = 0;
        for word in ideas.iter() {
            let w: &[u8] = word.as_bytes();
            let h = (w[0] - b'a') as usize;
            let t = &w[1..];  // the empty string is no different from the others
            let id: usize = *literal_pool.entry(t)
                .or_insert_with(|| {
                    autoinc += 1;
                    autoinc
                });
            retval[h].insert(id);
        }
        retval
    }

    // De-normalised data
    // fn index_by_first_letter<'a>(ideas: &'a [String]) -> [HashSet<&'a [u8]>; 26] {
    //     let mut retval: [HashSet<&'a [u8]>; 26] = Default::default();
    //     for word in ideas.iter() {
    //         let w: &[u8] = word.as_bytes();
    //         let h = (w[0] - b'a') as usize;
    //         let t = &w[1..];
    //         retval[h].insert(t);
    //     }
    //     retval
    // }
}