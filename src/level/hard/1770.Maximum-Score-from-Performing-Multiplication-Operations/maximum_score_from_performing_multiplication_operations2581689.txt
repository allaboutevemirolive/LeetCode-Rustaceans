// https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations/solutions/2581689/rust-inspired-by-pascal-s-triangle-linear-space-quadratic-time/
impl Solution {
    pub fn maximum_score(nums: Vec<i32>, multipliers: Vec<i32>) -> i32 {
        // Intuition: think of Pascal's triangle and flipping coins.
		// While the combinations blow up as O(2^n), the space blows up as O(n).
        // Let (L,R) be the number of elements taken from each end of `nums`.
		// (This is analogous to (heads,tails) when flipping coins.)
        // For any given (L,R) pair, there exists a maximum score.
        // These are the "stages" like in the travelling stagecoach problem.
        let m = multipliers.len();
        let n = nums.len();
        let mut current: Vec<i32> = vec![0; m+1];
        let mut future: Vec<i32> = vec![0; m+1];
        // For each row in Pascal's triangle:
        for (idx, coeff) in multipliers.into_iter().enumerate().rev() {
            // For each cell along that row:
            for l in (0 ..= idx).rev() {
                let cand_l = current[l+1] + nums[l] * coeff;
                let cand_r = current[l] + nums[n - 1 - idx + l] * coeff;
				// Which candidate has the better score for the stage?
                future[l] = cand_l.max(cand_r);
            }
            current[0 ..= idx].copy_from_slice(&future[0 ..= idx]);
        }
        current[0]
    }
}