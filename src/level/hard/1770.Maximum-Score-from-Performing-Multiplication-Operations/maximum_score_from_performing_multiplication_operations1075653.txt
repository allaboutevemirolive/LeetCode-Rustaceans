// https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations/solutions/1075653/rust-dp-solution-with-unit-test/
struct Solution;

#[allow(dead_code)]
impl Solution {
    pub fn maximum_score(nums: Vec<i32>, muls: Vec<i32>) -> i32 {
        let n = nums.len();
        let m = muls.len();
        let mut memo = vec![vec![std::i32::MIN; m]; n];
        Self::dp(0, 0, n, m, &nums, &muls, &mut memo)
    }
    fn dp(
        k: usize,
        i: usize,
        n: usize,
        m: usize,
        nums: &Vec<i32>,
        muls: &Vec<i32>,
        memo: &mut Vec<Vec<i32>>,
    ) -> i32 {
        if i == m {
            return 0;
        }
        if memo[k][i] != std::i32::MIN {
            return memo[k][i];
        }
        let left = Self::dp(k + 1, i + 1, n, m, nums, muls, memo) + nums[k] * muls[i];
        let right = Self::dp(k, i + 1, n, m, nums, muls, memo) + nums[n - i + k - 1] * muls[i];
        memo[k][i] = std::cmp::max(left, right);
        memo[k][i]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_solution() {
        let nums = vec![1, 2, 3];
        let muls = vec![3, 2, 1];
        assert_eq!(14, Solution::maximum_score(nums, muls));
        let nums = vec![-5, -3, -3, -2, 7, 1];
        let muls = vec![-10, -5, 3, 4, 6];
        assert_eq!(102, Solution::maximum_score(nums, muls));
    }
}