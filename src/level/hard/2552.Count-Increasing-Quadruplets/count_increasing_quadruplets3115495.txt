// https://leetcode.com/problems/count-increasing-quadruplets/solutions/3115495/rust-binary-indexed-tree/
impl Solution {
    pub fn count_quadruplets(nums: Vec<i32>) -> i64 {
        let n = nums.len() + 1;
        let mut tree = vec![0; n + 1];
        let mut data = vec![vec![0; n]; n];

        for i in 0 .. n - 1 {
            for k in 1 .. n {
                data[i][k] = Self::sum(k, &mut tree);
            }
                
            Self::add(nums[i] as usize, &mut tree);
        }

        let mut ret = 0;
        for j in 1 .. n - 2 {
            for k in j + 1 .. n - 1 {
                if nums[j] < nums[k] { continue }
                
                // total # of items > nums[j]
                let mut t = n as i64 - 1 - nums[j] as i64;
                //taking away those that are on k's left 
                t -= data[k][n - 1] - data[k][nums[j] as usize];
                // t is the # of items that are on k's right and > nums[j]   
                // data[j][nums[k] is the # of items on j's left and < nums[k]
                ret += data[j][nums[k] as usize - 1] * t;    
            }
        }
        
        ret
    }

    fn add(i: usize, tree: &mut Vec<i64>) {
        let mut i = i + 1;
        
        while i < tree.len() {
            tree[i] += 1;
            i += ((i as i32) & -(i as i32)) as usize; 
        }
    }

    fn sum(i: usize, tree: &mut Vec<i64>) -> i64 {
        let mut i = i + 1;
        let mut ret = 0;

        while i > 0 {
            ret += tree[i];
            i -= ((i as i32) & -(i as i32)) as usize;
        }
        ret
    }
}