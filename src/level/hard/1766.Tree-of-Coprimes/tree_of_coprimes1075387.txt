// https://leetcode.com/problems/tree-of-coprimes/solutions/1075387/rust-dfs/
use std::collections::HashMap;
use std::collections::HashSet;

struct Solution;

#[allow(dead_code)]
impl Solution {
    pub fn get_coprimes(nums: Vec<i32>, edges: Vec<Vec<i32>>) -> Vec<i32> {
        let mut graph: HashMap<i32, Vec<i32>> = HashMap::new();
        for edge in edges {
            if let [u, v] = &edge[..] {
                graph.entry(*u).or_insert(vec![]).push(*v);
                graph.entry(*v).or_insert(vec![]).push(*u);
            }
        }

        let mut seen: HashSet<i32> = HashSet::new();
        let mut path: Vec<Vec<(i32, i32)>> = vec![vec![]; 51];
        let mut ans = vec![-1; nums.len()];

        pub fn dfs(
            node: i32,
            depth: i32,
            nums: &Vec<i32>,
            seen: &mut HashSet<i32>,
            graph: &HashMap<i32, Vec<i32>>,
            path: &mut Vec<Vec<(i32, i32)>>,
            ans: &mut Vec<i32>,
        ) {
            pub fn gcd(a: i32, b: i32) -> i32 {
                if b == 0 {
                    a
                } else {
                    gcd(b, a % b)
                }
            }

            if seen.contains(&node) {
                return;
            }
            seen.insert(node);
            let mut max_depth = -1;
            for x in 1..51 {
                if gcd(nums[node as usize], x) == 1 {
                    match path[x as usize].len() {
                        0 => {}
                        n => {
                            let this_node = &path[x as usize][n - 1].0;
                            let this_depth = &path[x as usize][n - 1].1;
                            if *this_depth > max_depth {
                                max_depth = *this_depth;
                                ans[node as usize] = *this_node;
                            }
                        }
                    }
                }
            }
            path[nums[node as usize] as usize].push((node, depth));
            match graph.get(&node) {
                None => {}
                Some(neighbors) => {
                    for nei in neighbors {
                        dfs(*nei, depth + 1, nums, seen, graph, path, ans);
                    }
                }
            }
            path[nums[node as usize] as usize].pop();
        }
        dfs(0, 0, &nums, &mut seen, &graph, &mut path, &mut ans);
        ans
    }
}