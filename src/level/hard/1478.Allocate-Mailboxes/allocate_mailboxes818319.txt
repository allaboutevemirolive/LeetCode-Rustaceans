// https://leetcode.com/problems/allocate-mailboxes/solutions/818319/rust-translated/
impl Solution {
    pub fn min_distance(mut houses: Vec<i32>, k: i32) -> i32 {
        fn helper(h: &[i32], start: i32, k: i32, memo: &mut Vec<Vec<i32>>) -> i32 {
            if k == 1 {
                let end = h.len() as i32 - 1;
                let med = (end - start) / 2 + start;
                let mean = h[med as usize];
                return h
                    .iter()
                    .skip(start as usize)
                    .fold(0, |acc, &x| acc + (x - mean).abs());
            }
            if memo[start as usize][k as usize] != -1 {
                return memo[start as usize][k as usize];
            }
            let mut t = start;
            let mut ans = std::i32::MAX;
            while h.len() as i32 - 1 - t >= k - 1 {
                let med = (t - start) / 2 + start;
                let mut res = 0;
                for i in start..=t {
                    res += (h[i as usize] - h[med as usize]).abs();
                }
                res += helper(h, t + 1, k - 1, memo);
                if ans > res {
                    ans = res
                }
                t += 1;
            }
            memo[start as usize][k as usize] = ans;
            ans
        }

        let n = houses.len();
        if k >= n as i32 {
            return 0;
        }
        houses.sort();
        let mut memo = vec![vec![-1; k as usize + 1]; n];
        helper(&houses, 0, k, &mut memo)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_min_distance() {
        assert_eq!(Solution::min_distance(vec![1, 4, 8, 10, 20], 3), 5)
    }

    #[test]
    fn test_min_distance_02() {
        assert_eq!(Solution::min_distance(vec![2, 3, 5, 12, 18], 2), 9)
    }

    #[test]
    fn test_min_distance_03() {
        assert_eq!(Solution::min_distance(vec![7, 4, 6, 1], 1), 8)
    }

    #[test]
    fn test_min_distance_04() {
        assert_eq!(Solution::min_distance(vec![3, 6, 14, 10], 4), 0)
    }
}