// https://leetcode.com/problems/maximum-number-of-visible-points/solutions/942472/rust-sliding-window/
use std::f64::consts::PI;
impl Solution {
    pub fn visible_points(points: Vec<Vec<i32>>, angle: i32, location: Vec<i32>) -> i32 {
        if points.len() == 0 {
            return 0;
        }
        let mut extra = 0;
        let mut angles = points.iter()
            .filter(|p| if p[0] == location[0] && p[1] == location[1] {extra+=1;false} else {true} )
            .map(|p| ((location[1]-p[1]) as f64).atan2((location[0]-p[0]) as f64) )
            .map(|a| 360.0*(if a < 0.0 { a + 2.0*PI } else {a})/(2.0*PI) )
            .collect::<Vec<_>>();
        for i in 0..angles.len() {
            angles.push(angles[i]+360.0);
        }
        if angles.len() == 0 {
            return extra as i32;
        }
        
        angles.sort_by(|a, b| a.partial_cmp(b).unwrap());
        let angle = angle as f64;
        let mut best = 1;
        let mut l = 0;
        let mut r = 1;
        while r < angles.len() && l < angles.len() {
            while r < angles.len() && angles[r] - angles[l] <= angle {
                r += 1;
            }
            best = best.max(r-l);
            l += 1;
        }
        (extra+best) as i32
    }
}