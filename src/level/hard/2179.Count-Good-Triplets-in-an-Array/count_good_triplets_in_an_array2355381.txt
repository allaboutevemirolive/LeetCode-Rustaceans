// https://leetcode.com/problems/count-good-triplets-in-an-array/solutions/2355381/rust-segment-tree-with-brief-comments/
// https://cp-algorithms.com/data_structures/segment_tree.html

impl Solution {
    pub fn good_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i64 {
        let n = nums1.len();
        let mut nums2 = nums2;
        
		// Sort nums2 relatively in the order of nums1. We only need to count those (i, j, k)
        // where 0 <= i < j < k < n & nums1[i] < nums2[j] < nums2[k], or
        // sum(for each i: # of smaller on the left * # of bigger on the right )
		let mut mp = vec![0i32; n];
        for i in 0..n { mp[nums1[i] as usize] = i as i32; }    
        for i in 0..n { nums2[i] = mp[nums2[i] as usize]; }
        
        let mut ret = 0i64; 
        let mut tree = vec![0i32; 4 * n];
        
        for i in 0..n {
            if nums2[i] > 0 {
                // how many of values < *a have been updated in the segment tree?
                let smaller_counter = Self::count(1, 0, n - 1, 0, nums2[i] as usize - 1, &tree);
                let bigger_counter = n as i64 - 1 - nums2[i] as i64 - (i as i64 - smaller_counter);
                ret += smaller_counter * bigger_counter;
            }
            Self::update(1, 0, n - 1, nums2[i] as usize, &mut tree);
        }
        
        ret
    }
    
    // to enter a value i in the segment tree, we set the value at the leaf node to one
    fn update(u: usize, left: usize, right: usize, i: usize, tree: &mut Vec<i32>) {
        if left == right {
            tree[u] = 1;
            return;
        }
        
        let mid = left + (right - left) / 2;
        
        if i <= mid { Self::update(2 * u, left, mid, i, tree); }
        else { Self::update(2 * u + 1, mid + 1, right, i, tree); }
        
        tree[u] = tree[2 * u] + tree[2 * u + 1];
    }
    
    // to count the # of leaf nodes that have value set to 1 with index bounded by (l, r)
    fn count(u: usize, left: usize, right: usize, l: usize, r: usize, tree: &Vec<i32>) ->i64 {
        if left >= l && right <= r {
            return tree[u] as i64;
        }
        
        if left > r || right < l { return 0}
        
        let mid = left + (right - left) / 2;
        
        Self::count(2 * u, left, mid, l, r, tree) + Self::count(2 * u + 1, mid + 1, right, l, r, tree)
    }
}