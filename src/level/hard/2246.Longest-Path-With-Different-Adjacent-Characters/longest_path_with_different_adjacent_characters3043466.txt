// https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3043466/rust-dfs-recursive-iterative-examples-60ms-9mb/
impl Solution {
    pub fn longest_path(parents: Vec<i32>, s: String) -> i32 {
        let mut graph = vec![None; s.len()];

        for i in 1..s.len() {
            let p = parents[i] as usize;
            graph[p].get_or_insert_with(Vec::new).push(i as i32);
        }
        let (m1, m2) = Solution::dfs(0, &mut graph, &s);

        m1.max(m2)
    }

    /// Returns the length of the longest path terminating at `node`,
    /// and the length of the longest path that goes through any descendant 
    /// node as a tuple, in that order.
    /// 
    fn dfs(node  : i32, 
           graph : &mut [Option<Vec<i32>>], 
           s     : &String) 
        -> (i32, i32) 
    {
        macro_rules! label { ($i:expr) => { s.as_bytes()[$i as usize] } }
        let     nidx = node as usize;
        let mut br1  = 0;
        let mut br2  = 0;
        let mut via  = 0;

        if graph[nidx].is_some() {
            for child in graph[nidx].take().unwrap() {

                let (mut br_len, via_len) = Self::dfs(child, graph, s);

                via = via.max(via_len);

                if label![child] != label![node] {
                    br_len += 1;
                    if br_len > br1 { 
                        br2 = br1;
                        br1 = br_len; 
                    } else if br_len > br2 {
                        br2 = br_len; 
                    }
                }
            }
        }
        let len_max = br1.max(br2).max(1);
        let via_max = via.max(br1 + br2 - 1).max(len_max);

        (len_max, via_max)
    }
}