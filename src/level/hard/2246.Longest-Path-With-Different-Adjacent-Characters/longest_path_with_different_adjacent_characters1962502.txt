// https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/1962502/rust-divide-and-merge-graph-dfs-o-n/
use std::collections::HashMap;
use std::cmp::max;

static mut ans:i32 = 0;

fn dfs(root: usize, graph: &HashMap<usize, Vec<usize>>, s: &Vec<char>) -> i32 {
    if !graph.contains_key(&root) {
        unsafe {ans = max(ans, 1);}
        return 1;
    }
    let (mut a1, mut a2) = (0, 0);
    for &v in graph[&root].iter() {
        if s[root] == s[v] {
            dfs(v, graph, s);
            continue;
        }
        let curr = dfs(v, graph, s);
        if curr >= a1 {
            a2 = a1;
            a1 = curr;
        } else if curr > a2 {
            a2 = curr;
        }
    }
    unsafe {ans = max(ans, a1 + a2 + 1);}
    a1 + 1
}

impl Solution {
    pub fn longest_path(parent: Vec<i32>, s: String) -> i32 {
        unsafe {ans = 0}
        let mut graph = HashMap::new();
        for (i, &u) in parent.iter().enumerate() {
            if u == -1 { continue }
            let u = u as usize;
            if !graph.contains_key(&u) {
                graph.insert(u, vec![]);
            }
            // graph.get_mut(u).unwrap().push(i);
            graph.entry(u).or_insert(vec![]).push(i);
        }
        // println!("graph {:?}", graph);
        
        let sa: Vec<char> = s.chars().collect();
        dfs(0, &graph, &sa);
        let mut my_ans:i32 = 0;
        unsafe{my_ans = ans;}
        my_ans
        
    }
}