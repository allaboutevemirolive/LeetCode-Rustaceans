// https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/1962394/rust-dfs-beat-100/
impl Solution {
    fn post_order(tree: &Vec<Vec<usize>>, s: &Vec<char>, global_path: &mut i32, idx: usize) -> i32 {
        let mut max_len = 0;
        let mut second_len = 0;
        let curr = s[idx];
        for &child in tree[idx].iter() {
            let len = Self::post_order(tree, s, global_path, child);
            if curr == s[child] { continue; }
            if len > max_len {
                second_len = max_len;
                max_len = len;
            } else if len > second_len {
                second_len = len;
            }
        }
        max_len += 1;
        *global_path = std::cmp::max(*global_path, max_len + second_len);
        return max_len;
        
    }
    pub fn longest_path(parent: Vec<i32>, s: String) -> i32 {
        let mut global_path: i32 = 1;
        let n = parent.len();
        let mut tree: Vec<Vec<usize>> = vec![vec![]; n];
        let vecc: Vec<_> = s.chars().collect();
        for (idx, &val) in parent.iter().enumerate().skip(1) {
            tree[val as usize].push(idx);
        }
        Self::post_order(&tree, &vecc, &mut global_path, 0);
        global_path
    }
}