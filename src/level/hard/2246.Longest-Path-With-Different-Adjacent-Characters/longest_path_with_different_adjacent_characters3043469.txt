// https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3043469/rust-hashmap-memorize-dp-monad-style/
impl Solution {
    pub fn longest_path(parent: Vec<i32>, s: String) -> i32 {
        longest_path(
            0,
            &parent.iter().enumerate().fold(
                vec![Vec::new(); parent.len()],
                |tree, (i, p)| match *p {
                    -1 => tree,
                    p => add_edge(tree, i, p as usize),
                },
            ),
            s.as_bytes(),
            &mut HashMap::new(),
        )
        .1
    }
}

use std::collections::HashMap;
fn longest_path(
    i: usize,
    tree: &Vec<Vec<usize>>,
    s: &[u8],
    mem: &mut HashMap<usize, (i32, i32)>,
) -> (i32, i32) {
    match mem.get(&i) {
        Some(&mem) => mem,
        None => match tree[i]
            .iter()
            .map(|&c| (longest_path(c, tree, s, mem), s[c] != s[i]))
            .fold(((0, 0), 0), |(pass @ (fst, snd), ans), ((v, new), ok)| {
                (
                    match (v, ok) {
                        (_, false) => pass,
                        (v, _) if v > fst => (v, fst),
                        (v, _) if v > snd => (fst, v),
                        _ => pass,
                    },
                    if new > ans { new } else { ans },
                )
            }) {
            ((fst, snd), ans) => memorize(
                mem,
                i,
                (
                    fst + 1,
                    match fst + snd + 1 {
                        new if new > ans => new,
                        _ => ans,
                    },
                ),
            ),
        },
    }
}

fn add_edge(mut tree: Vec<Vec<usize>>, i: usize, p: usize) -> Vec<Vec<usize>> {
    tree[p].push(i);
    tree
}

fn memorize(mem: &mut HashMap<usize, (i32, i32)>, k: usize, v: (i32, i32)) -> (i32, i32) {
    mem.insert(k, v);
    v
}