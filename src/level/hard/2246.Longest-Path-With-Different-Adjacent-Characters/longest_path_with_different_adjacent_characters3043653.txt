// https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3043653/rust-dfs-heap-solution/
use std::collections::BinaryHeap;

impl Solution {
    pub fn longest_path(parent: Vec<i32>, s: String) -> i32 {
        let mut graph = vec![vec![]; parent.len()];
        let mut root = 0;
        for (child, &par) in parent.iter().enumerate() {
            if par == -1 {
                root = child;
                continue;
            }
            graph[par as usize].push(child);
        }
        let mut max_count = 1;
        Self::get_longest_path(&graph, s.as_bytes(), root, &mut max_count);
        max_count
    }

    pub fn get_longest_path(graph: &Vec<Vec<usize>>, s: &[u8], root: usize, max_count: &mut i32) -> i32 {
        let root_char = s[root];

        let mut costs_heap = BinaryHeap::new();
        for &adj in graph[root].iter() {
            let sub_cost = Self::get_longest_path(graph, s, adj, max_count);
            if root_char != s[adj] {
                costs_heap.push(sub_cost);
            };
        }
        match costs_heap.pop() {
            Some(mut v0) => {
                v0 += 1;
                *max_count = if let Some(v1) = costs_heap.peek() {
                    (v0 + *v1).max(*max_count)
                } else {
                    v0.max(*max_count)
                };
                v0
            },
            None => 1,
        }
    }
}