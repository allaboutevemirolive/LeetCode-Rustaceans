// https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3043449/rust-dfs-solution/
impl Solution {
    pub fn longest_path(parent: Vec<i32>, s: String) -> i32 {
        let s: Vec<char> = s.chars().collect();
        let mut res = 0;
        let adj_list = Self::build_graph(parent);

        Self::dfs(&adj_list, &s, 0, &mut res);

        res
    }

    fn dfs(adj_list: &Vec<Vec<usize>>, s: &Vec<char>, start: usize, res: &mut i32) -> i32 {
        let mut first = 0;
        let mut second = 0;

        for &child in adj_list[start].iter() {
            let len = Self::dfs(adj_list, s, child, res);

            if s[child] != s[start] {
                if len > first {
                    second = first;
                    first = len;
                } else if len > second {
                    second = len;
                }
            }
        }

        *res = std::cmp::max(*res, first + second + 1);

        first + 1
    }

    fn build_graph(parent: Vec<i32>) -> Vec<Vec<usize>> {
        let n = parent.len();
        let mut adj_list = vec![vec![]; n];

        for i in 1..n {
            adj_list[parent[i] as usize].push(i);
        }

        adj_list
    }
}