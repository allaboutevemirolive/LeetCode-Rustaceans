// https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/2382682/rust-dfs-on-tree/
use std::collections::*;
use std::cmp::*;
 
impl Solution {
	pub fn longest_path(parent: Vec<i32>, s: String) -> i32 {
		let mut g: Vec<Vec<i32>> = vec![vec![]; parent.len()];
		for (u, v) in parent.into_iter().enumerate() {
			if v >= 0 {
				g[v as usize].push(u as i32);
			}
		}
		let mut ans = 1;
		fn dfs(u: usize, g: &Vec<Vec<i32>>, s: &Vec<char>, ans: &mut i32) -> i32 {
			let mut d = HashMap::<usize, i32>::new();
			for v in g[u].iter() {
				d.insert(*v as usize, dfs(*v as usize, g, s, ans));
			}
			let mut res = 1;
			for (v1, d1) in &d {
				res = max(res, if s[u] == s[*v1] { 0 } else { d1 + 1 });
				if s[u] == s[*v1] { continue; }
				for (v2, d2) in &d {
					if *v1 == *v2 || s[u] == s[*v2] { continue; }
					*ans = max(*ans, d1 + d2 + 1);
				}
			}
			*ans = max(*ans, res);
			res
		}
		dfs(0, &g, &s.chars().collect(), &mut ans);
		ans
	}
}