// https://leetcode.com/problems/maximum-score-of-a-node-sequence/solutions/2372151/rust-top-3-neighbors/
impl Solution {
    pub fn maximum_score(scores: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {
        let len = scores.len();

        // we store the neighbor with tuples (Reverse(Score), NODE)
        // since rust's tuple are ordered lexicographically,
        // the score will be compared first
        // we also need to keep the binary heap as a min-heap to pop
        // the smallest element out of the binary heap
        let mut neighbors: Vec<BinaryHeap<(Reverse<i32>, usize)>> = vec![BinaryHeap::new(); len];

        for edge in edges.iter() {
            let u = edge[0] as usize;
            let v = edge[1] as usize;

            neighbors[u].push((Reverse(scores[v]), v));
            neighbors[v].push((Reverse(scores[u]), u));

            if neighbors[u].len() > 3 {
                neighbors[u].pop();
            }
            if neighbors[v].len() > 3 {
                neighbors[v].pop();
            }
        }

        let mut res = -1;

        for edge in edges.into_iter() {
            let u = edge[0] as usize;
            let v = edge[1] as usize;
            for (Reverse(u_neighbor_score), u_neighbor) in neighbors[u].iter() {
                for (Reverse(v_neighbor_score), v_neighbor) in neighbors[v].iter() {
                    if *u_neighbor != v && *v_neighbor != u && *u_neighbor != *v_neighbor {
                        res = std::cmp::max(
                            res,
                            scores[u] + scores[v] + *u_neighbor_score + *v_neighbor_score,
                        );
                    }
                }
            }
        }

        res
    }
}
