// https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/solutions/2628327/rust-union-find-kruskal-s-algorithm/
use std::collections::{HashMap, HashSet};
use std::hash::Hash;

// Not the fastest implementation because of the hashmap, but can easily be resued in 
// many different problems :)
struct UnionFind<T> {
    parents: HashMap<T, T>,
    ranks: HashMap<T, usize>,
}

impl<T> UnionFind<T>
    where
        T: Eq + Hash + Copy,
{
    pub fn new() -> Self {
        Self {
            parents: HashMap::new(),
            ranks: HashMap::new(),
        }
    }

    fn reset(&mut self) {
        self.parents.clear();
        self.ranks.clear();
    }

    pub fn find(&mut self, key: T) -> T {
        match self.parents.get(&key) {
            None => key,
            Some(&parent) => {
                // Compress path on 'find()' by moving the key's node
                // directly under the representative of this set
                let parent = self.find(parent);
                self.parents.insert(key, parent);
                parent
            }
        }
    }

    pub fn union(&mut self, a: T, b: T) -> bool {
        let x = self.find(a);
        let y = self.find(b);

        // A and B are already in the same set -> nothing to do
        if x == y {
            return false;
        }

        let xr = self.ranks.get(&x).copied().unwrap_or(0);
        let yr = self.ranks.get(&y).copied().unwrap_or(0);

        if xr < yr {
            self.parents.insert(x, y);
        } else if xr > yr {
            self.parents.insert(y, x);
        } else {
            self.parents.insert(x, y);
            *self.ranks.entry(y).or_insert(0) += 1;
        }

        true
    }
}

pub fn find_critical_and_pseudo_critical_edges(_n: i32, edges: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
    let mut edges = edges
        .into_iter()
        .enumerate()
        .map(|(idx, edge)| (edge[2], edge[0], edge[1], idx as i32))
        .collect::<Vec<_>>();
    edges.sort_unstable_by_key(|edge| edge.0);

    let mut uf = UnionFind::new();
    let mut mst_edges = HashSet::new();

    // Calculate the sum of the weights of the MST
    let mut minimal_cost = 0;
    for (cost, from, to, edge_id) in edges.iter().copied() {
        if uf.union(from, to) {
            minimal_cost += cost;
            mst_edges.insert(edge_id);
        }
    }
    let minimal_cost = minimal_cost;

    // For each unprocessed edge, check if it is a pseudo-critical edge
    // by forcing it to be a part of the minimum spanning tree. If the
    // the total cost of the MST does not increase - then the edge is
    // pseudo-critical, otherwise it is not part of any MST
    let mut candidates = vec![];
    for (cost, from, to, required_edge) in edges.iter().copied() {
        // skip already known pseudo critical edges
        if mst_edges.contains(&required_edge) {
            continue;
        }

        candidates.clear();
        candidates.push(required_edge);

        uf.reset();
        uf.union(from, to);

        let mut total_cost = cost;
        for (cost, from, to, edge_id) in edges.iter().copied() {
            if required_edge != edge_id && uf.union(from, to) {
                total_cost += cost;
                candidates.push(edge_id);
            }
        }

        if total_cost == minimal_cost {
            mst_edges.extend(candidates.drain(..));
        }
    }

    let mut critical = vec![];
    let mut pseudo_critical = vec![];

    // Some of the pseudo-critical edges, a re actually critical edges.
    // Exclude the pseudo-critical edges from the MST one by one and check
    // if its total cost changes. If it does - then the excluded edge is
    // a critical edge
    for skipped_edge in mst_edges {
        uf.reset();

        let mut total_cost = 0;
        for (cost, from, to, edge_id) in edges.iter().copied() {
            if skipped_edge == edge_id {
                continue;
            }

            if uf.union(from, to) {
                total_cost += cost;
            }
        }

        if total_cost == minimal_cost {
            pseudo_critical.push(skipped_edge);
        } else {
            critical.push(skipped_edge);
        }
    }

    vec![critical, pseudo_critical]
}