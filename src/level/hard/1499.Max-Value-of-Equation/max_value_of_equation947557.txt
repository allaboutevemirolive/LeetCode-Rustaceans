// https://leetcode.com/problems/max-value-of-equation/solutions/947557/rust-pointer-method-explained-o-n-time-o-1-space-28ms/
use std::cmp;

impl Solution {
    pub fn find_max_value_of_equation(points: Vec<Vec<i32>>, k: i32) -> i32 {
        let mut ptr1 = 0;
        let mut ptr2 = 0;
        let mut ans = std::i32::MIN;
        let mut sum = 0;
        
        for new in 0..points.len() {
            
            // ptr1 to satisfy the k-constraint
            while points[ptr1][0] < points[new][0] - k {
                ptr1 += 1;
            }            
            
            if ptr1 >= new {
                continue;
            }
            
            if ptr2 > ptr1 {              
                let d1 = points[new][0]+points[ptr1][0]-2*points[ptr2][0]+points[new][1]-points[ptr1][1];
                let d2 = points[new][0]-points[ptr2][0]+points[new][1]-points[ptr2][1];
                
                if d2 >= 0 && d2 > d1 {
                    // replace ptr2 with new
                    ptr2 = new;
                    sum = points[ptr2][0]-points[ptr1][0]+points[ptr2][1]+points[ptr1][1];
                    ans = cmp::max(ans, sum);
                } else if d1 >= 0 {
                    // replace ptr1
                    ptr1 = ptr2;
                    ptr2 = new;
                    sum = points[ptr2][0]-points[ptr1][0]+points[ptr2][1]+points[ptr1][1];
                    ans = cmp::max(ans, sum);
                }        
                
            } else {
                ptr2 = new;
                sum = points[ptr2][0]-points[ptr1][0]+points[ptr2][1]+points[ptr1][1];
                ans = cmp::max(ans, sum);
            }         
        }
        
        // find the rest
        ptr2 = points.len()-1;         
        while ptr1 < ptr2 {
            sum = cmp::max(sum, points[ptr2][0]-points[ptr1][0]+points[ptr2][1]+points[ptr1][1]); 
            ans = cmp::max(ans, sum);
            ptr1 += 1;
        }       
        return ans;
    }
}```