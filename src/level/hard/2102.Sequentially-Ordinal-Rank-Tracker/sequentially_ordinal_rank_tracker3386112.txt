// https://leetcode.com/problems/sequentially-ordinal-rank-tracker/solutions/3386112/with-two-binaryheaps-in-rust/
use std::{
    cmp::{Ordering, Reverse},
    collections::BinaryHeap,
};

#[derive(PartialEq, Eq, Clone)]
struct Data {
    name: String,
    score: i32,
}

impl PartialOrd for Data {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Data {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        match self.score.cmp(&other.score) {
            Ordering::Equal => other.name.cmp(&self.name),
            ord => ord,
        }
    }
}

struct SORTracker {
    x: BinaryHeap<Data>,
    y: BinaryHeap<Reverse<Data>>,
}

impl SORTracker {
    fn new() -> Self {
        SORTracker {
            x: BinaryHeap::new(),
            y: BinaryHeap::new(),
        }
    }

    fn add(&mut self, name: String, score: i32) {
        let data = Data { name, score };
        if let Some(vr) = self.y.pop() {
            if data > vr.0 {
                self.y.push(Reverse(data));
                self.x.push(vr.0);
            } else {
                self.y.push(vr);
                self.x.push(data);
            }
        } else {
            self.x.push(data);
        }
    }

    fn get(&mut self) -> String {
        let vr = self.x.pop().unwrap();
        self.y.push(Reverse(vr.clone()));
        vr.name
    }
}
