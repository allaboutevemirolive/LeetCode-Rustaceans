// https://leetcode.com/problems/groups-of-strings/solutions/1731651/rust-union-find/
use std::collections::HashMap;

pub struct Dsu {
    n: usize,
    // root node: -1 * component size
    // otherwise: parent
    parent_or_size: Vec<i32>,
}

impl Dsu {
    // 0 <= size <= 10^8 is constrained.
    pub fn new(size: usize) -> Self {
        Self {
            n: size,
            parent_or_size: vec![-1; size],
        }
    }
    pub fn merge(&mut self, a: usize, b: usize) -> usize {
        let (mut x, mut y) = (self.leader(a), self.leader(b));
        if x == y {
            return x;
        }
        if -self.parent_or_size[x] < -self.parent_or_size[y] {
            std::mem::swap(&mut x, &mut y);
        }
        self.parent_or_size[x] += self.parent_or_size[y];
        self.parent_or_size[y] = x as i32;
        x
    }

    pub fn same(&mut self, a: usize, b: usize) -> bool {
        self.leader(a) == self.leader(b)
    }
    pub fn leader(&mut self, a: usize) -> usize {
        if self.parent_or_size[a] < 0 {
            return a;
        }
        self.parent_or_size[a] = self.leader(self.parent_or_size[a] as usize) as i32;
        self.parent_or_size[a] as usize
    }
    pub fn group_size(&mut self) -> Vec<i32> {
        let mut cnt = 0;
        let mut max = 0;
        for i in 0..self.n {
            if self.parent_or_size[i] < 0 {
                cnt += 1;
                max = max.max(-self.parent_or_size[i]);
            }
        }
        vec![cnt, max]
    }
}
impl Solution {
    pub fn group_strings(words: Vec<String>) -> Vec<i32> {
        let n = words.len();
        let mut dsu = Dsu::new(n);
        let mut m: HashMap<usize, usize> = HashMap::new();
        let words = words
            .iter()
            .map(|x| x.chars().map(|y| y as u8 - 97).fold(0, |s, c| s | (1 << c)));
        for (cur, mask) in words.enumerate() {
            if let Some(v) = m.get(&mask) {
                dsu.merge(cur, *v);
            }
            m.insert(mask, cur);
            for i in 0..26 {
                if let Some(v) = m.get(&(mask ^ (1 << i))) {
                    dsu.merge(cur, *v);
                }
                for j in (i + 1)..26 {
                    if ((mask >> j) & 1) != ((mask >> i) & 1) {
                        if let Some(index) = m.get(&(mask ^ (1 << i) ^ (1 << j))) {
                            dsu.merge(cur, *index);
                        }
                    }
                }
            }
        }
        dsu.group_size()
    }
}
