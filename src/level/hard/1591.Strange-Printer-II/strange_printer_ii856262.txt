// https://leetcode.com/problems/strange-printer-ii/solutions/856262/rust-construct-graph-and-topological-sort/
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
enum VisitStatus {
    Visiting,
    Visited,
}

fn has_cycle(
    cur: i32,
    deps: &HashMap<i32, HashSet<i32>>,
    seen: &mut HashMap<i32, VisitStatus>,
) -> bool {
    match seen.get(&cur) {
        Some(VisitStatus::Visited) => return false,
        Some(VisitStatus::Visiting) => return true,
        None => {}
    }
    seen.insert(cur, VisitStatus::Visiting);

    for dep in deps.get(&cur).into_iter().flatten() {
        if has_cycle(*dep, deps, seen) {
            return true;
        }
    }

    seen.insert(cur, VisitStatus::Visited);
    false
}

fn is_printable(target_grid: Vec<Vec<i32>>) -> bool {
    let mut starts_ends = HashMap::new();

    for (i, row) in target_grid.iter().enumerate() {
        for (j, val) in row.iter().enumerate() {
            if let Some((x_min, y_min, x_max, y_max)) = starts_ends.get_mut(&val) {
                *x_min = std::cmp::min(*x_min, i);
                *y_min = std::cmp::min(*y_min, j);

                *x_max = std::cmp::max(*x_max, i + 1);
                *y_max = std::cmp::max(*y_max, j + 1);
            } else {
                starts_ends.insert(val, (i, j, i + 1, j + 1));
            }
        }
    }

    // println!("{:?}", starts_ends);

    let mut deps: HashMap<i32, HashSet<i32>> = HashMap::new();
    for (&&a_val, &(ax_min, ay_min, ax_max, ay_max)) in starts_ends.iter() {
        for (&&b_val, &(bx_min, by_min, bx_max, by_max)) in starts_ends.iter() {
            if a_val == b_val {
                continue;
            }

            let (cx_min, cy_min, cx_max, cy_max) = (
                std::cmp::max(ax_min, bx_min),
                std::cmp::max(ay_min, by_min),
                std::cmp::min(ax_max, bx_max),
                std::cmp::min(ay_max, by_max),
            );

            // println!("{:?}", &(cx_min, cy_min, cx_max, cy_max));

            for target_i in cx_min..cx_max {
                for target_j in cy_min..cy_max {
                    if target_grid[target_i][target_j] == b_val {
                        deps.entry(a_val).or_insert_with(HashSet::new).insert(b_val);
                    }
                    // else if target_grid[target_i][target_j] == a_val {
                    //     deps.entry(a_val).or_insert_with(Vec::new).push(b_val);
                    // }
                }
            }
        }
    }

    // println!("{:?}", deps);

    let mut seen = HashMap::new();
    for (&&val, _) in starts_ends.iter() {
        // println!("{:?}", val);
        if has_cycle(val, &deps, &mut seen) {
            // println!("{:?}", val);
            return false;
        }
    }

    true
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_lc1_simple() {
        assert!(is_printable(vec![
            vec![1, 1, 1, 1],
            vec![1, 2, 2, 1],
            vec![1, 2, 2, 1],
            vec![1, 1, 1, 1]
        ]))
    }

    #[test]
    fn test_lc1_hard() {
        assert!(is_printable(vec![
            vec![4, 4, 4, 1, 1, 1, 1, 1, 1, 1],
            vec![4, 4, 4, 1, 1, 1, 1, 1, 1, 1],
            vec![4, 4, 4, 3, 1, 1, 1, 1, 1, 1],
            vec![1, 3, 3, 3, 1, 1, 1, 1, 1, 1],
            vec![1, 3, 3, 3, 1, 1, 1, 1, 1, 1],
            vec![1, 3, 3, 3, 1, 1, 1, 1, 1, 1],
            vec![1, 3, 3, 6, 6, 6, 6, 6, 6, 5],
            vec![1, 3, 3, 6, 6, 6, 6, 6, 6, 5],
            vec![1, 1, 1, 6, 6, 6, 6, 6, 6, 2]
        ]))
    }
}

impl Solution {
    pub fn is_printable(target_grid: Vec<Vec<i32>>) -> bool {
        is_printable(target_grid)
    }
}