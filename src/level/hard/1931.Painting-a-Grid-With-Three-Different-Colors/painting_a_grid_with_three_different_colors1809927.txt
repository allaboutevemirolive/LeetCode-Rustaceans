// https://leetcode.com/problems/painting-a-grid-with-three-different-colors/solutions/1809927/rust-dp-mask-runs-in-88ms/
use std::collections::HashMap;

const MOD: i32 = 1000_000_007;
impl Solution {
    pub fn color_the_grid(m: i32, n: i32) -> i32 {
        let mask = |mut x: usize| -> Vec<usize> {
            let mut res = vec![];
            for _ in 0..m {
                res.push(x % 3);
                x /= 3;
            }
            res
        };
        let mut candidate = vec![];
        let m = m as usize;
        let n = n as usize;
        'outer: for x in 0usize..(3usize.pow(m as u32)) {
            let mut cur = mask(x);
            for w in cur.windows(2) {
                if w[0] == w[1] {
                    continue 'outer;
                }
            }
            candidate.push(x);
        }
        let mut nxt: HashMap<usize, Vec<usize>> = HashMap::new();
        for cur in candidate.iter() {
            for next_cur in candidate.iter() {
                let c = mask(*cur);
                let nc = mask(*next_cur);
                if c.iter().zip(nc.iter()).all(|x| x.0 != x.1) {
                    nxt.entry(*cur).or_default().push(*next_cur);
                }
            }
        }
        let mut dp: HashMap<usize, i32> = HashMap::new();
        for i in candidate.iter() {
            dp.insert(*i, 1);
        }
        for _ in 1..n {
            let mut ndp: HashMap<usize, i32> = HashMap::new();
            for (k, v) in dp.iter() {
                for next in nxt[k].iter() {
                    if let Some(value) = ndp.get_mut(next) {
                        *value = (*value + *v) % MOD;
                    } else {
                        ndp.insert(*next, *v);
                    }
                }
            }
            dp = ndp;
        }
        let mut res = 0;
        for v in dp.values() {
            res = (res + *v) % MOD;
        }
        res
    }
}
