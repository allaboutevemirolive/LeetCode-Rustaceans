// https://leetcode.com/problems/minimum-cost-to-cut-a-stick/solutions/865618/rust-idiomatic-code/
use std::collections::HashMap;

fn _min_cost<'a>(cuts: &'a [i32], cache: &mut HashMap<&'a [i32], i32>) -> i32 {
    if cuts.len() <= 2 {
        return 0;
    }
    if let Some(&res) = cache.get(cuts) {
        return res;
    }
    
    let mut res = std::i32::MAX;
    let rod_size = cuts.last().unwrap() - cuts[0];
    for i in 1..cuts.len()-1 {
        res = std::cmp::min(res, rod_size + _min_cost(&cuts[..i+1], cache) + _min_cost(&cuts[i..], cache));
    }
    
    
    cache.insert(cuts, res);
    res
}

impl Solution {
    pub fn min_cost(n: i32, mut cuts: Vec<i32>) -> i32 {
        cuts.push(0);
        cuts.push(n);
        cuts.sort();
        let mut cache = HashMap::new();
        _min_cost(cuts.as_slice(), &mut cache)
    }
}