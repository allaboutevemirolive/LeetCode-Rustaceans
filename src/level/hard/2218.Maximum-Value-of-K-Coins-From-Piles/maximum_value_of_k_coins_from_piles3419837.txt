// https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/solutions/3419837/rust-top-down-dp/
impl Solution {
    pub fn max_value_of_coins(piles: Vec<Vec<i32>>, k: i32) -> i32 {
        max_value_of_coins(piles, k)
    }
}

pub fn max_value_of_coins(piles: Vec<Vec<i32>>, k: i32) -> i32 {
    assert!(k >= 0);

    let mut cache = vec![vec![-1; k as usize]; piles.len()];
    dfs(&piles, &mut cache, 0, k as usize)
}

fn dfs(piles: &[Vec<i32>], cache: &mut [Vec<i32>], pile: usize, k: usize) -> i32 {
    // we are not allowed to take more coins
    if k == 0 || pile >= piles.len() {
        return 0;
    }

    if cache[pile][k - 1] >= 0 {
        return cache[pile][k - 1];
    }

    // The answer if we do NOT take coins from the current pile (i.e. skip it)
    let mut answer = dfs(piles, cache, pile + 1, k);

    // The total amount we have acquired from the current pile
    // essentially a prefix sum
    let mut sum = 0;

    // The answer if we take coins from the current pile
    let stack = &piles[pile];
    for depth in 0..stack.len().min(k) {
        sum += stack[depth];

        // we use `k - depth - 1`, because even if depth is 0, we take 1 element,
        // which is at depth=0, thus we always subtract 1
        let value = sum + dfs(piles, cache, pile + 1, k - depth - 1);
        answer = answer.max(value);
    }

    cache[pile][k - 1] = answer;
    answer
}