// https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/solutions/3418987/clean-rust-from-brute-force-memoization-tabulation-to-finally-space-optimized-1d-dp-solution/
impl Solution {
    fn solve(i: usize, coins: usize, piles:  &[Vec<i32>]) -> i32 {
        if i == 0 || coins == 0 {
            return 0
        }
        
        let notPick = Self::solve(i-1,coins,piles);
        let mut pick = 0;
        
        let mut coinSum = 0;
        for j in 0..piles[i-1].len() {
            coinSum += piles[i-1][j];
            
            if coins >= j+1 {
                pick = std::cmp::max(pick, coinSum + Self::solve(i-1,coins-j-1,piles));
            }
        }
        
        std::cmp::max(pick,notPick)
    }
    
    pub fn max_value_of_coins(piles: Vec<Vec<i32>>, k: i32) -> i32 {
        let n = piles.len();
        
        Self::solve(n,k as usize,&piles)
    }
}