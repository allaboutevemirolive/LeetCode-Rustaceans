// https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/solutions/3291477/rust-editorial-port-2-approaches/
impl Solution {
    pub fn max_value_of_coins(piles: Vec<Vec<i32>>, k: i32) -> i32 {
        fn bottom_up(piles: Vec<Vec<i32>>, k: i32) -> i32 {
            let mut dp = vec![vec![0; k as usize + 1]; piles.len() + 1];
            for i in 1..=piles.len() as usize {
                for coins in 0..=k as usize {
                    let mut current_sum = 0;
                    for current_coins in 0..=piles[i - 1].len().min(coins) {
                        if current_coins > 0 {
                            current_sum += piles[i - 1][current_coins - 1];
                        }
                        dp[i][coins] = dp[i][coins].max(dp[i - 1][coins - current_coins] + current_sum);
                    }
                }
            }
            dp[piles.len()][k as usize]
        }

        fn top_down(piles: Vec<Vec<i32>>, k: i32) -> i32 {
            fn rec(piles: &Vec<Vec<i32>>, i: usize, coins: usize, dp: &mut Vec<Vec<i32>>) -> i32 {
                if i == 0 {
                    return 0;
                }
                if dp[i][coins] != -1 {
                    return dp[i][coins];
                }
                let mut current_sum = 0;
                for current_coins in 0..=piles[i - 1].len().min(coins) {
                    if current_coins > 0 {
                        current_sum += piles[i - 1][current_coins - 1];
                    }
                    dp[i][coins] =
                        dp[i][coins].max(rec(piles, i - 1, coins - current_coins, dp) + current_sum);
                }
                dp[i][coins]
            }
            let mut dp = vec![vec![-1; k as usize + 1]; piles.len() + 1];
            rec(&piles, piles.len(), k as usize, &mut dp)
        }

        top_down(piles, k)      
    }
}