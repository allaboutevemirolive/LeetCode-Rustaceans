// https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/solutions/2654797/rust-solution/
//https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/

struct Solution {

}

#[allow(unused)]
impl Solution {

    pub fn max_value_of_coins(piles: Vec<Vec<i32>>, k: i32) -> i32 {
        fn prefix(p:Vec<i32>) -> Vec<i32> {
            let mut ret = Vec::new();
            let mut sum = 0;
            for i in p {
                sum+=i;
                ret.push(sum);
            }
            ret
        }
        let mut vals = Vec::new();

        for i in 0..=k {
            vals.push(0);
        }

        for pile in piles {
            let p=prefix(pile);
            let old=vals.clone();

            for l in 1..=k as usize {
                let mut current_max = old.get(l).unwrap().clone();
                for i in 1..=(l.min(p.len())) {
                    let v=old.get(l-i).unwrap() + p.get(i-1).unwrap();
                    current_max=v.max(current_max);
                }
                vals[l]=current_max;
            }
        }
        // it might be possible that a smaller is greater ; in case no k coins in all stacks
        vals.iter().max().unwrap().clone()
    }
}
#[cfg(test)]
mod tests {
    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use super::*;

    #[test]
    fn test1() {
        assert_eq!(Solution::max_value_of_coins(vec![vec![1,100,3],vec![7,8,9]],2), 101);
    }
    #[test]
    fn test2() {
        let piles=vec![
            vec![100],
            vec![100],
            vec![100],
            vec![100],
            vec![100],
            vec![100],
            vec![1,1,1,1,1,1,700]
        ];
        assert_eq!(Solution::max_value_of_coins(piles,7), 706);
    }

}