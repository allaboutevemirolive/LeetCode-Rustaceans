// https://leetcode.com/problems/last-day-where-you-can-still-cross/solutions/1976696/rust-solution-using-union-find/
fn size(parents: &mut Vec<i32>, i: i32) -> i32 {
  let ii = find(parents, i) as usize;
  -1 * parents[ii]
}

fn find(parents: &mut Vec<i32>, i: i32) -> i32 {
  let ii = i as usize;
  if parents[ii] < 0 {
    i
  } else {
    parents[ii] = find(parents, parents[ii]);
    parents[ii]
  }
}

fn connect(
  parents: &mut Vec<i32>,
  a: i32,
  b: i32
) -> bool {
  let mut pa = find(parents, a);
  let mut pb = find(parents, b);
  
  if pa == pb { return false }
  
  if size(parents, pa) < size(parents, pb) {
    let temp = pa;
    pa = pb;
    pb = temp;
  }
  
  let paa = pa as usize;
  let pbb = pb as usize;
  parents[paa] += parents[pbb];
  parents[pbb] = pa;
  
  true
}

fn helper(memo: &mut Vec<(bool, bool)>, parents: &mut Vec<i32>, ti:i32, ci:i32) -> bool {
  let v1 = memo[find(parents, ci) as usize];
  let v2 = memo[find(parents, ti) as usize];
  let (has_top, has_bottom) = (v1.0 | v2.0, v1.1 | v2.1);

  connect(parents, ci, ti);

  let pi = find(parents, ci) as usize;
  memo[pi].0 |= has_top;
  memo[pi].1 |= has_bottom;
  
  memo[pi].0 && memo[pi].1
}

impl Solution {
  pub fn latest_day_to_cross(row: i32, col: i32, mut cells: Vec<Vec<i32>>) -> i32 {
    let n = cells.len();
    for i in 0..n {
      cells[i][0] -= 1;
      cells[i][1] -= 1;
    }

    let mut parents = vec![-1;n];
    let mut memo = vec![(false,false);n];
    let mut lands = vec![vec![false;col as usize];row as usize];
    for i in (0..n).rev() {
      let (r, c) = (cells[i][0] as usize, cells[i][1] as usize);
      let (ir, ic) = (r as i32, c as i32);
      // current position
      let ci = col * ir + ic;
      lands[r][c] = true;
      if ir == 0 {
        memo[ci as usize].0 = true;
      } else if ir + 1 == row {
        memo[ci as usize].1 = true; 
      }

      if 0 < ir && lands[r-1][c] {
        if helper(&mut memo, &mut parents, col*(ir-1)+ic, ci) {
          return i as i32;
        }
      }
      
      if ir < row-1 && lands[r+1][c] {
        if helper(&mut memo, &mut parents, col*(ir+1)+ic, ci) {
          return i as i32;
        }
      }

      if 0 < ic && lands[r][c-1] {
        if helper(&mut memo, &mut parents, col*ir+ic-1, ci) {
          return i as i32;
        }
      }

      if ic < col-1 && lands[r][c+1] {
        if helper(&mut memo, &mut parents, col*ir+ic+1, ci) {
          return i as i32;
        }
      }
    }

    unreachable!()
  }
}