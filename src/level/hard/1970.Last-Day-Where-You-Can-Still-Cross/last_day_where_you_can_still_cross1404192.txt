// https://leetcode.com/problems/last-day-where-you-can-still-cross/solutions/1404192/c-rust-dfs/
//Rust
impl Solution {
    pub fn latest_day_to_cross(row: i32, col: i32, cells: Vec<Vec<i32>>) -> i32 {
        let dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]];
        let (m, n) = (row as usize, col as usize);
        let (mut grid, mut visited) = (vec![vec![1i32; n]; m], vec![vec![0i32; n]; m]);
        
        for k in (0..cells.len()).rev() {   
            let (i, j) = (cells[k][0] as usize - 1, cells[k][1] as usize - 1);
            grid[i][j] = 0;

            let mut good = false; // connecting to the first row?
            if i == 0 { good = true; }
            
            for d in dirs {
                let (u, v) = (i as i32 + d[0], j as i32 + d[1]);
                if u < 0 || u == m as i32 || v < 0 || v == n as i32 { continue; }
                let (u, v) = (u as usize, v as usize);
                
                if grid[u][v] != 1 && visited[u][v] == 1 { good = true; }
            }
            if good == false { continue; }
            
            visited[i][j] = 1;
            if i == m - 1 { return k as i32 }
            if Self::dfs(&mut grid, &mut visited, i, j) { return k as i32; }
        }
        
        panic![]
    }
    
    // dfs from (i, j), can reach the last row?
    fn dfs(grid: &mut Vec<Vec<i32>>, visited: &mut Vec<Vec<i32>>, i: usize, j: usize) -> bool {
        let dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]];
        let (m, n) = (grid.len(), grid[0].len());
        
        for d in dirs {
            let (u, v) = (i as i32 + d[0], j as i32 + d[1]);
            if u < 0 || u == m as i32 || v < 0 || v == n as i32 { continue; }
            let (u, v) = (u as usize, v as usize);
            if grid[u][v] == 1 { continue; }
            if u == m - 1 { return true }
            
            if visited[u][v] == 1 { continue; }
            visited[u][v] = 1;
            if Self::dfs(grid, visited, u, v) { return true; }
        }
        
        false
    }
}