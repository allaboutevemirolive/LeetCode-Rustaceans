// https://leetcode.com/problems/recover-the-original-array/solutions/2668994/rust-105ms/
impl Solution {
    pub fn recover_array(nums: Vec<i32>) -> Vec<i32> {
        use std::collections::HashMap;
        let mut nums = nums.clone();
        nums.sort();
        let smallest = nums[0];
        let mut last_k = -1;
        let mut left = HashMap::new();
        for &n in &nums {
            if !left.contains_key(&n) { left.insert(n, 1); }
            else { left.insert(n, left.get(&n).unwrap() + 1); }
        }
        'out: for &n in (&nums[1..]).iter() {
            let k = n - smallest;
            if k == last_k || k % 2 != 0 || k == 0 { continue; }
            last_k = k;
            // enumeration
            let mut table = left.clone();
            let mut ret = Vec::new();
            for &n in nums.iter() {
                if table.get(&n).unwrap().clone() == 0 { continue; }
                let counterpart = n + k;
                if !table.contains_key(&counterpart) || table.get(&counterpart).unwrap().clone() == 0
                { continue 'out; }
                ret.push(n + k / 2);
                table.insert(n, table.get(&n).unwrap() - 1);
                table.insert(counterpart, table.get(&counterpart).unwrap() - 1);
            }
            return ret;
        }
        return Vec::new();
    }
}