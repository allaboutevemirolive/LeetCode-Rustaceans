// https://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/2708328/rust-solution-o-n-runtime-o-n-space/
impl Solution {
    pub fn count_subarrays(nums: Vec<i32>, min_k: i32, max_k: i32) -> i64 {
        let (n, mut i) = (nums.len(), 0);
        let mut ret = 0;
        
        while i < n {
            if nums[i] < min_k || nums[i] > max_k {
                i += 1;
                continue;
            }
            
            let mut j = i;
            while j < n - 1 && nums[j + 1] >= min_k && nums[j + 1] <= max_k { 
                j += 1;
            }
            
            let (mut v1, mut v2) = (vec![], vec![]);
            
            for k in (i..=j).rev() {
                if nums[k] == min_k { v1.push(k); }
                if nums[k] == max_k { v2.push(k); }
            }
            
            for k in i..=j {
                if v1.is_empty() == false && v1[v1.len() - 1] < k { v1.pop(); }
                if v2.is_empty() == false && v2[v2.len() - 1] < k { v2.pop(); }
                if v1.is_empty() || v2.is_empty() { break }
                let last = v1[v1.len() - 1].max(v2[v2.len() - 1]);
                ret += j as i64 - last as i64 + 1;
            }
            
            i = j + 1;
        }
        
        ret
    }
}