// https://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3254130/rust-two-pointers/
impl Solution {
    pub fn count_subarrays(nums: Vec<i32>, min_k: i32, max_k: i32) -> i64 {
        let mut l = 0;
        let mut r = 0;
        let n = nums.len();

        let mut ans = 0i64;
        // count subarray in range [l, r)
        // which value in that satisfy: min_k <= value <= max_k
        let mut foo = |left, right| -> i64 {
            let mut min_count = 0;
            let mut max_count = 0;
            let mut l = left;
            let mut pairs = 0i64;

            for r in left..right {
                if nums[r] == min_k {
                    min_count += 1;

                    // if range [l, r] has both min_k and max_k
                    if max_count > 0 { 
                        // while r keeps moving right, it still satisfy the limitation,
                        // so calculate all them directly
                        let t = (right - r) as i64;

                        let mut cnt = 0;
                        // increase l to shrink the range to get more range pairs
                        while l < r && max_count > 0 {
                            cnt += 1;
                            if nums[l] == max_k {
                                max_count -= 1;
                            }
                            l += 1;
                        }
                        pairs += cnt * t;
                    }
                } else if nums[r] == max_k { // same as above with little difference
                    max_count += 1;
                    if min_count > 0 {
                        let t = (right - r) as i64;
                        let mut cnt = 0;
                        while l < r && min_count > 0 {
                            cnt += 1;
                            if nums[l] == min_k {
                                min_count -= 1;
                            }
                            l += 1;
                        }
                        pairs += cnt * t;
                    }
                }
            }
            pairs
        };

        loop {
            while l < n && (nums[l] > max_k || nums[l] < min_k) {
                l += 1;
            }
            if l >= n {
                break;
            }

            r = l;
            let mut min = nums[l];
            let mut max = nums[r];
            while r < n && nums[r] <= max_k && nums[r] >= min_k {
                min = min.min(nums[r]);
                max = max.max(nums[r]);
                r += 1;
            }
            if min == min_k && max == max_k {
                if min_k == max_k {
                    let t = (r - l) as i64;
                    ans += (t + 1) * t / 2;
                } else {
                    ans += foo(l, r); // check range [l, r)
                }
            }
            l = r + 1;
        }
        ans
    }
}