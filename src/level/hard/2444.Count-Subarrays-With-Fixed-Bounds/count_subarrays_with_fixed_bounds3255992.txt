// https://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255992/rust-7ms-3-3-mb/
impl Solution {
    pub fn count_subarrays(nums: Vec<i32>, min_k: i32, max_k: i32) -> i64 {
        use std::cmp::{ max, min };

        let n = nums.len();
        let (mut left_bound, mut last_min, mut last_max) = (-1, -1, -1);
        let mut count = 0;

        for i in 0..n {
            if nums[i] >= min_k && nums[i] <= max_k {
                if nums[i] == min_k { last_min = i as i32; }
                if nums[i] == max_k { last_max = i as i32; }
                count += max(0, min(last_min, last_max) - left_bound) as i64;
            } else {
                left_bound = i as i32;
                last_min = -1;
                last_max = -1;
            }
        }

        count
    }
}