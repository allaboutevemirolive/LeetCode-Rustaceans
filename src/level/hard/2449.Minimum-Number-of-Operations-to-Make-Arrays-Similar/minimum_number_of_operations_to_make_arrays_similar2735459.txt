// https://leetcode.com/problems/minimum-number-of-operations-to-make-arrays-similar/solutions/2735459/rust-parity-sort/
impl Solution {
    pub fn make_similar(nums: Vec<i32>, target: Vec<i32>) -> i64 {
        let (mut n_odd, mut t_odd, mut n_even, mut t_even) = nums.into_iter().zip(target.into_iter())
            .fold((vec![], vec![], vec![], vec![]), |(mut n_odd, mut t_odd, mut n_even, mut t_even), (n, t)| {
                if n % 2 == 0 { n_even.push(n) } else { n_odd.push(n) }
                if t % 2 == 0 { t_even.push(t) } else { t_odd.push(t) }
                (n_odd, t_odd, n_even, t_even)
            });
            n_odd.sort_unstable();
            n_even.sort_unstable();
            t_odd.sort_unstable();
            t_even.sort_unstable();
            (n_odd.into_iter().zip(t_odd.into_iter()).map(|(n, t)| (n-t).abs() as i64).sum::<i64>()
            + n_even.into_iter().zip(t_even.into_iter()).map(|(n, t)| (n-t).abs() as i64).sum::<i64>()) / 4
    }
}