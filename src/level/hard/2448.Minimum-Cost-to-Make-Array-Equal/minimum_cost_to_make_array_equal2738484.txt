// https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/2738484/rust-solution-using-sort-prefix-sum/
use std::collections::BTreeMap;

impl Solution {
    pub fn min_cost(nums: Vec<i32>, cost: Vec<i32>) -> i64 {
        let mut mp = BTreeMap::<i32, i64>::new();

        for i in 0 .. nums.len() {
            *mp.entry(nums[i]).or_default() += cost[i] as i64;
        }

        let mut ret = 0;
        let mut data = vec![];
        for (key, val) in mp { data.push((key, val)); }

        let n = data.len();
        let mut sum = 0;
        for i in 0 .. data.len() {
            ret += (data[i].0 as i64 - data[0].0 as i64) * data[i].1; 
            sum += data[i].1;
        }

        let mut left = data[0].1;
        for i in 1 .. n {
            let temp = left - (sum - left);
            if temp >= 0 { break }
            ret += temp * (data[i].0 as i64 - data[i - 1].0 as i64);
            left += data[i].1;
        }

        ret
    }
}