// https://leetcode.com/problems/kth-ancestor-of-a-tree-node/solutions/2282799/rust-binary-lifting/
struct TreeAncestor {
    // dp is a looking up table such that dp[j][i] is i's ancenstor 2^^j generations above.
    dp: Vec<Vec<i32>>,
}
impl TreeAncestor {

    fn new(n: i32, parent: Vec<i32>) -> Self {
        let mut temp = vec![vec![-1i32; n as usize]; 20]; 
        for i in 1..parent.len() { temp[0][i] = parent[i]; }
        for k in 1..20 {
            for i in 1..n as usize {
                let j = temp[k - 1][i];
                if j != -1 { temp[k][i] = temp[k - 1][j as usize]; }
            } 
        }
        TreeAncestor { dp: temp, }
    }
    
    fn get_kth_ancestor(&self, node: i32, k: i32) -> i32 {
        let mut node = node;
        // best way to understand this loop is to think of node as binary representation
		// For example if node  = 11 ( = 1 + 2 + 8 = 2^^0 + 2^^1 + 2^^3 ), the table is only
		// looked up three times, ehen i = 0. 1, & 3. 
        for i in 0..20 {
            if ((k & (1 << i)) == 0) { continue; }
            node = self.dp[i][node as usize];
            if node == -1 { break; }
        }

        return node;
    }
}
