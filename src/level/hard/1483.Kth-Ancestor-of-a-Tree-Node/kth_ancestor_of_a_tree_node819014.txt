// https://leetcode.com/problems/kth-ancestor-of-a-tree-node/solutions/819014/rust-translated/
#[derive(Debug)]
struct TreeAncestor {
    jumps: Vec<Vec<i32>>,
    lvls: Vec<i32>,
}

impl TreeAncestor {
    fn new(n: i32, parent: Vec<i32>) -> Self {
        let mut tree = vec![vec![]; n as usize];
        let mut jumps = vec![vec![]; n as usize];
        let mut lvls = vec![0; n as usize];
        for i in 1..n {
            tree[parent[i as usize] as usize].push(i);
        }
        let mut path = vec![];
        Self::traverse(&mut path, &mut tree, 0, 0, &mut jumps, &mut lvls);
        TreeAncestor { jumps, lvls }
    }

    fn traverse(
        path: &mut Vec<i32>,
        tree: &mut Vec<Vec<i32>>,
        i: i32,
        l: i32,
        jumps: &mut Vec<Vec<i32>>,
        lvls: &mut Vec<i32>,
    ) {
        lvls[i as usize] = l;
        let mut p = 1;
        while p <= path.len() {
            jumps[i as usize].push(path[path.len() - p]);
            p <<= 1;
        }
        path.push(i);
        let mut idx = 0;
        while idx < tree[i as usize].len() {
            let ch = tree[i as usize][idx];
            Self::traverse(path, tree, ch, l + 1, jumps, lvls);
            idx += 1;
        }
        // for &ch in &tree[i as usize] {
        //     Self::traverse(path, tree, ch, l + 1, jumps, lvls);
        // }
        path.pop();
    }

    fn get_kth_ancestor(&self, node: i32, k: i32) -> i32 {
        if k <= 0 {
            return node;
        }
        if k > self.lvls[node as usize] {
            return -1;
        }
        let mut p = 1;
        let mut pos = 0;
        while p << 1 <= k {
            p <<= 1;
            pos += 1;
        }
        self.get_kth_ancestor(self.jumps[node as usize][pos], k - p)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tree_ancestor() {
        let tree = TreeAncestor::new(7, vec![-1, 0, 0, 1, 1, 2, 2]);
        assert_eq!(tree.get_kth_ancestor(0, 1), -1);
        assert_eq!(tree.get_kth_ancestor(3, 1), 1);
        assert_eq!(tree.get_kth_ancestor(5, 2), 0);
        assert_eq!(tree.get_kth_ancestor(6, 3), -1);
        assert_eq!(tree.get_kth_ancestor(6, 4), -1);
    }

    #[test]
    fn test_tree_ancestor_02() {
        let tree = TreeAncestor::new(10, vec![-1, 0, 0, 1, 2, 0, 1, 3, 6, 1]);
        assert_eq!(tree.get_kth_ancestor(8, 6), -1);
        assert_eq!(tree.get_kth_ancestor(9, 7), -1);
        assert_eq!(tree.get_kth_ancestor(1, 1), 0);
        assert_eq!(tree.get_kth_ancestor(2, 5), -1);
        assert_eq!(tree.get_kth_ancestor(4, 2), 0);
        assert_eq!(tree.get_kth_ancestor(7, 3), 0);
        assert_eq!(tree.get_kth_ancestor(3, 7), -1);
        assert_eq!(tree.get_kth_ancestor(9, 6), -1);
        assert_eq!(tree.get_kth_ancestor(3, 5), -1);
        assert_eq!(tree.get_kth_ancestor(8, 8), -1);
    }
}