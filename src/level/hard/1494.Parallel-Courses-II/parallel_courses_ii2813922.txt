// https://leetcode.com/problems/parallel-courses-ii/solutions/2813922/rust-bit-masking-dp/

impl Solution {
    pub fn min_number_of_semesters(n: i32, relations: Vec<Vec<i32>>, k: i32) -> i32 {
        let (n, sz) = (n as usize, 1 << n as usize);
        let mut graph = vec![vec![]; n];

        for relation in relations {
            let (u, v) = (relation[0] as usize - 1, relation[1] as usize - 1);

            graph[u].push(v);
        }

        let mut dp = vec![-1; sz];
        dp[sz - 1] = 0;

        Self::solve(&graph, &mut dp, 0, k as usize)
    }

    // return the available courses after finishing the courses masked in taken_mask
    fn availavle_courses(graph: &Vec<Vec<usize>>, taken_mask: usize) -> Vec<usize> {
        let n = graph.len();
        let mut indegree = vec![0; n];
        
        for u in 0 .. n {
            if 1 << u & taken_mask > 0 { continue }
            
            for v in &graph[u] { 
                if 1 << v & taken_mask > 0 { continue }
                
                indegree[*v] += 1; 
            }
        }

        let mut ret = vec![];
        for u in 0 .. n {
            if 1 << u & taken_mask == 0 && indegree[u] == 0 { ret.push(u); }
        }

        ret
    }
 
    fn solve(graph: &Vec<Vec<usize>>, dp: &mut Vec<i32>, taken_mask: usize, k: usize) -> i32 {
        if dp[taken_mask] != -1 { return dp[taken_mask] }

        let indexes = Self::availavle_courses(graph, taken_mask);

        if indexes.len() <= k {
            let mut new_mask = 0;
            for u in indexes { new_mask |= 1 << u; }
            
            dp[taken_mask] = 1 + Self::solve(graph, dp, taken_mask | new_mask, k);
            
            return dp[taken_mask]
        }

        let sz = 1 << indexes.len();
        dp[taken_mask] = i32::MAX;

        for mask in 0 .. sz {
            let (mut new_mask, mut cnt) = (0, 0);
            
            for k in 0 .. indexes.len() {
                if 1 << k & mask == 0 { continue }
                new_mask |= 1 << indexes[k];

                cnt += 1;
            }

            if cnt != k { continue }
             
             let temp = Self::solve(graph, dp, taken_mask | new_mask, k);
             if temp < dp[taken_mask] - 1 { dp[taken_mask] = 1 + temp; }           
        }

        dp[taken_mask]
    }
}