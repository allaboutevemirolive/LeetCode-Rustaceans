// https://leetcode.com/problems/fancy-sequence/solutions/898718/rust-keep-track-of-operations/
struct Fancy {
	// vector of (current value, index of ops that haven't been applied).
    items: Vec<(i64, usize)>,
	// vector of (is add operation, value of operation).
    ops: Vec<(bool, i32)>,
}

impl Fancy {
    fn new() -> Self {
        Fancy {
            items: vec![],
            ops: vec![],
        }
    }

    fn append(&mut self, val: i32) {
        self.items.push((val as i64, self.ops.len()));
    }

    fn add_all(&mut self, inc: i32) {
        self.ops.push((true, inc));
    }

    fn mult_all(&mut self, m: i32) {
        self.ops.push((false, m));
    }

    fn get_index(&mut self, idx: i32) -> i32 {
        let idx = idx as usize;
        if idx >= self.items.len() {
            return -1;
        }
        let item = &mut self.items[idx];
        for &(is_add, val) in self.ops[item.1..].iter() {
            if is_add {
                item.0 += val as i64;
            } else {
                item.0 *= val as i64;
                item.0 %= (10i64.pow(9) + 7);
            }
        }
        item.1 = self.ops.len();
        let res = item.0 % (10i64.pow(9) + 7);
        res as i32
    }
}
