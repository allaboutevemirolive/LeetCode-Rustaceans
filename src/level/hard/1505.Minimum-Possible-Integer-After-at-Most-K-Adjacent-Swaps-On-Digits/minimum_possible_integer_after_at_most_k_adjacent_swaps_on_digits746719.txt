// https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/solutions/746719/rust-translated-binary-indexed-tree/
#[derive(Debug, Default)]
struct BinaryIndexedTree {
    n: usize,
    nodes: Vec<i32>,
}

impl BinaryIndexedTree {
    fn new(n: usize) -> BinaryIndexedTree {
        BinaryIndexedTree {
            n,
            nodes: vec![0; n + 1],
        }
    }

    pub fn update(&mut self, idx: usize, delta: i32) {
        let mut i = (idx + 1) as i32;
        while i <= self.n as i32 {
            self.nodes[i as usize] += delta;
            i += i & (-i);
        }
    }

    pub fn query(&mut self, idx: usize) -> i32 {
        let mut i = (idx + 1) as i32;
        let mut sum = 0;
        while i > 0 {
            sum += self.nodes[i as usize];
            i -= i & (-i);
        }
        sum
    }
}
impl Solution {
    pub fn min_integer(num: String, k: i32) -> String {
        let n = num.len();
        let mut qs = vec![Vec::<i32>::new(); 10];
        for (pos, d) in num.as_bytes().iter().enumerate() {
            qs[(d - b'0') as usize].push(pos as i32);
        }
        let mut removed = vec![false; n];
        let mut tree = BinaryIndexedTree::new(n);
        let mut k = k;
        let mut ans = String::new();
        while k > 0 {
            let mut found = false;
            for d in 0..10 {
                if !qs[d as usize].is_empty() {
                    let pos = qs[d as usize][0];
                    let shifted = tree.query(pos as usize);
                    if pos - shifted <= k {
                        k -= pos - shifted;
                        tree.update(pos as usize, 1);
                        qs[d].remove(0);
                        ans.push((b'0' + d as u8) as char);
                        removed[pos as usize] = true;
                        found = true;
                        break;
                    }
                }
            }
            if !found {
                break;
            }
        }
        for i in 0..n {
            if !removed[i] {
                ans.push(num.as_bytes()[i] as char);
            }
        }
        ans
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_min_integer() {
        assert_eq!(
            Solution::min_integer(String::from("4321"), 4),
            String::from("1342")
        )
    }

    #[test]
    fn test_min_integer_02() {
        assert_eq!(
            Solution::min_integer(String::from("100"), 1),
            String::from("010")
        )
    }

    #[test]
    fn test_min_integer_03() {
        assert_eq!(
            Solution::min_integer(String::from("36789"), 1000),
            String::from("36789")
        )
    }

    #[test]
    fn test_min_integer_04() {
        assert_eq!(
            Solution::min_integer(String::from("22"), 22),
            String::from("22")
        )
    }

    #[test]
    fn test_min_integer_05() {
        assert_eq!(
            Solution::min_integer(String::from("9438957234785635408"), 23),
            String::from("0345989723478563548")
        )
    }
}