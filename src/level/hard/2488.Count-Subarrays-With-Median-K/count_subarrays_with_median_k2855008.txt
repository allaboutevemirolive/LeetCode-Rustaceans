// https://leetcode.com/problems/count-subarrays-with-median-k/solutions/2855008/rust-hashmap/
use std::collections::HashMap;

impl Solution {
    pub fn count_subarrays(nums: Vec<i32>, k: i32) -> i32 {
        let n = nums.len();
        let mut i = 0;
        while nums[i] != k { i += 1; }
        
        let (mut left, mut right) = (HashMap::<i32, i32>::new(), HashMap::<i32, i32>::new());
        
        let mut cnt = 0;
        *right.entry(cnt).or_default() += 1;
        for j in i + 1 .. n {
            cnt += if nums[j] > k { 1 } else { -1 };
            *right.entry(cnt).or_default() += 1;
        }
        
        cnt = 0;
         *left.entry(cnt).or_default() += 1;
        for j in (0 .. i).rev() {
            cnt += if nums[j] > k { 1 } else { -1 };
            *left.entry(cnt).or_default() += 1;
        }
        
        let mut ret = 0;
        for (key, val) in left {
            if let Some(cnt) = right.get(&(-key)) {
                ret += val * cnt;
            }
            if let Some(cnt) = right.get(&(1 - key)) {
                ret += val * cnt;
            }
        }
        
        ret
    }
}