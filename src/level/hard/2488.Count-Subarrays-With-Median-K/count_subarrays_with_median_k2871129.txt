// https://leetcode.com/problems/count-subarrays-with-median-k/solutions/2871129/rust-y/
use std::cmp::max;
use std::cmp::min;
use std::collections::HashMap;
impl Solution {
    pub fn count_subarrays(mut nums: Vec<i32>, mut k: i32) -> i32 {
        let mut ind: usize = 0;
        for (i, x) in nums.iter().enumerate() {
            if *x == k {
                ind = i;
            }
        }
        let mut dif: Vec<i32> = vec![0; nums.len()];
        for (i, x) in nums.iter().enumerate() {
            if i > ind {
                dif[i] = dif[i - 1];
                if *x > k {
                    dif[i] += 1;
                } else {
                    dif[i] -= 1;
                }
            }
        }
        let mut index: i32 = nums.len() as i32;
        for (i, x) in nums.iter().rev().enumerate() {
            index -= 1;
            if index < ind as i32 {
                dif[index as usize] = dif[(index + 1) as usize];
                if *x > k {
                    dif[index as usize] += 1;
                } else {
                    dif[index as usize] -= 1;
                }
            }
        }
        let mut ans: i32 = 0;
        let mut hm: HashMap<i32, i32> = HashMap::new();
        for (i, x) in dif.iter().enumerate() {
            if i >= ind {
                ans += hm.get(&(-*x)).unwrap_or(&0) + hm.get(&(-*x + 1)).unwrap_or(&0);
            }
            if i <= ind {
                if hm.contains_key(x) {
                    if let Some(val) = hm.get_mut(x) {
                        *val = *val + 1;
                    }
                } else {
                    hm.insert(*x, 1);
                }
            }
        }
        return ans as i32 + 1;
    }
}