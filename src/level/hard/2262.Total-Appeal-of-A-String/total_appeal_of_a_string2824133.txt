// https://leetcode.com/problems/total-appeal-of-a-string/solutions/2824133/rust-o-n-and-o-n-2-dp-solutions/
use std::collections::HashSet;
impl Solution {
    pub fn appeal_sum(s: String) -> i64 {
        let (mut sum, mut cur): (usize, usize) = (0, 0);
        // store the previous occurence (1-index) of a char
        let mut prev: [usize; 26] = [0; 26];
        
        /*
            the main premise here is for any '...*...*' we want to
            get the total amount of substrings ending at the second *
            minus the ones that already include a *. since we have
            already calculated the appeal upto this point
            (i.e., for '...*...') then the appeal for this
            will just be that value plus the number of substrings
            ending at the second * that do not include another *
            
            in this case we would want to skip the substrings starting with
            '...*', '..*', '.*', and '*' because these would cause a
            character 'collision' - we are effectively just adding
            (8 - 4) to our current value
            
            so, assuming that cur represents the appeal of all substrings
            ending at an index, we can just take the sum of these values
            at all indicies to get our result
        */
        
        for (i, c) in s.chars().enumerate() {
            cur += i + 1 - prev[c as usize - 0x61];
            prev[c as usize - 0x61] = i + 1;
            sum += cur
        }
        
        sum as _
        
        /* N^2 solution :(
        let as_chars = s.chars().collect::<Vec<char>>();
        let len = as_chars.len();
        
        let mut dp = vec![vec![None; len]; len];
        let mut sum: i64 = 0;
        
        for size in 1..=len {
            for left in 0..len-size+1 {
                let right = left + size - 1;
                match size {
                    1 => {
                        dp[left][left] = Some(HashSet::from([as_chars[left]]));
                        sum += 1;
                    },
                    _ => {
                        dp[left][right] = dp[left][right - 1].take();
                        if let Some(x) = dp[left][right].as_mut() {
                            x.insert(as_chars[right]);
                            sum += x.len() as i64;
                        }
                    }
                }
            }
        }
                
        sum
        */
    }
}