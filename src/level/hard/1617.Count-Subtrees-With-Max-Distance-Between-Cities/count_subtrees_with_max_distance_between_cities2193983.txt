// https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities/solutions/2193983/rust-bitmask-dfs/
use std::{
    borrow::Borrow,
    cell::RefCell,
    cmp::Ordering,
    collections::hash_map::Entry::Occupied,
    collections::hash_map::Entry::Vacant,
    collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque},
    rc::Rc,
};


impl Solution {
    pub fn count_subgraphs_for_each_diameter(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {
        // Convert the graph into an adjacency list
        let mut graph: HashMap<i32, Vec<i32>> = HashMap::new();
        for edge in edges {
            let u = edge[0];
            let v = edge[1];
            (*graph.entry(u).or_insert(vec![])).push(v);
            (*graph.entry(v).or_insert(vec![])).push(u);
        }

        let mut res = vec![0; (n - 1) as usize];
        for mask in 1..(1 << n) {
            match Self::max_dist(mask, &mut graph, n) {
                None => (),
                Some(dist) => res[dist as usize - 1] += 1,
            }
        }

        res
    }

    fn max_dist(mask: i32, graph: &mut HashMap<i32, Vec<i32>>, n: i32) -> Option<i32> {
        let mut cities = HashSet::new();
        for i in 1..=n {
            if mask >> (i - 1) & 1 == 1 {
                cities.insert(i);
            }
        }

        let mut res = 0;
        for city in &cities {
            match Self::dfs(*city, graph, &cities) {
                Some(dist) => res = std::cmp::max(res, dist),
                None => return None,
            }
        }

        if res == 0 {
            None
        } else {
            Some(res)
        }
    }

    fn dfs(start: i32, graph: &mut HashMap<i32, Vec<i32>>, cities: &HashSet<i32>) -> Option<i32> {
        let mut res = 0;
        let mut visited = HashSet::from([start]);

        let mut deque = VecDeque::from([start]);
        while !deque.is_empty() {
            let mut next_deque: VecDeque<i32> = VecDeque::new();
            while let Some(node) = deque.pop_front() {
                for next in graph.entry(node).or_default() {
                    if cities.contains(next) && !visited.contains(next) {
                        next_deque.push_back(*next);
                    }
                }

                visited.insert(node);
            }

            deque = next_deque;
            res += 1;
        }

        if visited.len() == cities.len() && res != 1 {
            Some(res - 1)
        } else {
            None
        }
    }
}
