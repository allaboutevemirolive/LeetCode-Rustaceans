// https://leetcode.com/problems/reorder-list/solutions/3347551/rust-recursive-and-stack-approach/
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn reorder_list(head: &mut Option<Box<ListNode>>) {
        fn using_stack(head: &mut Option<Box<ListNode>>) {
            let mut cur = head.take();
            let mut stack = vec![];
            while let Some(mut n) = cur.take() {
                cur = n.next.take();
                stack.push(Some(n));
            }

            let mut new_head = None;
            let mut new_tail = &mut new_head;

            let len = stack.len();
            let half = if len % 2 == 1 { len / 2 } else { (len - 1) / 2 };
            for i in 0..=half {
                let mut h = stack[i].take();
                let t = stack[len - 1 - i].take();
                h = h.map(|mut x| {
                    x.next = t;
                    x
                });
                let node = new_tail.insert(h.take().unwrap());
                if node.next.is_some() {
                    new_tail = &mut node.next.as_mut().unwrap().next;
                } else {
                    new_tail = &mut node.next;
                }
            }
            *head = new_head;
        }
        fn using_recursion(head: &mut Option<Box<ListNode>>) {
            fn weave(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
                if head.is_none() || head.as_mut().unwrap().next.is_none() {
                    return head;
                }
                let mut tail = &mut head;
                while tail.is_some() && tail.as_mut().unwrap().next.is_some() {
                    tail = &mut tail.as_mut().unwrap().next;
                }
                let tail = tail.take();
                let ret = weave(head.as_mut().unwrap().next.take());
                head.map(|mut x| {
                    x.next = tail.map(|mut x| {
                        x.next = ret;
                        x
                    });
                    x
                })
            }
            *head = weave(head.take());
        }
        using_recursion(head)      
    }
}