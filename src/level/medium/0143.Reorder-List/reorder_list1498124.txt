// https://leetcode.com/problems/reorder-list/solutions/1498124/rust-in-place-with-o-1-space/
use std::mem::swap;

fn cut(root: Option<&mut Box<ListNode>>, level: usize) -> (Option<Box<ListNode>>, usize) {
    match &mut root.unwrap().next {
        Some(node) => {
            let (middle, list_len) = cut(Some(node), level+1);
            let mut tail: Option<Box<ListNode>> = None;
            if level == list_len/2 - 1 {
                swap(&mut tail, &mut node.next);
                (tail, list_len)
            } else {
                (middle, list_len)
            }
            
        },
        None => {
            (None, level+1)
        }
    }
}

pub fn reverse_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
    let mut prev: Option<Box<ListNode>> = None;
    let mut curr: Option<Box<ListNode>> = head;
    loop {
        match curr {
            Some(mut boxed) => {
                let mut next = boxed.next.take();
                boxed.next = prev;
                prev = Some(boxed);
                curr = next.take();
            },
            None => {
                break;
            }
        }
    }
    prev
}

fn weave(mut a: Option<Box<ListNode>>, mut b: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
    let mut next_a: Option<Box<ListNode>> = a.as_mut().unwrap().next.take();
    let mut next_b: Option<Box<ListNode>> = b.as_mut().unwrap().next.take();
    a.as_mut().unwrap().next = b;
    match next_b {
        Some(boxed_b) => {
            a.as_mut().unwrap().next.as_mut().unwrap().next = weave(next_a, Some(boxed_b));
        },
        None => {
            a.as_mut().unwrap().next.as_mut().unwrap().next = next_a;
        }
    }
    a
}

impl Solution {
    pub fn reorder_list(head: &mut Option<Box<ListNode>>) {
        //println!("Cutting...");
        let (mut tail, _) = cut(head.as_mut(), 0);
        //println!("head: {:?}", head);
        //println!("tail: {:?}", tail);
        
        if !tail.is_none() {
            //println!("Reversing tail...");
            tail = reverse_list(tail);
            //println!("tail: {:?}", tail);

            //println!("Weaving...");
            let mut new_head: Option<Box<ListNode>> = None;
            swap(head, &mut new_head);
            new_head = weave(new_head, tail);
            swap(head, &mut new_head);
            //println!("head: {:?}", head);
        }
    }
}