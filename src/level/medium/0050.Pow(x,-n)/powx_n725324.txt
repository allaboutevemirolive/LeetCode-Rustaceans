// https://leetcode.com/problems/powx-n/solutions/725324/rust-0ms-1-9mb/
use std::f64;
impl Solution {
    pub fn my_pow(a: f64, n: i32) -> f64 {
        match a {
            0.0 => match n {
                0 => 1.0, // 0^0 == 1
                y if y.is_negative() => f64::NAN, // NaN, division-by-zero
                _ => 0.0, // 0^n == 0
            },
            1.0 => 1.0, // 1^n == 1
            -1.0 => if n % 2 == 0 { 1.0 } else { -1.0 }, // even -> 1.0, odd -> -1.0
            x => match n {
                0 => 1.0, // x^ == 0
                1 => x, // x^1 == x
                y if y.is_negative() => //x^(-n) == 1/x^n
                    1.0/( Self::my_pow(x, (y/2).abs())*Self::my_pow(x, (y - y/2).abs()) ),
                y => // x^n == x^(n/2)*x^(n/2)*x^(n%2)
                    Self::my_pow(x, y/2)*Self::my_pow(x, y/2)*Self::my_pow(x, y%2),
            }
        }
    }
}