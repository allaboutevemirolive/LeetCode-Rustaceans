// https://leetcode.com/problems/course-schedule/solutions/609468/rust-prod-like-version/
use std::collections::{HashMap, HashSet};

impl Solution {
    pub fn can_finish(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> bool {
        //println!("start");

        let graph = Graph::new(prerequisites);

        //println!("build dag_info");
        let mut dag_info = graph.graph.iter()
            .map(|(v, adjs)| (*v, adjs.len() as i32))
            .collect::<HashMap<i32, i32>>();

        loop {
            //println!("looking for zero degrees. Dag: {:?}", dag_info);

            if dag_info.is_empty() {
                println!("Dag is empty. It possible to finish courses");
                return true;
            }

            let zero_degrees = dag_info.iter()
                .filter(|(_, degree)| **degree == 0)
                .map(|(v, _)| v)
                .copied()
                .collect::<HashSet<i32>>();

            //println!("Zero degree vertexes: {:?}", zero_degrees);

            if zero_degrees.is_empty() {
                println!("There is no zero_degree vertexes in the graph, but dag is not empty. So there is a cycle. Not possible to finish cources");
                return false;
            }

            //remove all zero_degree vertexes
            dag_info = dag_info
                .iter()
                .filter(|(v, _)| {
                    !zero_degrees.contains(v)
                })
                .map(|(k, v)| (*k, *v))
                .collect::<HashMap<i32, i32>>();

            //decrease all vertexes degrees by subtracting zero degree vertexes
            zero_degrees.iter().for_each(|zero_vertex| {
                graph.in_degree[zero_vertex].iter().for_each(|adj| {
                    dag_info.insert(*adj, dag_info[adj] - 1);
                });
            });
        }
    }
}

struct Graph {
    graph: HashMap<i32, HashSet<i32>>,
    in_degree: HashMap<i32, HashSet<i32>>,
}

impl Graph {
    fn new(edges: Vec<Vec<i32>>) -> Graph {
        println!("build a graph");

        let mut graph: HashMap<i32, HashSet<i32>> = HashMap::new();
        let mut in_degree: HashMap<i32, HashSet<i32>> = HashMap::new();

        for edge in edges {
            let vrt = edge[0];
            let adj = edge[1];
            graph.entry(vrt).or_insert_with(|| HashSet::new()).insert(adj);
            graph.entry(adj).or_insert_with(|| HashSet::new());

            in_degree.entry(adj).or_insert_with(|| HashSet::new()).insert(vrt);
            in_degree.entry(vrt).or_insert_with(|| HashSet::new());
        }

        return Graph { graph, in_degree };
    }
}