// https://leetcode.com/problems/3sum-closest/solutions/1652178/rust/


struct Solution{}
impl Solution {
    pub fn three_sum_closest(nums: Vec<i32>, target: i32) -> i32 {
        let mut n:Vec<i32> = vec![];
        let mut min = i32::MAX;
        let mut ans:i32 = 0;
        let mut nums =  nums.clone();
        nums.sort();
        for i in 0..nums.len()-2{
            let mut left = i + 1;
            let mut right = nums.len() - 1;
            while left < right{
                let m = nums[i] + nums[left]+ nums[right];
                n.push(m);
                if m > target{
                    right = right - 1;
                }else{
                    left = left + 1;
                }
               
            }        
        }
        if n.len() > 1{
            for i in n.iter(){
                let m = i32::abs(i-target);              
                if min > m{
                    min = m;
                    ans = *i as i32;
                }
            }
        }else{
            return n[0]
        }
        ans
    }
}
fn main() {
    
    println!("{:?}",Solution::three_sum_closest(vec![1,1,-1,-1,3], 3));

}
#[cfg(test)]
mod test{
    use crate::Solution;

    #[test]
    fn main_test(){
        assert_eq!(Solution::three_sum_closest(vec![-1,2,1,-4], 1),2);
        assert_eq!(Solution::three_sum_closest(vec![0,0,0], 1),0);
        assert_eq!(Solution::three_sum_closest(vec![1,1,1,1], 3),3);
        assert_eq!(Solution::three_sum_closest(vec![1,1,-1,-1,3], 3),3);
        assert_eq!(Solution::three_sum_closest(vec![0,2,1,-3], 1),0);
    }    
}

