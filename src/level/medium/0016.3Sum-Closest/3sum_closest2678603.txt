// https://leetcode.com/problems/3sum-closest/solutions/2678603/rust-sort-with-moving-pointers-two-styles/
impl Solution {
    pub fn three_sum_closest(nums: Vec<i32>, target: i32) -> i32 {
        let n = nums.len();
        
        let sorted_nums = {
            // Leetcode doesn't give us mut nums, need mut to sort
            let mut temp = nums.clone(); 
            temp.sort();
            temp
        };
        
        let mut diff: Option<i32> = None;
        
        for (i, &i_num) in sorted_nums.iter().enumerate() {
            let (mut low, mut high) = (i+1, n-1);
            while low < high {
                let curr = i_num + sorted_nums[low] + sorted_nums[high];
                if curr == target {
                    return target;
                }
                
                match diff {
                    None => {diff = Some(target-curr);},
                    Some(d) => {
                        if (target-curr).abs() < d.abs() {
                            diff = Some(target-curr);    
                        }
                        
                        if curr < target {
                            low += 1;
                        } else {
                            high -= 1;
                        }
                    }
                }
            }
        }
        
        target - diff.unwrap_or(0)   
    }
}