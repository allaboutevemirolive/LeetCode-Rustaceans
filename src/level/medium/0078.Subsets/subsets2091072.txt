// https://leetcode.com/problems/subsets/solutions/2091072/rust-clean-solution-100-faster/
fn unique_subset(set: &Vec<i32>, tmp: &Vec<i32>, idx: usize, result: &mut Vec<Vec<i32>>) {
    if idx >= set.len() {
        // Push the current collected set into result
        result.push(tmp.clone());
        return;
    }

    // One branch would collect the current element
    // another branch would exclude the element

    // Exclude the current element
    unique_subset(set, tmp, idx + 1, result);

    // Include the current element
    // Push the current element
    let mut tmp2 = Vec::new();
    for e in tmp {
        tmp2.push(*e);
    }
    tmp2.push(set[idx]);

    unique_subset(set, &tmp2, idx + 1, result);
}

impl Solution {
    pub fn subsets(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let mut result = Vec::new();
        unique_subset(&nums, &Vec::new(), 0, &mut result);
        
        return result;
    }
}