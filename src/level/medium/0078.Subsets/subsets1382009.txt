// https://leetcode.com/problems/subsets/solutions/1382009/rust-iterative-bit-manipulation/
impl Solution {
    pub fn subsets(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let N: usize = nums.len();
        let mut res:Vec<Vec<i32>> = Vec::with_capacity(N);
        let largest:usize = 0x01 << N; // number of combinations to iterate
        let mut perm:Vec<i32> = vec![0; N];
        let mut high:usize = 0;
        for curr in 0..largest {
            res.push(Solution::int_to_vector(&nums, curr, &mut perm));
        }
        
        return res;
    }
    
    /***
     * Given some integer curr describing a permutation of what we've picked and
     * haven't in the array A, determine the permutation
     ***/
    fn int_to_vector(A: &Vec<i32>, curr: usize, perm: &mut Vec<i32>) -> Vec<i32> {
        let high_bit = Solution::highest_set_bit(curr);
        // println!("highest bit of {} is {}", curr, high_bit);
        
        // copy to perm
        let mut perm_size: usize = 0;
        let mut mask: usize = 0x01;
        for idx in 0..high_bit {
            if curr & mask != 0 { // select
                perm[perm_size] = A[idx];
                perm_size += 1;
            }
            
            mask = mask << 0x01;
        }
        
        return perm[0..perm_size].iter().cloned().collect();
    }
    
    /***
     * Determine the highest set bit of x (one-indexed). So, a 0 means that no bits are set.
     * Could use a loop but it's possible to do this via divide and conquer
     *
     * Assumes at most we're dealing with a 16-bit integer; otherwise we'd have
     * to extend with a few more if statements to account for larger inputs
     *
     * Ex: 1  0  1  1 | 1  1  1  1 | 1  1  1  1 | 1  1  1  1
           16 15 14 13  12 11 10 9   8  7  6  5   4  3  2  1
     * Should return 16 as the highest bit set
     *
     ***/
    fn highest_set_bit(x: usize) -> usize {
        let mut res:usize = 0;
        let mut curr:usize = x;
        // assume we're dealing with at largest a 16-bit unsigned integer
        // so split in half
        if curr >= 0x0100 { // compare against 2^8 = 2^4 * 2^4 = two hex bits
            //    1011 1111 1111 1111
            // => 0000 0000 1011 1111
            res += 9;
            curr >>= 8;
        }
        
        if curr >= 0x10 { // 2^4 = 1 hex bit
            //     1011 1111
            // =>  0000 1011
            res += 5;
            curr >>= 4;
        }
        
        if curr >= 0x04 { // 2^2
            //     1111
            // =>  0011
            res += 3;
            curr >>= 2;
        }
        
        if curr >= 0x02 { // 2^1
            //    11
            // => 01
            res += 2;
            curr >>= 1;
        }
        if curr == 0x01 { // rightmost bit considered
            res += 1;
        }
        
        return res;
    }
}