// https://leetcode.com/problems/longest-palindromic-substring/solutions/845846/0ms-in-rust/
 fn expand_around_center(s: &[u8], left: usize) -> (usize, usize, usize) {
    let (mut l, mut r) = (left, left);
    while r + 1 < s.len() && s[r+1] == s[l] {
        r += 1;
    }
    let next = r + 1;

    while l > 0 && r + 1 < s.len() {
        if s[l - 1] == s[r + 1] {
            l -= 1;
            r += 1;
        } else {
            break;
        }
    }
    (l, r, next)
}



impl Solution {

pub fn longest_palindrome(s: String) -> String {
    if s.is_empty() {
        return s;
    }

    let bytes = s.as_bytes();
    let (mut start, mut end) = (0, 0);

    let mut i = 0;
    while (bytes.len() - i) * 2 > (end - start + 1) + 1 {
        let (l, r, n) = expand_around_center(bytes, i);
        i = n;
        if r - l + 1 > end - start + 1 {
            start = l;
            end = r;
        }
    }

    String::from_utf8(bytes[start..=end].to_vec()).unwrap()
}


}