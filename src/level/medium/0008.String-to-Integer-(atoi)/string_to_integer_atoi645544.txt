// https://leetcode.com/problems/string-to-integer-atoi/solutions/645544/rust-0ms/
#[derive(Clone, Copy, PartialOrd, PartialEq, Ord, Eq)]
#[repr(u8)]
enum State {
    Skipping,
    Parsing,
}

impl Solution {
    pub fn my_atoi(str: String) -> i32 {
        let mut result: i32 = 0;
        let mut is_negative = false;
        
        let mut state = State::Skipping;
        
        for byte in str.bytes() {
            match byte {
                b' ' | b'\n' | b'\t' if state == State::Skipping => continue,
                b'-' if state == State::Skipping => {
                    state = State::Parsing;
                    is_negative = true;
                }
                b'+' if state == State::Skipping => {
                    state = State::Parsing;
                },
                v @ b'0'..=b'9' => {
                    state = State::Parsing;
                    match result.checked_mul(10).and_then(|result| result.checked_add((v - b'0') as i32)) {
                        Some(v) => result = v,
                        None => {
                            return if is_negative {
                                std::i32::MIN
                            } else {
                                std::i32::MAX
                            };
                        }
                    }
                }
                _ => break,
            }
        }
        
        if is_negative {
            result = result.saturating_mul(-1);
        }
        
        result
    }
}