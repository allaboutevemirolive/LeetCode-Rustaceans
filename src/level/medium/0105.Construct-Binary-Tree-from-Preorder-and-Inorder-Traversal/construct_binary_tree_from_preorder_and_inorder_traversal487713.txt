// https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/487713/rust-solution/
struct Helper {
	index: i32,
	inorder: Vec<i32>,
	preorder: Vec<i32>,
}

impl Helper {
	pub fn helper(&mut self, ini: i32, end: i32) -> Option<Rc<RefCell<TreeNode>>> {
		if ini > end {
			return None;
		}
		let mut node = TreeNode::new(self.preorder[self.index as usize]);
		self.index += 1;
		if ini == end {
			return Some(Rc::new(RefCell::new(node)));
		}

		let index = self.inorder.iter().position(|&e| e == node.val).unwrap() as i32;
		node.left = self.helper(ini, index - 1);
		node.right = self.helper(index + 1, end);
		Some(Rc::new(RefCell::new(node)))
	}
}

impl Solution {
    pub fn build_tree(preorder: Vec<i32>, inorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {
		let len = preorder.len();
		let mut h = Helper {
			index: 0,
			inorder,
			preorder,
		};

		h.helper(0, len as i32 - 1)
	}
}