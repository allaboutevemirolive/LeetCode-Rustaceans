// https://leetcode.com/problems/number-of-boomerangs/solutions/888717/rust-better-than-100-due-to-microoptimizations-o-n-2/
impl Solution {
    pub fn number_of_boomerangs(points: Vec<Vec<i32>>) -> i32 {
        use std::collections::HashMap;

        let mut ans = 0;
        let mut map = HashMap::<i32, i32>::new();
        for i in 0..points.len() {
            for j in 0..points.len() {
                if i == j {
                    continue;
                }
				// here we suffer from double indirection
				// At first, we jump to the location of i inner vec (one cache miss)
				// then we jump to the j inner vec location (second cache miss)
				// Also there are 2 bounds check for each inner vecs
				// this can be lowered to one if calc for 1
                let dx = points[i][0] - points[j][0];
                let dy = points[i][1] - points[j][1];
                let dist = dx * dx + dy * dy;
                *map.entry(dist).or_default() += 1;
            }
            for &val in map.values() {
                ans += val * (val - 1);
            }
			// This is smart move: reuse allocation
            map.clear();
        }
        ans
    }
}