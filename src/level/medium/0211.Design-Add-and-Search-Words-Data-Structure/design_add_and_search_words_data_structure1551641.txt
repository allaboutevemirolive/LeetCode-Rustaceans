// https://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/1551641/rust-24ms-iterative-dfs/
use std::collections::HashMap;

#[derive(PartialEq, Eq, Default, Debug)]
struct Trie { 
    children: HashMap<char, Trie>,
    end: bool,
}

#[derive(Default)]
struct WordDictionary {
    trie: Trie
}

impl WordDictionary {
    fn new() -> Self {
        WordDictionary { 
            trie: Trie::default()
        }
    }
    fn add_word(&mut self, word: String) {
        self.trie.insert(&word)
    }
    
    fn search(&self, word: String) -> bool {
        self.trie.search(&word)
    }
}

// Implement Trie [leetcode 208]
impl Trie { 
    fn insert(&mut self, word: &str) { 
        let mut curr = self;
        
        for ch in word.chars() { 
            curr = curr.children.entry(ch).or_default();
        }
        curr.end = true 
    }
    fn search(&self, word: &str) -> bool { 
        let mut curr = self;
        if word.is_empty() { return self.end}    
        
        let ch = word.chars().next().unwrap();
        
        if ch == '.' {
            //  .a
            for child in curr.children.values() { 
                // Depth for search/ iterative matching   
                if Self::search(child, &word[1..]) { 
                    return true 
                } 
            }

        } else { 
            if let Some(child) = curr.children.get(&ch) { 
                return Self::search(child, &word[1..])
            } else { return false}
        }
        false
    }
} 
