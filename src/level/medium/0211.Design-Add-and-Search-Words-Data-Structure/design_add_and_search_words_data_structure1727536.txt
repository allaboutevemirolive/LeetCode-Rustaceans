// https://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/1727536/rust-trie/
/// @author: Leon
/// https://leetcode.com/problems/design-add-and-search-words-data-structure/
/// Time Complexities:
///     `new()`:        O(1)
///     `add_word()`:   O(`_len_wd`)
///     `search()`:     O(`_len_wd`)
/// Space Complexity:   O(n * `_len_wd`)
use std::cell::RefCell;
use std::rc::Rc;

struct WordDictionary {
    root: Rc<RefCell<TrieNode>>,
}

impl WordDictionary {
    fn new() -> Self {
        WordDictionary {
            root: Rc::new(RefCell::new(TrieNode::new(None))),
        }
    }

    fn add_word(&mut self, word: String) {
        let mut cur = Some(self.root.clone());
        for ch in word.chars() {
            let idx_ch: usize = ch as usize - 'a' as usize;
            let tmp = cur.unwrap().clone();
            let children = &mut tmp.borrow_mut().children;
            if children[idx_ch].is_none(){
                children[idx_ch] = Some(Rc::new(RefCell::new(TrieNode::new(None))));
            }
            cur = children[idx_ch].clone();
        }
        cur.unwrap().borrow_mut().word = Some(word);
    }

    fn search(&self, word: String) -> bool {
        Self::dfs(0, &word.chars().collect(), self.root.clone())
    }

    fn dfs(idx: usize, chs_wd: &Vec<char>, node: Rc<RefCell<TrieNode>>) -> bool {
        let len_w: usize = chs_wd.len();
        const ANY: char = '.';
        if idx == len_w {
            return node.borrow().word.is_some();
        }
        let ch = chs_wd[idx];
        match ch {
            ANY => {
                for ele in node.borrow().children.iter() {
                    if let Some(child) = ele.clone() {
                        if Self::dfs(idx + 1, chs_wd, child) {
                            return true;
                        }
                    }
                }
            }
            _ => match node.borrow().children[ch as usize - 'a' as usize].clone() {
                Some(child) => {
                    return Self::dfs(idx + 1, chs_wd, child);
                }
                None => return false,
            },
        }
        false
    }
}

struct TrieNode {
    word: Option<String>,
    children: Vec<Option<Rc<RefCell<TrieNode>>>>,
}

impl TrieNode {
    fn new(word: Option<String>) -> Self {
        TrieNode {
            word,
            children: vec![None; 26],
        }
    }
}