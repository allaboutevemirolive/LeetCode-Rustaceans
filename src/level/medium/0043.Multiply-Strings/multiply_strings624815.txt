// https://leetcode.com/problems/multiply-strings/solutions/624815/rust-iterator-based-solution-annotated/
    pub fn multiply(num1: String, num2: String) -> String {
        // prepopulate answer with zeroes; answer will not be longer than sum of lens of two inputs
        let mut ans = vec![0;num1.len()+num2.len()];
        let num2_iter = num2.chars()
                            .rev()
                            .map(|c| c as u8 - 48) // convert char to digit
                            .enumerate();
        num1.chars()
            .rev()
            .map(|c| c as u8 - 48) // convert char to digit 
            .enumerate()
            .for_each(|(n,i)| {
                num2_iter.clone().for_each(|(m,j)| {
                    let product = i*j + ans[n+m]; // ans[n+m] will contain any previous carry value, add it to the product
                    ans[n+m] = product % 10; // only insert the last digit of the product
                    ans[n+m+1] += product / 10; // insert the carry value to the next place
                })
        });
        // solution may have padded zeroes, b/c it is still reversed check for trailing zeroes and remove them unless there is only one digit
        while ans.len() > 1 && ans.last() == Some(&0) {
            ans.pop();
        }
        // reverse, convert back to chars, and collect into string
        ans.iter().rev().map(|i| (i+48) as char).collect::<String>()
    }