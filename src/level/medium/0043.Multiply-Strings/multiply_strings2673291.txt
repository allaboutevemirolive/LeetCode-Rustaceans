// https://leetcode.com/problems/multiply-strings/solutions/2673291/rust-simulation/
impl Solution {
    pub fn multiply(mut num1: String, mut num2: String) -> String {
        if num1 == "0" || num2 == "0" {
            return "0".to_owned();
        }
        if num1.len() < num2.len() {
            std::mem::swap(&mut num1, &mut num2);
        }

        let num1: Vec<u8> = num1.bytes().map(|b| b - b'0').collect();

        let (product, _) = num2
            .bytes()
            .rev()
            .fold((vec![], 0), |(product, zeroes), b| {
                let d = b - b'0';
                let mut add = Self::multiply_one(num1.clone(), d);
                add.resize(add.len() + zeroes, 0);

                let sum = Self::add(product, add);
                (sum, zeroes + 1)
            });

        product
            .iter()
            .map(|b| char::from_digit(*b as u32, 10).unwrap())
            .collect()
    }

    fn add(mut num1: Vec<u8>, mut num2: Vec<u8>) -> Vec<u8> {
        num1.reverse();
        num2.reverse();

        num1.resize(num1.len().max(num2.len()), 0);
        num2.resize(num1.len().max(num2.len()), 0);

        let mut add = 0;
        num1.iter_mut().zip(num2.iter()).for_each(|(n1, n2)| {
            *n1 += n2 + add;
            add = *n1 / 10;
            *n1 %= 10;
        });

        if add == 1 {
            num1.push(1);
        }

        num1.reverse();
        num1
    }

    fn multiply_one(mut num1: Vec<u8>, d: u8) -> Vec<u8> {
        let mut add = 0;
        num1.iter_mut().rev().for_each(|x| {
            *x = *x * d + add;
            add = *x / 10;
            *x %= 10;
        });
        if add != 0 {
            num1.insert(0, add)
        }

        num1
    }
}