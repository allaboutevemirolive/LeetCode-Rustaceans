// https://leetcode.com/problems/multiply-strings/solutions/1432532/rust-0ms-sliding-window-custom-iterator/
impl Solution {
    pub fn multiply(num1: String, num2: String) -> String {
        // handle annoying edge cases
        if num1 == "0" || num2 == "0" {
            return "0".to_string();
        }

        // let's allocate less
        let mut res = Vec::with_capacity(num1.len() + num2.len());

        // process numbers in sliding windows:
        //    *  123
        //       456
        // ---------
        // +  |7|3|8
        //  |6|1|5
        // 4|9|2
        let mut iters = Vec::with_capacity(num1.len());
        for coefficient in num2.chars().rev().filter_map(|c| c.to_digit(10)) {
            iters.push(NumFromCharIterator::new(num1.chars().rev(), coefficient));
        }

        let mut lower = 0;
        let mut upper = 1;
        let mut carry = 0;
        loop {
            let mut modified = false;
            let mut sum = 0;
            for i in lower..upper {
                if let Some(digit) = iters.get_mut(i).and_then(|iter| iter.next()) {
                    modified = true;
                    sum += digit;
                    // indicates ith sliding window has exhausted itself
                } else if lower == i {
                    lower += 1;
                }
            }
            if carry != 0 {
                modified = true;
                sum += carry;
            }
            if !modified {
                break;
            }

            res.push(std::char::from_digit(sum % 10, 10).unwrap());
            carry = sum / 10;
            upper += 1;
        }

        res.reverse();
        res.into_iter().collect()
    }
}

struct NumFromCharIterator<T> {
    digits: T,
    coefficient: u32,
    carry: u32,
}

impl<T> NumFromCharIterator<T> {
    fn new(digits: T, coefficient: u32) -> NumFromCharIterator<T> {
        NumFromCharIterator {
            digits,
            coefficient,
            carry: 0,
        }
    }
}

impl<T> Iterator for NumFromCharIterator<T>
where
    T: Iterator<Item = char>,
{
    type Item = u32;

    fn next(&mut self) -> Option<u32> {
        if let Some(digit) = self.digits.next() {
            let digit = digit.to_digit(10).unwrap();
            let n = digit * self.coefficient + self.carry;
            self.carry = n / 10;
            Some(n % 10)
        } else if self.carry != 0 {
            let tmp = self.carry;
            self.carry = 0;
            Some(tmp)
        } else {
            None
        }
    }
}