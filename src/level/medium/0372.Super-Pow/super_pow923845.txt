// https://leetcode.com/problems/super-pow/solutions/923845/rust-0ms-o-1-space/
impl Solution {
    pub fn super_pow(a: i32, b: Vec<i32>) -> i32 {
        let a = a as usize % 1337;
        if a <= 1 {
            return a as i32;
        }
        
        // find cycle where a^(cycle + 1) % 1337 == a % 1337
        let cycle = Self::find_cycle(a);

        // calculate b % cycle
        let mut mod_cycle = Self::big_modulo(b, cycle);
        if mod_cycle == 0 {
            mod_cycle = cycle;
        }
        
        // calculate a^mod_cycle % 1337
        let original = a;
        let mut a = a;
        for _ in 1..mod_cycle {
            a *= original;
            a %= 1337;
        }
        a as i32
    }
    
    pub fn big_modulo(b: Vec<i32>, m: i32) -> i32 {
        if m == 1 {
            0
        } else {
            let mut power_10 = 1;
            b.iter().rev().fold(0, |carry, &v| {
                let carry = (power_10 * v + carry) % m;
                power_10 = (power_10 * 10) % m;
                carry
            })
        }
    }
    
    pub fn find_cycle(mut a: usize) -> i32 {
        let original = a;
        let mut count = 1;
        
        loop {
            count += 1;
            
            a *= original;
            a %= 1337;
            
            if a == original {
                return count - 1;
            }
        }
    }
}