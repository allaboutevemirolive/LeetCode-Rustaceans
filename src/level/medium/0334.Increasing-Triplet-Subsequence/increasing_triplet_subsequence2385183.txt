// https://leetcode.com/problems/increasing-triplet-subsequence/solutions/2385183/rust-solution-using-lower-bound/
type Target = i32;
type UseValue = i32;
fn lower_bound(arr: &Vec<Target>, x: &UseValue) -> usize {
    let mut low = 0;
    let mut high = arr.len();
    while low != high {
        let mid = (low + high) / 2;
        match arr[mid].cmp(x) {
            std::cmp::Ordering::Less => {
                low = mid + 1;
            }
            std::cmp::Ordering::Equal | std::cmp::Ordering::Greater => {
                high = mid;
            }
        }
    }
    low
}

impl Solution {
    pub fn increasing_triplet(nums: Vec<i32>) -> bool {
        let mut arr = vec![nums[0]];
        let n = nums.len();
        for i in 1..n {
            let v = nums[i];
            let ti = lower_bound(&arr, &v);
            if ti >= arr.len() {
                arr.push(v);
            } else {
                arr[ti] = v;
            }
        }

        3 <= arr.len()
    }
}