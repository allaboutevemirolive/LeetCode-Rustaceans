// https://leetcode.com/problems/perfect-squares/solutions/2494714/rust-bfs-solution/
use std::collections::VecDeque;

struct SearchNode {
    num: i32,
    depth: i32
}

impl Solution {
    pub fn num_squares(n: i32) -> i32 {
        let mut visited = vec![false; (n + 1) as usize];
        let mut squares = Vec::<i32>::new();
        let end_range = f64::floor(f64::sqrt(n as f64)) as i32;
        let mut deq = VecDeque::<SearchNode>::new();
        
        deq.push_back(SearchNode{num : 0, depth : 0}); // For depth 1 squares
        for i in 1 ..= end_range {
            deq.push_back(SearchNode{num : i * i, depth : 1});
            squares.push(i * i);
        }
        
        while !deq.is_empty() {
            if let Some(node) = deq.pop_front() {
                for square in &squares {
                    if node.num + square == n {
                        return node.depth + 1;
                    } else if node.num + square < n && !visited[(node.num + square) as usize] {
                        visited[(node.num + square) as usize] = true;
                        deq.push_back(SearchNode{num : node.num + square, depth : node.depth + 1});
                    } else if (node.num + square > n) {
                        break;
                    }
                }
            }
        }
        
        0
    }
}