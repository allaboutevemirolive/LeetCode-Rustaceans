// https://leetcode.com/problems/water-and-jug-problem/solutions/679597/rust-gcd-recursive-binary-algorithm/
impl Solution {
    pub fn can_measure_water(x: i32, y: i32, z: i32) -> bool {
        let diff = x -y;
        if diff == 0 {
            match z {
                z if x == z || y == z || z == 0 => true,
                _ => false
            }
        } else {
            x+y >= z && z % (gcd(x,y)) == 0
        }
    }
}
    
fn gcd(x: i32, y: i32) -> i32 {
    if x == y {
        return x
    } else if x == 0 {
        return y
    } else if y == 0 {
        return x
    } else {
        match (x & 1_i32, y & 1_i32) {
            (0, 0) => return gcd(x >> 1, y >> 1) << 1, // both are even, divide each by two (>>1) 
                                                      // find GCD of quotients and multiply that recursive GCD by two (<<1)
            (0, 1) => return gcd(x >> 1, y), // x is even, y is odd, divide x by two, find gcd of quotient and y
            (1, 0) => return gcd(x, y >> 1), // x is odd, y is even, divide y by two, find gcd of quotient and x
            (1,1) => return gcd((x-y).abs() >> 1, x.min(y)), // both are odd, reduce larger element and divide by two then 
                                                             // find gcd of that and lesser element
            _ => unreachable!()
        }
    }
}