// https://leetcode.com/problems/different-ways-to-add-parentheses/solutions/920037/fun-with-rust/
#[derive(Debug)]
enum Operator {
    Add,
    Subtract,
    Multiply,
}

impl Operator {
    fn fromChar(c: &char) -> Operator {
        match c {
            '+' => Operator::Add,
            '-' => Operator::Subtract,
            '*' => Operator::Multiply,
            _ => panic!("bad input"),
        }
    }
    fn eval(&self, left: &i32, right: &i32) -> i32 {
        match self {
            Operator::Add => left+right,
            Operator::Subtract => left-right,
            Operator::Multiply => left*right,
        }   
    }
}

impl Solution {
    fn comp(nums: &Vec<i32>, ops: &Vec<Operator>, l: usize, r: usize) -> Vec<i32> {
        if l == r {
            return vec![nums[l]];
        }
        let mut result = vec![];
        for i in l..r {
            let left = Solution::comp(&nums, &ops, l, i);
            let right = Solution::comp(&nums, &ops, i+1, r);
            for _l in left.iter() {
                for _r in right.iter() {
                    result.push(ops[i].eval(_l, _r));
                }
            }
        }
        result
    }
    pub fn diff_ways_to_compute(input: String) -> Vec<i32> {
        let mut ops: Vec<Operator> = vec![];
        let mut nums: Vec<i32> = vec![];
        let mut v = 0;
        for c in input.chars() {
            match c {
                d if d.is_digit(10) => {
                    v *= 10;
                    v += d.to_digit(10).unwrap() as i32;
                },
                c => {
                    nums.push(v);
                    v = 0;
                    ops.push(Operator::fromChar(&c));
                }
            }
        }
        nums.push(v);
        return Solution::comp(&nums, &ops, 0, nums.len()-1);
    }
}