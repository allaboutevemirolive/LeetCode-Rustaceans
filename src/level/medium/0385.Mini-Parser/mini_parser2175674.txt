// https://leetcode.com/problems/mini-parser/solutions/2175674/rust-dfs/
// #[derive(Debug, PartialEq, Eq)]
// pub enum NestedInteger {
//   Int(i32),
//   List(Vec<NestedInteger>)
// }
impl Solution {
    pub fn deserialize(s: String) -> NestedInteger {
        let mut u = 0;
        dfs(s.as_bytes(), &mut u)
    }
}

fn dfs(s: &[u8], u: &mut usize) -> NestedInteger {
    let mut res = Vec::new();
    match s[*u] {
        b'[' => {
            *u += 1; // jump '['
            while s[*u] != b']' {
                res.push(dfs(s, u));
            }
            *u += 1; // jumo ']'
            if *u < s.len() && s[*u] == b',' {
                // jump ','
                *u += 1;
            }
        }
        _ => {
            let mut k = *u;
            while k < s.len() && s[k] != b',' && s[k] != b']' {
                k += 1;
            }
            let f = NestedInteger::Int(parse_to_int(&s[*u..k]));
            if k < s.len() && s[k] == b',' {
                // jump ','
                k += 1;
            }
            *u = k;
            // delay return
            return f;
        }
    }
    NestedInteger::List(res)
}

fn parse_to_int(s: &[u8]) -> i32 {
    let mut res = 0;
    let mut sign = 1;
    for c in s {
        if *c == b'-' {
            sign = -1;
            continue;
        }
        if !c.is_ascii_digit() {
            break;
        }
        res = res * 10 + (*c - b'0') as i32;
    }
    res * sign
}