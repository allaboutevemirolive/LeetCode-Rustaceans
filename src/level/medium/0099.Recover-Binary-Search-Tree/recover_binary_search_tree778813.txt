// https://leetcode.com/problems/recover-binary-search-tree/solutions/778813/rust-using-treeiter/
use std::cell::RefCell;
use std::rc::Rc;

pub struct TreeIter {
    levels: Vec<Rc<RefCell<TreeNode>>>,
}

impl TreeIter {
    fn all_left(mut node: Rc<RefCell<TreeNode>>) -> Vec<Rc<RefCell<TreeNode>>> {
        let mut lefts = vec![node.clone()];
        while let Some(left) = node.clone().borrow().left.clone() {
            lefts.push(left.clone());
            node = left;
        }
        lefts
    }

    fn from_opt_root(root: Option<Rc<RefCell<TreeNode>>>) -> TreeIter {
        match root {
            Some(node) => TreeIter {
                levels: TreeIter::all_left(node),
            },
            None => TreeIter { levels: vec![] },
        }
    }
}

impl Iterator for TreeIter {
    type Item = Rc<RefCell<TreeNode>>;
    fn next(&mut self) -> Option<Self::Item> {
        if let Some(node) = self.levels.pop() {
            match node.borrow().right.clone() {
                Some(right) => self.levels.extend(TreeIter::all_left(right).into_iter()),
                None => {}
            }
            Some(node)
        } else {
            None
        }
    }
}

pub fn recover_tree(root: &mut Option<Rc<RefCell<TreeNode>>>) {
    let mut bad_one = None;
    let mut bad_two = None;

    let tree_iter = TreeIter::from_opt_root((*root).clone()).skip(1);
    let prev_tree_iter = TreeIter::from_opt_root((*root).clone());
    for (prev_node, node) in prev_tree_iter.zip(tree_iter) {
        if prev_node.borrow().val > node.borrow().val {
            if !bad_one.is_some() {
                bad_one = Some(prev_node.clone());
                bad_two = Some(node.clone());
            } else {
                bad_two = Some(node.clone());
                break;
            }
        }
    }

    std::mem::swap(
        &mut bad_one.expect("there must be a bad node").borrow_mut().val,
        &mut bad_two.expect("there must be a bad node").borrow_mut().val,
    );
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tree_iter() {
        let tree = Rc::new(RefCell::new(TreeNode::new(4)));

        tree.borrow_mut().left = Some(Rc::new(RefCell::new(TreeNode::new(2))));
        tree.borrow_mut().left.as_mut().unwrap().borrow_mut().left =
            Some(Rc::new(RefCell::new(TreeNode::new(1))));
        tree.borrow_mut().left.as_mut().unwrap().borrow_mut().right =
            Some(Rc::new(RefCell::new(TreeNode::new(3))));

        tree.borrow_mut().right = Some(Rc::new(RefCell::new(TreeNode::new(6))));
        tree.borrow_mut().right.as_mut().unwrap().borrow_mut().left =
            Some(Rc::new(RefCell::new(TreeNode::new(5))));
        tree.borrow_mut().right.as_mut().unwrap().borrow_mut().right =
            Some(Rc::new(RefCell::new(TreeNode::new(7))));

        let tree_iter = TreeIter::from_opt_root(Some(tree));
        let vals: Vec<_> = tree_iter.map(|node| node.borrow().val).collect();
        assert_eq!(vals, vec![1, 2, 3, 4, 5, 6, 7]);
    }

    #[test]
    fn test_tree_iter_empty() {
        let tree_iter = TreeIter::from_opt_root(None);
        let vals: Vec<_> = tree_iter.map(|node| node.borrow().val).collect();
        assert_eq!(vals, vec![]);
    }
}



impl Solution {
    pub fn recover_tree(root: &mut Option<Rc<RefCell<TreeNode>>>) {
        recover_tree(root)
    }
}