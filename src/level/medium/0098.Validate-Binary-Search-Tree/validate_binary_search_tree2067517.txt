// https://leetcode.com/problems/validate-binary-search-tree/solutions/2067517/rust-iterative-move-semantics/
use std::cell::RefCell;
use std::rc::Rc;
impl Solution {
    pub fn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {
        let mut stack = vec![];
        let mut curr = root;

        let mut prev = None;

        while curr.is_some() || !stack.is_empty() {
            while let Some(node_rc) = curr {
                let mut node_ref = node_rc.borrow_mut();
                let left = node_ref.left.take();
                drop(node_ref);
                stack.push(node_rc);
                curr = left;
            }

            let node_rc = stack.pop().unwrap();
            let mut node_ref = node_rc.borrow_mut();
            if let Some(p) = prev {
                if node_ref.val <= p {
                    return false;
                }
            }
            
            prev = Some(node_ref.val);

            curr = node_ref.right.take();
        }
        true
    }
}