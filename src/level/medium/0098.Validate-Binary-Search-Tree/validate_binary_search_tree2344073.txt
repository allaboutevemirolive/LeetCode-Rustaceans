// https://leetcode.com/problems/validate-binary-search-tree/solutions/2344073/rust-straightforward-dfs/
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {
        // dfs traveler
        fn checker(tree: Option<Rc<RefCell<TreeNode>>>, smaller: &mut Vec<i32>, larger: &mut Vec<i32>) -> bool {
            if let Some(node) = tree {
                let node = node.borrow();

                if smaller.iter().any(|v| v<=&node.val) ||
                    larger.iter().any(|v| v>=&node.val) {
                        return false
                    }
					
                (if let Some(rcnode) = node.left.as_ref() {
                    smaller.push(node.val);
                    let res = checker(Some(Rc::clone(rcnode)), smaller, larger);
                    smaller.pop();
                    res
                } else {
                    true
                }) && (if let Some(rcnode) = node.right.as_ref() {
                    larger.push(node.val);
                    let res = checker(Some(Rc::clone(rcnode)), smaller, larger);
                    larger.pop();
                    res
                } else {
                    true
                })
            } else {
                true
            }
        }
        checker(root, &mut vec![], &mut vec![])
    }
}
    