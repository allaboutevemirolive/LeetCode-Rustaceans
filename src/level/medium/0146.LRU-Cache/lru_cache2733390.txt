// https://leetcode.com/problems/lru-cache/solutions/2733390/rust-hashmap-linkedlist/
use std::{cell::RefCell, rc::Rc, collections::HashMap};
use std::fmt;

struct LRUCache {
    dll : DoublyLinkedList,
    map : HashMap<i32, Rc<RefCell<ListNode>>>,
    capacity : i32,
}

/** 
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl LRUCache {

    fn new(capacity: i32) -> Self {
        LRUCache {
            dll : DoublyLinkedList::new(),
            map : HashMap::new(),
            capacity,
        }
    }
    
    fn get(&mut self, key: i32) -> i32 {
        if let Some(node) = self.map.get(&key) {
            self.dll.move_front(Rc::clone(node));
            return node.borrow().val;
        }
        -1
    }
    
    fn put(&mut self, key: i32, value: i32) {
        if let Some(node) = self.map.get_mut(&key) {
            node.borrow_mut().val = value;
            self.dll.move_front(Rc::clone(node));
            return 
        }
        
        if self.capacity as usize == self.map.len() {
            let to_remove = self.dll.pop_back();
            self.map.remove(&to_remove);
        }
        
        let new_node = Rc::new(RefCell::new(ListNode::new(key, value)));
        
        self.map.insert(key, new_node.clone());
        self.dll.insert_front(new_node);
    }
}



pub struct DoublyLinkedList {
	pub d_head : Option<Rc<RefCell<ListNode>>>,
	pub d_tail : Option<Rc<RefCell<ListNode>>>
}

impl DoublyLinkedList {
	pub fn new() -> Self {
		let d_head = Rc::new(RefCell::new(ListNode::new(-1, -1)));
		let d_tail = Rc::new(RefCell::new(ListNode::new(-1, -1)));
		
		d_head.borrow_mut().next = Some(Rc::clone(&d_tail));
		d_tail.borrow_mut().prev = Some(Rc::clone(&d_head));

		Self {
			d_head : Some(d_head),
			d_tail : Some(d_tail)
		}
	}

	pub fn move_front(&mut self, node : Rc<RefCell<ListNode>>) {
		Self::remove(node.clone());
		self.insert_front(node);
	}

	pub fn insert_front(&mut self, first_node : Rc<RefCell<ListNode>>) {
		let mut second_node = Self::get_next(self.d_head.clone().unwrap());
		
		first_node.borrow_mut().next = Some(second_node.clone());
		second_node.borrow_mut().prev = Some(first_node.clone());

		self.d_head.clone().unwrap().borrow_mut().next = Some(first_node.clone());
		first_node.borrow_mut().prev = self.d_head.clone();
		
	}

	pub fn pop_back(&self) -> i32 {
		Self::remove(Self::get_prev(self.d_tail.clone().unwrap()))
	}

	pub fn remove(node : Rc<RefCell<ListNode>>) -> i32 {
		let mut nxt_node = Self::get_next(node.clone());
		let mut prev_node = Self::get_prev(node.clone());
		nxt_node.borrow_mut().prev = Some(prev_node.clone());
		prev_node.borrow_mut().next = Some(nxt_node);
        node.borrow().key
	}

	fn get_next(node: Rc<RefCell<ListNode>>) -> Rc<RefCell<ListNode>> {
		node.borrow_mut().next.clone().unwrap()
	}
    
	fn get_prev(node: Rc<RefCell<ListNode>>) -> Rc<RefCell<ListNode>> {
		node.borrow_mut().prev.clone().unwrap()
	}
}

impl fmt::Debug for DoublyLinkedList {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		let mut values = vec![];
		let mut p = self.d_head.clone();
		while let Some(node) = p {
			values.push(node.borrow().val);
			p = node.borrow().next.clone();
		}
        write!(f, "{:?}", values)
    }
}

pub struct ListNode {
    pub key : i32,
	pub val : i32,
	pub prev : Option<Rc<RefCell<ListNode>>>,
	pub next : Option<Rc<RefCell<ListNode>>>
}

impl ListNode {
	pub fn new(key : i32, val : i32) -> Self {
		ListNode {
            key,
			val,
			prev : None,
			next : None
		}
	}
}
