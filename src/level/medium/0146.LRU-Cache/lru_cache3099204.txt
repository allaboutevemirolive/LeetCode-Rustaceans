// https://leetcode.com/problems/lru-cache/solutions/3099204/rust-easy/
use std::collections::HashMap;

struct LRUCache {
    hmap: HashMap<i32, Value>,
    head: Option<i32>,
    tail: Option<i32>,
    capacity: usize,
}

struct Value {
    value: i32,
    prev: Option<i32>,
    next: Option<i32>,
}

/** 
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl LRUCache {

    fn new(capacity: i32) -> Self {
        return LRUCache {
            hmap: HashMap::new(),
            head: None,
            tail: None,
            capacity: capacity as usize
        };
    }
    
    fn remove(&mut self, key: i32) {
        let value = self.hmap.remove(&key);
        if value.is_none() {
            return
        }
        let value = value.unwrap();
        if let Some(prev_key) = value.prev {
            self.hmap.get_mut(&prev_key).unwrap().next = value.next;
        }
        if let Some(next_key) = value.next {
            self.hmap.get_mut(&next_key).unwrap().prev = value.prev;
        }
        if self.head == Some(key) {
            self.head = value.next;
        }
        if self.tail == Some(key) {
            self.tail = value.prev;
        }
    }

    fn insert_to_head(&mut self, key: i32, value: i32) {
        let mut key_prev: Option<i32> = None;
        let mut key_next: Option<i32> = None;
        if self.head == None {
            self.head = Some(key);
            self.tail = Some(key);
            key_prev = None;
            key_next = None;
        } else {
            let head_key = self.head.unwrap();
            key_prev = None;
            key_next = self.head;
            self.head = Some(key);
            self.hmap.get_mut(&head_key).unwrap().prev = Some(key);
        }
        self.hmap.insert(key, Value {
            value,
            prev: key_prev,
            next: key_next,
        });
    }

    fn get(&mut self, key: i32) -> i32 {
        if let Some(v) = self.hmap.get(&key) {
            let ans = v.value;
            // remove key
            self.remove(key);
            // insert the key into the front
            self.insert_to_head(key, ans);
            return ans;
        } else {
            return -1;
        }
    }

    fn put(&mut self, key: i32, value: i32) {
        self.remove(key);
        // insert the key into the front
        self.insert_to_head(key, value);
        // extract the last one on the list
        if self.hmap.len() > self.capacity {
            let tail_key = self.tail.unwrap();
            // println!("Remove key {:?}", tail_key);
            let before_tail = self.hmap.get_mut(&tail_key).unwrap().prev;
            self.tail = before_tail;
            if let Some(before_tail_key) = before_tail {
                self.hmap.get_mut(&before_tail_key).unwrap().next = None;
            }
            self.hmap.remove(&tail_key);
        }
        // println!("self.hmap.len() = {:?}", self.hmap.len());
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * let obj = LRUCache::new(capacity);
 * let ret_1: i32 = obj.get(key);
 * obj.put(key, value);
 */