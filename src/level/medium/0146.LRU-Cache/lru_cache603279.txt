// https://leetcode.com/problems/lru-cache/solutions/603279/rust-24ms/
use std::collections::VecDeque;
use std::collections::HashMap;

struct LRUCache {
    log  : VecDeque<i32>,
    key_log_freq : HashMap<i32, i32>,
    cache : HashMap<i32, i32>,
    capacity : usize
}


/** 
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl LRUCache {

    fn new(capacity: i32) -> Self {
        LRUCache { 
            log: VecDeque::new(),
            key_log_freq: HashMap::new(),
            cache: HashMap::new(), 
            capacity: capacity as usize
        }
    }

    fn remove_unused(&mut self) {
        while self.key_log_freq.get(&self.log.front().unwrap()).unwrap() != &1 {
            if let Some(k) = self.log.pop_front() {
                *self.key_log_freq.entry(k).or_insert(0) -= 1;
            }
        }

        if let Some(k) = self.log.pop_front() {
            self.key_log_freq.remove(&k);
            self.cache.remove(&k);
        }        
    }
    
    fn put(&mut self, key: i32, value: i32) {
        if self.cache.len() == self.capacity && self.cache.get(&key) == None {
            self.remove_unused();
        }            

        self.log.push_back(key);
        *self.key_log_freq.entry(key).or_insert(0) += 1;
        self.cache.insert(key, value);
    }
    
    fn get(&mut self, key: i32) -> i32 {
        match self.cache.get(&key) {
            Some(value) => {
                self.log.push_back(key);
                *self.key_log_freq.entry(key).or_insert(0) += 1;        
                *value                
            },
            None => -1
        }
    }
    
}