// https://leetcode.com/problems/lru-cache/solutions/1007048/rust-hashmap-and-ring-buffer-solution/
use std::collections::{VecDeque, HashMap};

struct LRUCache {
    q: VecDeque<i32>,
    m: HashMap<i32, i32>,
    c: usize,
}

/** 
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl LRUCache {

    fn new(capacity: i32) -> Self {
        Self {
            q: VecDeque::with_capacity(capacity as usize),
            m: HashMap::new(),
            c: capacity as usize,
        }
    }
    
    fn get(&mut self, key: i32) -> i32 {
        match self.m.get(&key) {
            Some(v) => {
                self.q.remove(self.q.iter().position(|&x| x == key).unwrap());
                self.q.push_front(key);
                *v
            },
            None => -1
        }
    }
    
    fn put(&mut self, key: i32, value: i32) {
        match self.m.get(&key) {
            Some(_) => {
                self.q.remove(self.q.iter().position(|&x| x == key).unwrap());
                self.q.push_front(key);
                self.m.insert(key, value);
            },
            None => {
                if self.m.len() == self.c {
                    self.m.remove(&self.q.pop_back().unwrap());
                }
                self.m.insert(key, value);
                self.q.push_front(key);
            }
        }
    }
}