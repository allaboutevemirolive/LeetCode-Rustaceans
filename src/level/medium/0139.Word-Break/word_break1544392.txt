// https://leetcode.com/problems/word-break/solutions/1544392/rust-0ms/
use std::collections::HashSet;
use std::cmp::min;
use std::cmp::max;

fn _word_break(s: &[char], dict: &HashSet<Vec<char>>, min_len: usize, max_len: usize, memo: &mut HashSet<usize>, level: u8) -> bool {
    if s.len() == 0 {
        return true;
    }
    if memo.contains(&s.len()) {
        return false;
    } 
    if s.len() < min_len {
        return false;
    }
    let mut v: Vec<char> = Vec::with_capacity(max_len);
    v.extend(s[..min_len].into_iter());
    
    for i in min_len..min(s.len(), max_len) {
        if dict.contains(&v) {
            if _word_break(&s[v.len()..], dict, min_len, max_len, memo, level + 1) {
                return true;
            }
        }
        
        v.push(s[i]);
    }
    if dict.contains(&v) {
        if _word_break(&s[v.len()..], dict, min_len, max_len, memo, level + 1) {
            return true;
        }
    }
    memo.insert(s.len());
    false
}

impl Solution {
    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {
        let mut min_len: usize = usize::MAX;
        let mut max_len: usize = usize::MIN;
        let mut dict: HashSet<Vec<char>> = HashSet::with_capacity(word_dict.len());
        for word in word_dict {
            min_len = min(min_len, word.len());
            max_len = max(max_len, word.len());
            let mut v: Vec<char> = word.chars().collect();
            dict.insert(v);
        }
        println!("min_len: {:?} max_len: {:?}", min_len, max_len);
        
        let mut memo: HashSet<usize> = HashSet::new();
        let s_chars: Vec<char> = s.chars().collect();
        _word_break(&s_chars, &dict, min_len, max_len, &mut memo, 0)
    }
}