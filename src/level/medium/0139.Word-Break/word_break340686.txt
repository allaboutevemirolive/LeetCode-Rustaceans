// https://leetcode.com/problems/word-break/solutions/340686/rust-solution/
use std::collections::HashSet;
use std::collections::HashMap;

impl Solution {
    
    fn word_break_impl(s: String, word_set: &HashSet<String>, mem: &mut HashMap<String, bool>) -> bool {
        if mem.contains_key(&s) {
            return mem[&s];
        }
        
        if word_set.contains(&s) {
            mem.insert(s, true);
            return true;
        }
        
        for i in 1..s.len() {
            let left = &s[0..i];
            let right = &s[i..];
            if word_set.contains(right) {
                if Self::word_break_impl(left.to_string(), word_set, mem) {
                    mem.insert(s, true);
                    return true;
                }
            }
        }
        mem.insert(s, false);
        false
    }
    
    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {
        let word_set: HashSet<String> = word_dict.iter().cloned().collect();
        let mut mem = HashMap::new();
        Self::word_break_impl(s, &word_set, &mut mem)
    }
}