// https://leetcode.com/problems/word-break/solutions/3296468/rust-3-approaches/
impl Solution {
    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {
        fn brute_memo(s: String, word_dict: Vec<String>) -> bool {
            use std::collections::HashSet;
            fn rec(
                s: &[char],
                start: usize,
                word_dict: &HashSet<String>,
                memo: &mut [Option<bool>],
            ) -> bool {
                if start == s.len() {
                    return true;
                }

                if memo[start].is_some() {
                    return memo[start].unwrap();
                }
                for end in start + 1..=s.len() {
                    if word_dict.contains(&s[start..end].iter().copied().collect::<String>())
                        && rec(s, end, word_dict, memo)
                    {
                        memo[start] = Some(true);
                        return memo[start].unwrap();
                    }
                }
                memo[start] = Some(false);
                memo[start].unwrap()
            }

            let s = s.chars().collect::<Vec<_>>();
            let mut memo = vec![None; s.len()];
            let word_dict = word_dict.into_iter().collect::<HashSet<String>>();
            rec(&s, 0, &word_dict, &mut memo)
        }

        fn bfs(s: String, word_dict: Vec<String>) -> bool {
            use std::collections::{HashSet, VecDeque};
            let s = s.chars().collect::<Vec<_>>();
            let word_dict = word_dict.into_iter().collect::<HashSet<String>>();
            let mut visited = vec![false; s.len()];
            let mut queue = VecDeque::new();
            queue.push_back(0);
            while let Some(start) = queue.pop_front() {
                if visited[start] {
                    continue;
                }
                visited[start] = true;
                for end in start + 1..=s.len() {
                    if word_dict.contains(&s[start..end].iter().copied().collect::<String>()) {
                        queue.push_back(end);
                        if end == s.len() {
                            return true;
                        }
                    }
                }
            }
            false
        }

        fn dp(s: String, word_dict: Vec<String>) -> bool {
            use std::collections::HashSet;
            let s = s.chars().collect::<Vec<_>>();
            let word_dict = word_dict.into_iter().collect::<HashSet<String>>();
            let mut dp = vec![false; s.len() + 1];
            dp[0] = true;
            for start in 0..s.len() {
                for end in start + 1..=s.len() {
                    if word_dict.contains(&s[start..end].iter().copied().collect::<String>())
                        && dp[start]
                    {
                        dp[end] = true;
                    }
                }
            }
            dp[s.len()]
        }

        dp(s, word_dict)
    }
}