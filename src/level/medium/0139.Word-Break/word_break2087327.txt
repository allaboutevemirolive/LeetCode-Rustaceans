// https://leetcode.com/problems/word-break/solutions/2087327/rust-recursion-with-memoization/
use std::collections::HashSet;

pub fn word_break<S: AsRef<str>>(s: S, word_dict: Vec<String>) -> bool {
    let words = word_dict.into_iter().collect::<HashSet<_>>();
    let mut cache = vec![false; s.as_ref().len() + 1];
    recurse(s.as_ref(), 0, &words, &mut cache)
}

fn recurse(s: &str, from: usize, words: &HashSet<String>, cache: &mut Vec<bool>) -> bool {
    if s[from..].is_empty() {
        return true;
    }

    for to in from..s.len() + 1 {
        if cache[to] {
            continue;
        }

        if words.contains(&s[from..to]) {
            cache[to] = true;

            if recurse(s, to, words, cache) {
                return true;
            }
        }
    }

    false
}