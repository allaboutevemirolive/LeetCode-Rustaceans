// https://leetcode.com/problems/string-compression/solutions/3246834/rust-solution/
impl Solution {
    pub fn compress(chars: &mut Vec<char>) -> i32 {
        fn correct(chars: &mut [char], count: i32, pos: usize, prev_c: char) -> usize {
            let l = match count <= 1 {
                true => 1,
                false => 2 + (count as f32).log10() as usize,
            };
            chars[pos] = prev_c;
            if count > 1 {
                chars[pos + 1..]
                    .iter_mut()
                    .zip(count.to_string().chars())
                    .for_each(|(c, d)| *c = d);
            }
            l
        }

        let mut count = 1;
        let mut pos = 0;
        let mut prev_c = ' ';

        for i in 0..chars.len() {
            let c = chars[i];
            match prev_c == c {
                true => count += 1,
                false if prev_c != ' ' => {
                    pos += correct(chars, count, pos, prev_c);
                    count = 1;
                }
                _ => (),
            };
            prev_c = c;
        }
        pos += correct(chars, count, pos, prev_c);
        pos as _
    }
}