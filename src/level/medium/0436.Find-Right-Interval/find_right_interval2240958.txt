// https://leetcode.com/problems/find-right-interval/solutions/2240958/rust-solution-using-binary-search/
type Target = i32;
type UseValue = i32;
fn lower_bound(arr: &Vec<(i32, i32, usize)>, x: &UseValue) -> usize {
    let mut low = 0;
    let mut high = arr.len();
    while low != high {
        let mid = (low + high) / 2;
        match arr[mid].0.cmp(x) {
            std::cmp::Ordering::Less => {
                low = mid + 1;
            }
            std::cmp::Ordering::Equal | std::cmp::Ordering::Greater => {
                high = mid;
            }
        }
    }
    low
}

impl Solution {
    pub fn find_right_interval(intervals: Vec<Vec<i32>>) -> Vec<i32> {
        let n = intervals.len();
        let mut arr = intervals.into_iter().enumerate().map(|v| (v.1[0], v.1[1], v.0)).collect::<Vec<(i32, i32, usize)>>();
        arr.sort();

        let mut result = vec![0;n];
        for i in 0..n {
            let (_, end, index) = arr[i];
            let ti = lower_bound(&arr, &end);

            if ti == n {
                result[index] = -1;
            } else {
                result[index] = arr[ti].2 as i32;
            }
        }
        result
    }
}