// https://leetcode.com/problems/partition-equal-subset-sum/solutions/2549559/rust-backtracking-simpler-version-of-lc-698/
pub fn can_partition(mut nums: Vec<i32>) -> bool {
    let total = nums.iter().copied().sum::<i32>();

    // Fast path: either there are no elements in the vector or
    // their sum is not divisible by 2, thus it cannot be divided 
    // evenly
    if total == 0 || total % 2 != 0 {
        return false;
    }

    nums.sort_unstable_by_key(|&x| -x);
    backtrack(&nums, total / 2, 0)
}

fn backtrack(nums: &[i32], rem: i32, from: usize) -> bool {
    // We've made a subset with the target sum
    if rem == 0 {
        return true;
    }

    for idx in from..nums.len() {
        // The current number is larger than the remaining sum,
        // thus it cannot be part of this subset
        if nums[idx] > rem {
            continue;
        }

        // Check if we have already tried that number (because the array is sorted)
        // And if the previous try did not work, then this one will not work as well
        if idx > from && nums[idx - 1] == nums[idx] {
            return false;
        }

        // Check if the next number is part of this subset
        if backtrack(nums, rem - nums[idx], idx + 1) {
            return true;
        }
    }

    false
}