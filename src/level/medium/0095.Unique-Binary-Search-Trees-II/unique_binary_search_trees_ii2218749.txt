// https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/2218749/rust-recursive-with-comments/
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    fn recurse_trees(lo: i32, hi: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {
        // Base case - no elements to iterate over - return a single None that
        // can terminate the parent node.
        if lo > hi {
            return vec![None];
        }

        let mut rez = vec![];

        // Iterate over roots for this subtree
        for i in lo..=hi {
            // Recurse over left child subtrees
            let lefts = Self::recurse_trees(lo, i-1);
            // Recurse over right child subtrees
            let rights = Self::recurse_trees(i+1, hi);
            // Iterate over all combinations of left and right child subtrees
            for left in lefts {
                for right in &rights {
                    // Don't make life complicated - generate the
                    // "raw" root node first and populate it, and
                    // then we can package it as an Option<Rc<RefCell<_>>>
                    let mut root = TreeNode::new(i);
                    root.left = left.clone();
                    root.right = right.clone();
                    rez.push(Some(Rc::new(RefCell::new(root))));
                }
            }
        }

        rez
    }

    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {
        Self::recurse_trees(1, n)
    }
}