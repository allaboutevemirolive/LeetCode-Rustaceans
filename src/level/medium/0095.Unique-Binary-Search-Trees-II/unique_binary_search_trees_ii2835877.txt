// https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/2835877/rust-2-recursive-solutions/
use std::rc::Rc;
use std::cell::RefCell;
use std::cmp::Ordering;
impl Solution {
    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {        
        fn helper(min: i32, max: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {  
            match min.cmp(&max) {
                Ordering::Equal => {
                    vec![
                        Some(Rc::new(RefCell::new(
                            TreeNode{
                                val: min,
                                left: None,
                                right: None,
                            }
                        )))
                    ]
                },
                Ordering::Greater => {
                    vec![None]
                },
                Ordering::Less => {
                    (min..=max).flat_map(|val| {
                        helper(min, val-1).iter().flat_map(|left| {
                            helper(val+1, max).iter().map(|right| {
                                Some(Rc::new(RefCell::new(
                                    TreeNode{
                                        val: val,
                                        left: left.clone(),
                                        right: right.clone(),
                                    }
                                )))
                            }).collect::<Vec<_>>()
                        }).collect::<Vec<_>>()
                    }).collect()
                }
            }
        }
        
        helper(1, n)
    }
}