// https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/476742/rust-recursion/
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn generate_trees(n: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {
        if n == 0 {
            vec![]
        } else {
             Self::generate_trees_impl(1, n)
        }  
    }

pub fn generate_trees_impl(l: i32, r: i32) -> Vec<Option<Rc<RefCell<TreeNode>>>> {
    if l > r {
        vec![None]
    } else {
        let mut res = vec![];
        for i in l..r+1 {
            let lnodes =Self::generate_trees_impl(l, i-1);
            let rnodes = Self::generate_trees_impl(i+1, r);
            for ln in lnodes.iter() {
                for rn in rnodes.iter() {
                    let node = Some(Rc::new(RefCell::new(TreeNode{
                        val: i,
                        left: ln.clone(),
                        right:rn.clone(),
                    }))); 
                    // node.unwrap().clone().borrow_mut().left = ln.clone();
                    // node.unwrap().borrow_mut().right = rn.clone();
                    res.push(node);
                }
            }
        }
        res
    }
}
}