// https://leetcode.com/problems/minimum-size-subarray-sum/solutions/754979/rust-cheapest-best/
use std::i32::MAX;

impl Solution {
    pub fn min_sub_array_len(s: i32, nums: Vec<i32>) -> i32 {
        match nums.len() {
            0 => 0,
            _ => {
                let (mut t, mut m, mut i, mut j) = (0, MAX, 0, 0);
                while j < nums.len() + 1 {
                    if t < s {
                        t += nums.get(j).unwrap_or(&0);
                        j += 1;
                    } else {
                        m = ((j - i) as i32).min(m);
                        t -= nums[i];
                        i += 1;
                    }
                }
                if m == MAX { 0 } else { m }
            }
        }
    }
}