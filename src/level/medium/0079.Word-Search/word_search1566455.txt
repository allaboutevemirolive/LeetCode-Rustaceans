// https://leetcode.com/problems/word-search/solutions/1566455/rust/
impl Solution {
    pub fn exist(board: Vec<Vec<char>>, word: String) -> bool {
        let word_chars = word.as_bytes().to_vec(); 
        let word_chars_remaining = word_chars.len();
        for y in 0..board.len() {
            for x in 0..board[0].len() {
                let mut currentBoard = board.clone();
                if Self::quick_exist(&mut currentBoard, (x,y), &word_chars, word_chars_remaining) {
                    return true; 
                }
            }
        }
        
        false
    }
    
    fn quick_exist(board: &mut Vec<Vec<char>>, pos: (usize, usize), word_chars: &Vec<u8>, word_chars_remaining: usize) -> bool     { 
        let mut current_board = board; 
        if word_chars_remaining == 0 { return true; }
        if pos.0 < 0 || pos.0 > (current_board[0].len()-1) || pos.1 < 0 || pos.1 > (current_board.len() - 1) { return false; }
        if current_board[pos.1][pos.0] == '#' { return false; }
        
        let word_chars_last_index = word_chars.len();
        let target = word_chars[word_chars_last_index - word_chars_remaining] as char;
        let curr = current_board[pos.1][pos.0]; 
        
        if target != curr { return false; }
        else {
            current_board[pos.1][pos.0] = '#';
            let remaining = word_chars_remaining - 1;
            if Self::quick_exist(&mut current_board, (pos.0 + 1, pos.1), word_chars, remaining) { return true; }
            if Self::quick_exist(&mut current_board, (pos.0 - 1, pos.1), word_chars, remaining) { return true; }
            if Self::quick_exist(&mut current_board, (pos.0, pos.1 - 1), word_chars, remaining) { return true; }
            if Self::quick_exist(&mut current_board, (pos.0, pos.1 + 1), word_chars, remaining) { return true; }
            current_board[pos.1][pos.0] = curr; 
            return false; 
        }
    }
}