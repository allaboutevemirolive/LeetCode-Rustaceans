// https://leetcode.com/problems/decode-ways/solutions/1080070/rust-solution-using-memoization/
use std::str;
use std::collections::HashMap;

impl Solution {
    pub fn num_decodings(s: String) -> i32 {
        let mut memo = HashMap::new();
        Self::num_decodings_helper(&s, 0, &mut memo)
    }
        
    pub fn num_decodings_helper(s: &String, index: usize, memo: &mut HashMap<usize, i32>) -> i32 {
        if (index == s.len() || 
            index == s.len() - 1 && s.as_bytes()[index] as char != '0') {
            return 1;
        }
        
        if s.as_bytes()[index] as char == '0' {
            return 0;
        }
        
        if memo.contains_key(&index) {
            return *memo.get(&index).unwrap();
        }
        
        let mut result = Self::num_decodings_helper(s, index + 1, memo);
        let next_two = s.chars().skip(index).take(2).collect::<String>();
        let number = next_two.parse::<i32>().unwrap();

        if number <= 26 {
            result += Self::num_decodings_helper(s, index + 2, memo);
        }
        
        memo.insert(index, result);
        result
    }
}