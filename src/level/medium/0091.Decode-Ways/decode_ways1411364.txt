// https://leetcode.com/problems/decode-ways/solutions/1411364/rust-bottom-up-dp-with-explanation/
impl Solution {
    pub fn num_decodings(s: String) -> i32 {        
        // dp: f(i) => start from i, num of decodings.
        // for every char at i, it can choose to be itself or group with the next
        // f(i) = f(i + 1) ( when s[i] is possible to construct a num ) 
        //      + f(i + 2) ( when s[i], s[i + 1] is possible to construct a num )
        let s = s.into_bytes();
        let n = s.len();
        let mut dp = vec![0; n];
        for i in (0..n).rev() {
            if s[i] == b'0' { continue; }
            if i + 1 == n {
                dp[i] = 1;
                continue;
            }
            let mut v = dp[i + 1];
            if s[i] == b'1' || (s[i] == b'2' && s[i + 1] <= b'6') { 
                if i + 2 < n { v += dp[i + 2]; }
                else { v += 1; }
            }
            dp[i] = v;
        }
        dp[0]
    }
}