// https://leetcode.com/problems/binary-tree-level-order-traversal/solutions/1743034/rust-0ms-2-1-mb/
use std::rc::Rc;
use std::cell::RefCell;
use std::collections::VecDeque;
type Node = Option<Rc<RefCell<TreeNode>>>;

impl Solution {
    pub fn level_order(root: Node) -> Vec<Vec<i32>> {
        let mut q = VecDeque::new();
        let mut res = Vec::new();
        q.push_back((0, root));
        
        while let Some((lvl, node)) = q.pop_front() { 
            if let Some(rc) = node { 
                let TreeNode { val, left, right } = 
                Rc::try_unwrap(rc).unwrap().into_inner();
                if lvl >= res.len() { 
                    res.resize(lvl + 1, vec![])
                }
                res[lvl].push(val);
                q.push_back((lvl + 1, left));
                q.push_back((lvl + 1, right));
            }
        }
        res
    }
}

