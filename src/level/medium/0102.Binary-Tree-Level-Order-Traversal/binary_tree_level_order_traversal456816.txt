// https://leetcode.com/problems/binary-tree-level-order-traversal/solutions/456816/rust-solution-100-00/
impl Solution {
    pub fn level_order(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {
        let mut levels = Vec::new();
        Solution::dfs(&mut levels, &root, 0);
        return levels;
    }

    fn dfs(levels: &mut Vec<Vec<i32>>, root: &Option<Rc<RefCell<TreeNode>>>, depth: usize) {
        if let Some(root) = root {
            if levels.len() == depth {
                levels.push(Vec::new());
            }
            levels[depth].push(root.borrow().val);
            Solution::dfs(levels, &root.borrow().left, depth + 1);
            Solution::dfs(levels, &root.borrow().right, depth + 1);
        }
    }
}