// https://leetcode.com/problems/house-robber-ii/solutions/2344523/rust-dynamic-programming-0ms-2-2mb/
use std::cmp::max;
use std::collections::HashMap;

impl Solution {
    pub fn dp_rob(
        nums: &Vec<i32>, 
        index: usize, 
        memo: &mut HashMap<(usize, bool), i32>,
        first_house_robbed: bool,
    ) -> i32 {
        if index >= nums.len() {
            return 0;
        } else if index == nums.len() - 1 && first_house_robbed {
            return 0;
        } 
        
        if let Some(value) = memo.get(&(index, first_house_robbed)) {
            return *value;
        }
        
        let mut result: i32 = 0;
        if index == 0 {
            result = max(
                // Rob the first house
                nums[index] + Self::dp_rob(nums, index + 2, memo, true),
                // Do not rob the first house
                Self::dp_rob(nums, index + 1, memo, false),
            );
        } else {
            result = max(
                // Rob the current house
                nums[index] + Self::dp_rob(nums, index + 2, memo, first_house_robbed),
                // Do not rob the current house
                Self::dp_rob(nums, index + 1, memo, first_house_robbed),
            );
        }
        memo.insert((index, first_house_robbed), result);
        result
    }
    
    pub fn rob(nums: Vec<i32>) -> i32 {
        let mut memo: HashMap<(usize, bool), i32> = HashMap::new();
        Self::dp_rob(&nums, 0 as usize, &mut memo, false)
    }
}