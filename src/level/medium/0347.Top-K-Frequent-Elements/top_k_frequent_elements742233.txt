// https://leetcode.com/problems/top-k-frequent-elements/solutions/742233/rust-quick-select-solution/
use std::cmp::Ordering;
use std::collections::HashMap;

impl Solution {
    fn partition(slice: &mut [(i32, usize)], left: usize, right: usize) -> usize {
        let pivot = left + (right - left) / 2;
        slice.swap(pivot, right);

        let mut i = left;
        for j in left..right {
            if slice[j].1 > slice[right].1 {
                slice.swap(i, j);
                i += 1;
            }
        }

        slice.swap(i, right);
        i
    }

    fn quick_select(slice: &mut [(i32, usize)], mut left: usize, mut right: usize, k: usize) {
        while left < right {
            let mid = Self::partition(slice, left, right);

            match k.cmp(&mid) {
                Ordering::Greater => left = mid + 1,
                Ordering::Equal => break,
                Ordering::Less => right = mid - 1,
            }
        }
    }

    pub fn top_k_frequent(nums: Vec<i32>, k: i32) -> Vec<i32> {
        let k = k as usize;

        let freq = nums.into_iter().fold(HashMap::new(), |mut hm, n| {
            *hm.entry(n).or_insert(0) += 1;
            hm
        });

        let mut freq: Vec<(i32, usize)> = freq.into_iter().collect();
        let len = freq.len();

        Self::quick_select(&mut freq, 0, len - 1, k);
        freq.into_iter().map(|p| p.0).take(k as usize).collect()
    }
}