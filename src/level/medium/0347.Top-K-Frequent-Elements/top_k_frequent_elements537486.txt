// https://leetcode.com/problems/top-k-frequent-elements/solutions/537486/rust-solution-0-ms/
use std::collections::{HashMap, BinaryHeap};
use std::cmp::Ordering;

#[derive(Eq)]
struct HeapNode {
    key: i32,
    value: i32,
}

impl Ord for HeapNode {
    fn cmp(&self, other: &Self) -> Ordering {
        self.value.cmp(&other.value)
    }
}

impl PartialOrd for HeapNode {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq for HeapNode {
    fn eq(&self, other: &Self) -> bool {
        self.value == other.value
    }
}

impl Solution {
    pub fn top_k_frequent(nums: Vec<i32>, k: i32) -> Vec<i32> {
        let mut map: HashMap<i32, i32> = HashMap::new();
        for num in nums {
            let times = map.entry(num).or_insert(0);
            *times += 1;
        }
        
        let mut heap: BinaryHeap<HeapNode> = BinaryHeap::new();
        for (key, value) in map {
            heap.push(
                HeapNode{
                    key,
                    value,
                }
            );
        }
        
        // it says that k is always valid, so I can unwrap here
        let mut vec = vec![];
        for _i in 0..k {
            vec.push(heap.pop().unwrap().key);
        }
        
        vec
    }
}