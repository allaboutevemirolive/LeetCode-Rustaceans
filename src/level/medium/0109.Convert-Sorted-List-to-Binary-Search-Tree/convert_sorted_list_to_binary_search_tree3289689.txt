// https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3289689/rust-o-n-time-o-1-space-day-stout-warren-algorithm/

use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn sorted_list_to_bst(mut head: Option<Box<ListNode>>) -> Option<Rc<RefCell<TreeNode>>> {
        let mut dummy = Rc::new(RefCell::new(TreeNode::new(-1)));
        let mut curr = dummy.clone();
        let mut count = 0;

        // Step 1: Convert linked list to "vine" (a tree with only right links)
        while let Some(mut node) = head {
            head = node.next.take();
            let new_tree_node = Rc::new(RefCell::new(TreeNode::new(node.val)));
            curr.borrow_mut().right = Some(new_tree_node.clone());
            curr = new_tree_node;
            count += 1;
        }

        // Step 2: Reduce the number of nodes in the "vine" to 1.
        // Each rotation reduces the number of nodes in the vine by 1, except for the last rotation which always reduces by 2 (except for possibly in the first iteration). 
        // Example count:
        // 28 -> 15 -> 7 -> 3 -> 1 
        while count > 1 {
            curr = dummy.clone();
            // check if count is all 1s in binary
            while ((count + 1) & count) != 0 {
                curr = rotate(curr.clone());
                count -= 1;
            }
            count -= 1;
        }
        let ans = dummy.borrow_mut().right.take();
        ans
    }
}

// Given 
//       curr
//      /   \
//     B     C 
//          /  \
//         E    D
//             /  \
//            F    ...
//
// roate the tree to: 
//       curr
//      /   \
//     B     D 
//          /  \
//         C    ...
//        / \     
//       E    F  
// and return node D
fn rotate(curr: Rc<RefCell<TreeNode>>) -> Rc<RefCell<TreeNode>> {
    let c = curr.borrow_mut().right.take().unwrap();
    let d = c.borrow_mut().right.take().unwrap();
    c.borrow_mut().right = d.borrow_mut().left.take();
    d.borrow_mut().left = Some(c);
    curr.borrow_mut().right = Some(d.clone());
    d
}