// https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3285534/rust-two-pointers-iterative/
use std::rc::Rc;
use std::cell::RefCell;

type ListOpt<'a> = Option<&'a Box<ListNode>>;
type TreeOpt = Option<Rc<RefCell<TreeNode>>>;

enum Phase<'a> { Call(ListOpt<'a>, ListOpt<'a>), Return(i32, bool, bool) }

impl Solution {
    pub fn sorted_list_to_bst(head: Option<Box<ListNode>>) -> TreeOpt {
        use Phase::*;
        
        head.as_ref()?;

        let mut stack = vec![Call(head.as_ref(), None)];
        let mut rets  = vec![];

        while let Some(phase) = stack.pop() {
            match phase {
                Call(head, last) => {
                    let mut slow = head;
                    let mut fast = head.and_then(|node| node.next.as_ref());

                    while fast != last {
                        slow = slow.and_then(|node| node.next.as_ref());
                        fast = fast.and_then(|node| node.next.as_ref());
                        if fast != last {
                            fast = fast.and_then(|node| node.next.as_ref());
                        }
                    }
                    let slow_next = slow.and_then(|node| node.next.as_ref());
                    let val       = slow.unwrap().val;
                    let has_left  = head != slow;
                    let has_right = slow_next != fast;

                    stack.push(Return(val, has_left, has_right));

                    if has_left {
                        stack.push(Call(head, slow));
                    }

                    if has_right {
                        stack.push(Call(slow_next, last));
                    }
                },
                Return(val, has_left, has_right) => {
                    let root = treenode(val);
                    if has_left {
                        root.borrow_mut().left = rets.pop().unwrap();
                    }
                    if has_right {
                        root.borrow_mut().right = rets.pop().unwrap();
                    }
                    rets.push(Some(root));
                }
            }
        }
        rets.pop().unwrap()
    }
}

fn treenode(val: i32) -> Rc<RefCell<TreeNode>> {
    Rc::new(RefCell::new(TreeNode::new(val)))
}