// https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/2144209/rust-pre-order-in-order-solutions-clean-code-easy-to-understand-with-comments/
// Calculate the list length only once at the beginning. If we pass 
// it as a parameter,then we can avoid iteration over the list again 
// and again for re-calculating it for the sub-trees
pub fn sorted_list_to_bst(head: Option<Box<ListNode>>) -> Option<Rc<RefCell<TreeNode>>> {
    let length = list_length(head.as_ref());
    sorted_list_with_len_to_bst(head, length)
}

fn sorted_list_with_len_to_bst(
    head: Option<Box<ListNode>>,
    length: usize,
) -> Option<Rc<RefCell<TreeNode>>> {
    if length == 0 {
        return None;
    }

    let (left, mid, right) = split_list(head, length);
    Some(Rc::new(RefCell::new(TreeNode {
        val: mid.val,
        left: sorted_list_with_len_to_bst(left, length / 2),
        right: sorted_list_with_len_to_bst(right, (length - 1) / 2),
    })))
}

fn list_length(head: Option<&Box<ListNode>>) -> usize {
    let mut node = head;
    let mut length = 0;

    while let Some(n) = node {
        node = n.next.as_ref();
        length += 1;
    }

    length
}

fn split_list(
    list: Option<Box<ListNode>>,
    length: usize,
) -> (Option<Box<ListNode>>, Box<ListNode>, Option<Box<ListNode>>) {
    // This function can be called only if there is at least one element in the list
    assert!(length > 0);

    let mut head = list;

    let mut left = None;
    let mut tail = &mut left;

    for _ in 0..length / 2 {
        let mut node = head.take().unwrap();
        head = node.next.take();

        tail = &mut tail.insert(node).next;
    }

    let mut mid = head.take().unwrap();
    let right = mid.next.take();

    (left, mid, right)
}