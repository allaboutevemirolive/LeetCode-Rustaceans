// https://leetcode.com/problems/coin-change/solutions/1051982/rust-top-down-dp/
use std::collections::HashMap;

impl Solution {
    pub fn coin_change(coins: Vec<i32>, amount: i32) -> i32 {
        // given f(s) = k, represents to sum up to s, min coin nums is k

        // let's try top-down DP
        // memoization: HashMap<s, k>
        let mut cache = HashMap::new();
        Self::dfs(&coins, amount, &mut cache)
            .map(|a| a as i32)
            .unwrap_or(-1)
    }

    fn dfs(
        coins: &[i32],
        target: i32,
        cache: &mut HashMap<i32, Result<usize, ()>>,
    ) -> Result<usize, ()> {
        if let Some(cached) = cache.get(&target) {
            return *cached;
        }

        if target == 0 {
            return Ok(0);
        }
        if target < 0 {
            return Err(());
        }
        let res = coins
            .iter()
            .filter_map(|c| Self::dfs(coins, target - c, cache).ok())
            .min()
            .map(|a| a + 1)
            .ok_or(());
        cache.insert(target, res);
        res
    }
}