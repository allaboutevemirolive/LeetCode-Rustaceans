// https://leetcode.com/problems/coin-change/solutions/2060962/rust-top-down-and-bottom-up-several-solutions-with-comments/
use std::collections::HashMap;

impl Solution {
    fn dfs(coins: &[i32], taken: usize, amount: usize, memo: &mut HashMap<usize, usize> ) -> usize {
        let remaining = amount - taken;
        if remaining == 0 {
            0
        } else if let Some(min_coins) = memo.get(&taken) {
            *min_coins
        } else {
            let mut min_coins = usize::MAX;
            for denomination in coins.iter().map(|d| *d as usize) {
                if denomination <= remaining {
                    min_coins = min_coins.min(Self::dfs(coins, taken + denomination, amount, memo).saturating_add(1));
                }
            }
            memo.insert(taken, min_coins);
            min_coins
        }
    }

    pub fn coin_change(coins: Vec<i32>, amount: i32) -> i32 {
        match Self::dfs(&coins, 0, amount as usize, &mut HashMap::new()) {
            usize::MAX => -1,
            min_coins => min_coins as _,
        }
    }
}