// https://leetcode.com/problems/coin-change/solutions/3289459/rust-2-approaches/
impl Solution {
    pub fn coin_change(coins: Vec<i32>, amount: i32) -> i32 {
        fn dp_top_down(coins: Vec<i32>, amount: i32) -> i32 {
            fn rec(coins: &Vec<i32>, amount: i32, amounts_per_sum: &mut Vec<i32>) -> i32 {
                if amount < 0 {
                    return -1;
                }
                if amount == 0 {
                    return 0;
                }
                if amounts_per_sum[amount as usize - 1] == 0 {
                    let mut min = i32::MAX;
                    for &coin in coins {
                        let amt = rec(coins, amount - coin, amounts_per_sum);
                        if amt >= 0 && amt < min {
                            min = amt + 1;
                        }
                    }
                    amounts_per_sum[amount as usize - 1] = if min == i32::MAX { -1 } else { min };
                }
                amounts_per_sum[amount as usize - 1]
            }
            let mut memo = vec![0; amount as usize];
            rec(&coins, amount, &mut memo)
        }
        fn dp_bottom_up(coins: Vec<i32>, amount: i32) -> i32 {
            let max = amount + 1;
            let mut dp = vec![max; max as usize];
            dp[0] = 0;
            for i in 1..max as usize {
                for j in 0..coins.len() {
                    if coins[j] as usize <= i {
                        dp[i] = dp[i].min(dp[i - coins[j] as usize] + 1);
                    }
                }
            }
            if dp[amount as usize] > amount {
                -1
            } else {
                dp[amount as usize]
            }
        }
        dp_top_down(coins, amount)
    }
}