// https://leetcode.com/problems/coin-change/solutions/1933207/rust-dynamic-programming-bottom-up-solution/
impl Solution {
 // Time complexity: O(amount * coins.len())
 pub fn coin_change(coins: Vec<i32>, amount: i32) -> i32 {
  let mut dp = vec![amount + 1; amount as usize + 1];
  // Initialize the base case
  // To fulfill the amoun 0, there is 0 coin type selected
  dp[0] = 0;

  for a in 1..amount + 1 {
   // With every amount, we iterate thorugh every coin types 
   for coin in coins.iter() {
    if a - coin >= 0 {
	 // Compare the current coin type with the "1 + dp[a-coin]"
	 // There is always 1 coin selected along with the dp[a-coin]
     dp[a as usize] = std::cmp::min(dp[a as usize], 1 + dp[(a - coin) as usize]);
    }
   }
  }

  // If there is no valid result, return -1
  return if dp[amount as usize] != amount + 1 {
   dp[amount as usize]
  } else {
   -1
  };
 }
}
