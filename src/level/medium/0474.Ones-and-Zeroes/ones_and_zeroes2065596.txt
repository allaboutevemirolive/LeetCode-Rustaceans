// https://leetcode.com/problems/ones-and-zeroes/solutions/2065596/rust-dp-with-hashmap/
use std::collections::HashMap;

impl Solution {
    pub fn find_max_form(strs: Vec<String>, m: i32, n: i32) -> i32 {
        let mut dp: HashMap<(i32, i32), i32> = HashMap::new();
        dp.insert((0, 0), 0);
        for s in strs.iter() {
            let zero = s.chars().filter(|&c| c == '0').count() as i32;
            let one = s.len() as i32 - zero;
            let entries: Vec<((i32, i32), i32)> =
                dp.iter().map(|(&k, &v)| (k, v)).collect();
				
            for ((zero2, one2), size) in entries.iter() {
                let (zero_sum, one_sum) = (zero + zero2, one + one2);
                if zero_sum <= m && one_sum <= n {
                    let entry = dp.entry((zero_sum, one_sum)).or_insert(0);
                    *entry = (*entry).max(size + 1);
                }
            }
        }
        *dp.values().max().unwrap()
    }
}