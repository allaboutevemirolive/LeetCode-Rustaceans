// https://leetcode.com/problems/decode-string/solutions/1070994/rust-solution/
use std::str::Chars;


impl Solution {
    
    pub fn decode_string(s: String) -> String {
        let lex = Lexer::new(&s);
        let parsed = Parser::new(lex);
        
        let mut result = String::new();
        for item in parsed {
            let s = item.to_string();
            result.push_str(&s);
        }
        result
    }
}

pub enum Token {
    Skip,
    Char(char),
    Num(i32),
    OpenBrace,
    CloseBrace,
}

pub struct Lexer<'a> {
    chars: Chars<'a>,
}

impl<'a> Lexer<'a> {
    pub fn new(encrypted: &'a str) -> Self {
        Self {
            chars: encrypted.chars(),
        }
    }
}

impl<'a> Iterator for Lexer<'a> {
    type Item = Token;

    fn next(&mut self) -> Option<Token> {
        let ch = self.chars.next()?;
        let t = match ch {
            '[' => Token::OpenBrace,
            ']' => Token::CloseBrace,
            '0'..='9' => Token::Num((ch as u32 - '0' as u32) as i32),
            'a'..='z' => Token::Char(ch),
            'A'..='Z' => Token::Char(ch),
            _ => Token::Skip,
        };

        Some(t)
    }
}

pub struct Encoded {
    str: String,
    count: i32,
}

impl Encoded {
    pub fn new(count: i32) -> Self {
        Self {
            str: String::new(),
            count,
        }
    }

    pub fn to_string(&self) -> String {
        let mut result = String::new();
        for _ in 0..self.count {
            result.push_str(&self.str);
        }
        result
    }
}

pub struct Parser<'a> {
    lexer: Lexer<'a>,
}

impl<'a> Parser<'a> {
    pub fn new(lexer: Lexer<'a>) -> Self {
        Self { lexer }
    }
}

impl<'a> Iterator for Parser<'a> {
    type Item = Encoded;

    fn next(&mut self) -> Option<Encoded> {
        let mut count = 0;
        let mut parsed = Vec::new();

        loop {
            match self.lexer.next() {
                Some(Token::Skip) => {}
                Some(Token::OpenBrace) => {
                    // no digit before brace - consider 1
                    if count == 0 {
                        count = 1;
                    }
                    let e = Encoded::new(count);
                    count = 0;
                    parsed.push(e);
                }
                Some(Token::CloseBrace) => {
                    let mut e = parsed.pop()?;
                    // no digit was before brace - consider 1
                    if e.count == 0 {
                        e.count = 1;
                    }

                    if parsed.is_empty() {
                        return Some(e);
                    }

                    // nested handling
                    let mut  parent = parsed.pop().unwrap();
                    parent.str.push_str(&e.to_string());

                    parsed.push(parent);
                }
                Some(Token::Char(c)) => {
                    if parsed.is_empty() {
                        let mut  e = Encoded::new(1);
                        e.str.push(c);
                        return Some(e);
                    }
                    parsed.last_mut()?.str.push(c)
                }
                Some(Token::Num(n)) => count = count * 10 + n,
                None => return None,
            }
        }
    }
}