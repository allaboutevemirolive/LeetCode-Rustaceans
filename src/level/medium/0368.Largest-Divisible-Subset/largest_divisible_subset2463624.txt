// https://leetcode.com/problems/largest-divisible-subset/solutions/2463624/rust-solution-using-bfs/
impl Solution {
    pub fn largest_divisible_subset(mut nums: Vec<i32>) -> Vec<i32> {
        nums.sort();
        let n = nums.len();
        let mut g = vec![vec![];n];

        for i in 0..n {
            let v1 = nums[i];
            for j in i+1..n {
                let v2 = nums[j];
                if v2 % v1 == 0 {
                    g[i].push(j);
                }
            }
        }

        let inf = 1_000_000;
        let mut result = vec![nums[0]];
        for i in 0..n {
            let mut stack = vec![(i,1)];
            let mut previouses = vec![(inf,0);n];
            while !stack.is_empty() {
                let mut new_stack = vec![];
                while let Some((ci, score)) = stack.pop() {
                    let next_score = score+1;
                    for &ni in &g[ci] {
                        if previouses[ni].1 < next_score {
                            new_stack.push((ni, next_score));
                            previouses[ni] = (ci, next_score);
                        }
                    }
                }
                stack = new_stack;
            }

            let mut max = 0;
            let mut target_index = inf;
            for i in 0..n {
                let (_, score) = previouses[i];
                if max < score {
                    max = score;
                    target_index = i;
                }
            }

            if result.len() < max {
                let mut j = target_index;
                let mut temp = vec![];
                while previouses[j].0 != inf {
                    temp.push(nums[j]);
                    j = previouses[j].0;
                }
                temp.push(nums[j]);
                result = temp;
            }
        }
        result.sort();
        result
    }
}