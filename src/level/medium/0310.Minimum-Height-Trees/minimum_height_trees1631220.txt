// https://leetcode.com/problems/minimum-height-trees/solutions/1631220/rust-solution/
use std::collections::{HashSet, VecDeque};

impl Solution {
    pub fn find_min_height_trees(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {
        let n = n as usize;
        let mut g = vec![HashSet::new(); n];
        for e in edges {
            let (a, b) = (e[0] as usize, e[1] as usize);
            g[a].insert(b);
            g[b].insert(a);
        }

        let mut q = VecDeque::with_capacity(n);
        let mut d = vec![i32::MAX; n];
        g.iter()
            .enumerate()
            .filter(|(_, us)| us.len() <= 1)
            .for_each(|(v, _)| {
                q.push_back(v);
                d[v] = 0;
            });

        while let Some(v) = q.pop_front() {
            for u in std::mem::take(&mut g[v]) {
                g[u].remove(&v);
                if g[u].len() == 1 {
                    q.push_back(u);
                    d[u] = d[v] + 1;
                }
            }
        }
        let max_d = *d.iter().max().unwrap();

        d.into_iter()
            .enumerate()
            .filter(|&(_, d)| d == max_d)
            .map(|(i, _)| i as _)
            .collect()
    }
}