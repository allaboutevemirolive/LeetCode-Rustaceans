// https://leetcode.com/problems/minimum-height-trees/solutions/3400497/rust-topological-sort/
impl Solution {
    pub fn find_min_height_trees(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {
        find_min_height_trees(n, edges)
    }
}

use std::collections::HashSet;

pub fn find_min_height_trees(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {
    let edges = edges
        .into_iter()
        .map(|edge| (edge[0] as usize, edge[1] as usize))
        .collect::<Vec<_>>();

    let answer = min_height_trees(n as usize, &edges);

    answer.into_iter().map(|x| x as i32).collect()
}

pub fn min_height_trees(n: usize, edges: &[(usize, usize)]) -> Vec<usize> {
    if n < 2 {
        return (0..n).collect();
    }

    let mut graph = build_adjacency_list(n, edges);
    let mut leaves = graph
        .iter()
        .enumerate()
        .filter_map(|(i, set)| if set.len() == 1 { Some(i) } else { None })
        .collect::<Vec<_>>();

    // Trim the leaves until reaching the centroids

    let mut remaining_nodes = n;

    while remaining_nodes > 2 {
        remaining_nodes -= leaves.len();

        let mut new_leaves = vec![];

        for leaf in leaves {
            let neighbour = *graph[leaf].iter().next().unwrap();
            graph[neighbour].remove(&leaf);

            if graph[neighbour].len() == 1 {
                new_leaves.push(neighbour);
            }
        }

        leaves = new_leaves;
    }
    leaves
}

fn build_adjacency_list(n: usize, edges: &[(usize, usize)]) -> Vec<HashSet<usize>> {
    let mut graph = vec![HashSet::new(); n];

    for &(a, b) in edges {
        graph[a].insert(b);
        graph[b].insert(a);
    }

    graph
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_min_height_trees_1() {
        assert_eq!(min_height_trees(4, &[(1, 0), (1, 2), (1, 3)]), vec![1]);
    }

    #[test]
    fn test_min_height_trees_2() {
        assert_eq!(
            min_height_trees(6, &[(3, 0), (3, 1), (3, 2), (3, 4), (5, 4)]),
            vec![3, 4]
        );
    }
}
