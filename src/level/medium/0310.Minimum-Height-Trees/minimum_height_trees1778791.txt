// https://leetcode.com/problems/minimum-height-trees/solutions/1778791/rust-solution/
impl Solution {
    pub fn find_min_height_trees(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {
        let mut tree: Vec<Vec<i32>> = vec![vec![]; n as _];
        let mut node_edges_count = vec![0; n as _];
        let mut nodes_count = n;

        edges.iter().for_each(|i| {
            tree[i[0] as usize].push(i[1]);
            tree[i[1] as usize].push(i[0]);
            node_edges_count[i[0] as usize] += 1;
            node_edges_count[i[1] as usize] += 1;
        });

        let mut leaves: Vec<i32> = node_edges_count
            .iter_mut()
            .enumerate()
            .filter(|(_, j)| **j < 2)
            .map(|(i, j)| {
                *j = 0;
                i as i32
            })
            .collect();

        while nodes_count > 2 {
            let mut next_leaves: Vec<i32> = Vec::new();
            leaves.iter().for_each(|j| {
                tree[*j as usize].iter().for_each(|k| {
                    if node_edges_count[*k as usize] > 0 {
                        node_edges_count[*k as usize] -= 1;
                        if node_edges_count[*k as usize] == 1 {
                            next_leaves.push(*k);
                        }
                    }
                });
                nodes_count -= 1;
            });
            leaves = next_leaves;
        }
        leaves
    }
}