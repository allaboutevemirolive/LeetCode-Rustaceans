// https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solutions/1590433/rust-recursive-solution/
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
use std::collections::HashMap;


impl Solution {
    pub fn build_tree(inorder: Vec<i32>, postorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {
        build_tree(inorder, postorder)
    }
}

pub fn build_tree(inorder: Vec<i32>, postorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {
    assert_eq!(postorder.len(), inorder.len());
    if postorder.len() == 0 {
        return None;
    }

    let indexes = inorder
        .iter()
        .copied()
        .enumerate()
        .map(|(idx, val)| (val, idx))
        .collect::<HashMap<_, _>>();

    let mut root_index = postorder.len();
    subtree(&postorder, &mut root_index, 0, postorder.len(), &indexes)
}

fn subtree(
    postorder: &[i32],
    index: &mut usize,
    left: usize,
    right: usize,
    indexes: &HashMap<i32, usize>,
) -> Option<Rc<RefCell<TreeNode>>> {
    if *index == 0 {
        return None;
    }
    *index -= 1;

    let root = postorder[*index];
    let mut node = TreeNode::new(root);

    let &inorder_root_index = indexes.get(&root).unwrap();

    if *index > 0 {
        let value = postorder[*index - 1];
        let inorder_index = indexes[&value];
        if inorder_index > inorder_root_index && inorder_index < right {
            node.right = subtree(postorder, index, inorder_root_index, right, indexes);
        }
    }

    if *index > 0 {
        let value = postorder[*index - 1];
        let inorder_index = indexes[&value];
        if inorder_index < inorder_root_index && inorder_index >= left {
            node.left = subtree(postorder, index, left, inorder_root_index, indexes);
        }
    }

    Some(Rc::new(RefCell::new(node)))
}