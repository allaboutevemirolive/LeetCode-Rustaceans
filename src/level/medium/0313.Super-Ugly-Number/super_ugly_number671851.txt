// https://leetcode.com/problems/super-ugly-number/solutions/671851/rust-100-ac-binaryheap-with-ordering/
use std::cmp::Ordering;
use std::collections::BinaryHeap;  // max-heap by default

#[derive(Eq, PartialEq)]
struct Candidate {
    value: i32,
    p: i32,
    index: usize,
}

impl Ord for Candidate {
    fn cmp(&self, other: &Candidate) -> Ordering {
        other.value.cmp(&self.value)  // this makes it a min-heap
    }
}

impl PartialOrd for Candidate {
    fn partial_cmp(&self, other: &Candidate) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Solution {
    pub fn nth_super_ugly_number(n: i32, primes: Vec<i32>) -> i32 {
        let mut uglies = vec![1];
        let mut heap: BinaryHeap<Candidate> = BinaryHeap::new();

        for &prime in primes.iter() {
            heap.push(Candidate {
                value: prime,
                p: prime,
                index: 1,
            });
        }

        for _ in 1..n {
            let mut ugly = 0;
            if let Some(cand) = heap.peek() {
                ugly = cand.value;
            }
            uglies.push(ugly);
            while heap.peek().unwrap().value == ugly {
                let cand = heap.pop().unwrap();
                heap.push(Candidate {
                    value: cand.p * uglies[cand.index],
                    p: cand.p,
                    index: cand.index + 1,
                });
            }
        }
        uglies[uglies.len()-1]  // same as `*uglies.last().unwrap() `
    }
}