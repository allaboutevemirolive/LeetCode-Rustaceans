// https://leetcode.com/problems/super-ugly-number/solutions/1349583/rust-dp/
use std::collections::{HashSet, BinaryHeap};
impl Solution {
    pub fn nth_super_ugly_number(n: i32, primes: Vec<i32>) -> i32 {
        let n = n as usize;
        let m = primes.len();
        let mut pointers: Vec<i32> = vec![0; m];
        let mut dp: Vec<i32> = vec![1; n];
        
        for i in 1..n {
            dp[i] = (0..m)
                .map(|x| dp[pointers[x] as usize] * primes[x])
                .min()
                .unwrap();
            
            for x in 0..m {
                if dp[pointers[x] as usize] * primes[x] == dp[i]{
                    pointers[x] += 1;
                }
            }
        }
        
        dp[n - 1]
    }
}