// https://leetcode.com/problems/gray-code/solutions/2827065/rust-solution-with-explanation-kind-of-dp/
impl Solution {
    pub fn gray_code(n: i32) -> Vec<i32> {
        /*
            i guess we could consider this a dynamic programming problem as we can
            use res[0..2^{n-1}] in order to solve res[0..2^{n}] and so on...
            
            think of it this way...
            
            if we have are tryig to solve for n = 3 and have solved for n = 2
            
            [0,1,3,2 | -,-,-,-] || [000,001,011,010 | -,-,-,-]
            
            and we can work with the following solution...
            
            [0,1,3,2 | 6,7,5,4] || [000,001,011,010 | 110,111,101,100]
            
            we can start to see a pattern.
            
            the value of res[2^3 - x] is equivalent to res[x] + 2^2!
            in generic form, res[2^{n} - x] = res[x] + 2^{n - 1} for x in 0..2^{n - 1}
                        
            Premise
            --
            for every iteration of our algorithm we are just flipping
            the next bit from-the-right for each of the previously computed values.
            
            Why do we reverse?
            --
            it's intutive that the last value in the array will be a 1 with leading zeroes
            because the first and last values in the array can only differ by at 1 bit.
            the reversal of the values also makes sense as the two values on each
            side of the partition (010 and 110 in the case above) will just differ
            by the bit we are flipping.
            
            What about the other values?
            --
            because we are just adding this one bit to all values,
            and all of the previous values already only differ by a single bit, this
            property will continue to hold for all of the other values being computed
            during each iteration.
        */
        
        let mut res: Vec<i32> = vec![0; 1<<n];
        for i in 0..n {
            let start = 1<<i;
            for j in 0..start {
                res[start + (start - j) - 1] = res[j] + start as i32;
            }
        }
        res
    }
}