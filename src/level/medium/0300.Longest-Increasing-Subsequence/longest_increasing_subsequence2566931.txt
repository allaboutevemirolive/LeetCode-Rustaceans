// https://leetcode.com/problems/longest-increasing-subsequence/solutions/2566931/rust-0-ms-binary-search-and-in-place-operations-with-detailed-comments/
impl Solution 
{
    pub fn length_of_lis(nums: Vec<i32>) -> i32 
    {
        // [1] provided that we have to return only the length, 
        //     and not the longest subsequence itself, 
        //     we use the same storage for all candidates;
        //     (yes, candidate subsequences will overwrite each other;
        //     we only care about the final length)
        let mut subseq: Vec<i32> = Vec::with_capacity(nums.len());
        
        // [2] when iterating over the numbers...
        for n in nums.iter()
        {
            if let Err(pos) = subseq.binary_search(n)
            {
                // [3] ...we either encounter new largest number...
                //     (and add new item to subsequence)
                if pos == subseq.len() { subseq.push(*n); }
                // [4] ...or branch into subsequence at position 'pos'
                //     (and store this branch over the old one)
                else                   { subseq[pos] = *n;}
            }
            // [5] Ok(pos) behaves the same way as in [4]
        }
        
        return subseq.len() as i32;
    }
}