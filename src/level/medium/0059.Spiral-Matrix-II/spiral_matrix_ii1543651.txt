// https://leetcode.com/problems/spiral-matrix-ii/solutions/1543651/rust-solution/
use std::collections::HashMap; 

impl Solution {
    pub fn generate_matrix(n: i32) -> Vec<Vec<i32>> {
        let mut matrix :Vec<Vec<i32>> = Vec::with_capacity(n as usize);
        for _ in 0..n {
            let mut newVec :Vec<i32> = Vec::with_capacity(n as usize);
            for _ in 0..n {
                newVec.push(0);
            }
            matrix.push(newVec); 
        }
        
        let mut max_index = n - 1;
        let mut direction = (1, 0);
        let mut pos = (0, 0);
        let max = n*n;
        for i in 1..=max {
            matrix[pos.1][pos.0] = i;
            let mut prevPos = pos;
            pos = Self::addPos((pos.0 as i32, pos.1 as i32), direction);
            if Self::invalidPos(&matrix, pos, max_index as usize) {
                if direction.0 == 1 && direction.1 == 0 {
                    direction = (0, 1);
                } else if direction.0 == 0 && direction.1 == 1 {
                    direction = (-1, 0);
                } else if direction.0 == -1 && direction.1 == 0 {
                    direction = (0, -1);
                } else if direction.0 == 0 && direction.1 == -1 {
                    direction = (1, 0); 
                }
             
                pos = Self::addPos((prevPos.0 as i32, prevPos.1 as i32), direction);
                if Self::invalidPos(&matrix, pos, max_index as usize) { return break; }
            }
        }
        matrix
    }
    
    fn invalidPos(matrix: &Vec<Vec<i32>>, pos: (usize, usize), max_index: usize) -> bool {
        return pos.0 > max_index || pos.0 < 0 || pos.1 > max_index || pos.1 < 0 || matrix[pos.1][pos.0] > 0
    }
    
    fn addPos(pos1: (i32, i32), direction: (i32, i32)) -> (usize, usize) {
        return ((pos1.0 + direction.0) as usize, (pos1.1 + direction.1) as usize);
    }
}