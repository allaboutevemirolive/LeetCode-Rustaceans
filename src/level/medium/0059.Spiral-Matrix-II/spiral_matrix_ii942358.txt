// https://leetcode.com/problems/spiral-matrix-ii/solutions/942358/rust-cheapest-best/
enum Direction {
    Right,
    Down,
    Left,
    Up,
}

impl Direction {
    fn turn(&mut self) {
        match self {
            Self::Right => *self = Self::Down,
            Self::Down => *self = Self::Left,
            Self::Left => *self = Self::Up,
            Self::Up => *self = Self::Right,
        }
    }

    fn progress(&self, x: &mut usize, y: &mut usize) {
        match self {
            Self::Right => *x += 1,
            Self::Down => *y += 1,
            Self::Left => *x -= 1,
            Self::Up => *y -= 1,
        }
    }
}

impl Solution {
    pub fn generate_matrix(n: i32) -> Vec<Vec<i32>> {
        let n = n as usize;
        let mut res: Vec<Vec<i32>> = Vec::with_capacity(n);
        res.push((1..=n as i32).collect());
        res.extend(vec![vec![0; n]; n - 1]);

        let (mut cur, mut x, mut y, mut m, mut dir) = (n as i32, n - 1, 0, n - 1, Direction::Down);
        for _ in 1..n {
            for _ in 0..2 {
                for _ in 0..m {
                    cur += 1;
                    dir.progress(&mut x, &mut y);
                    res[y][x] = cur;
                }
                dir.turn();
            }
            m -= 1;
        }

        res
    }
}