// https://leetcode.com/problems/restore-ip-addresses/solutions/2681204/rust-backtrack-0ms/
use std::collections::HashSet;
impl Solution {
    pub fn restore_ip_addresses(s: String) -> Vec<String> {        
        fn helper(
            set: &mut HashSet<String>, 
            s_as_chars: &Vec<char>,
            cur_index: usize,
            cur_value: u32,
            dots_placed: u32,
            mut cur_soln: Vec<char>
        ) {
            // handle bounds
            if dots_placed > 3 || cur_value > 255 {
                return;
            }
            
            // handle end of string
            if cur_index == s_as_chars.len()  {
                if dots_placed == 3 {
                    set.insert(cur_soln.into_iter().collect::<String>());
                }
                return
            }
            
            // calculate next val
            let value_w_cur = (cur_value * 10) + s_as_chars[cur_index] as u32 - 0x30;
            
            // handle index 0
            if cur_index == 0 {
                cur_soln.push(s_as_chars[cur_index]);
                return helper(
                    set, 
                    s_as_chars, 
                    cur_index + 1, 
                    value_w_cur,
                    dots_placed,
                    cur_soln,
                );
            }
            
            // place a dot
            if cur_soln[cur_soln.len() - 1] != '.' {
                cur_soln.push('.');
                helper(
                    set, 
                    s_as_chars, 
                    cur_index, 
                    0,
                    dots_placed + 1,
                    cur_soln.clone(),
                );
                cur_soln.pop();
            }
            
            // handle leading zero
            if cur_soln[cur_soln.len() - 1] == '0' {
                if cur_soln.len() > 1 {
                    if cur_soln[cur_soln.len() - 2] == '.' {
                        return
                    }
                } else {
                    return
                }
            }
            
            // place the next char
            cur_soln.push(s_as_chars[cur_index]);
            helper(
                set, 
                s_as_chars, 
                cur_index + 1, 
                value_w_cur,
                dots_placed,
                cur_soln,
            );
        }
        
        let mut solns: HashSet<String> = HashSet::new();
        let as_chars: Vec<char> = s.chars().collect();
        if as_chars.len() < 4 || as_chars.len() > 12 {
            return vec![];
        }
        helper(&mut solns, &as_chars, 0, 0, 0, vec![]);
        solns.into_iter().collect::<Vec<String>>()
    }
}