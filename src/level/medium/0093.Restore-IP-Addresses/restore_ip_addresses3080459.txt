// https://leetcode.com/problems/restore-ip-addresses/solutions/3080459/rust-backtracking-solution/
impl Solution {
    pub fn restore_ip_addresses(s: String) -> Vec<String> {
        let mut restored = vec![];
        Self::restore_ip_address_recurse(s.as_bytes(), &mut vec![], &mut restored);
        restored
    }

    pub fn restore_ip_address_recurse(s: &[u8], restoring: &mut Vec<u8>, restored: &mut Vec<String>) {
        if restoring.len() == 4 {
            if s.is_empty() {
                let mut restored_ip = String::new();
                for each in restoring.iter() {
                    restored_ip.push_str(&each.to_string());
                    restored_ip.push('.');
                }
                restored_ip.pop();
                restored.push(restored_ip);
            }
            return;
        }

        for i in 0..3.min(s.len()) {
            let ip_slice = &s[0..i+1];
            if ip_slice.len() > 1 && unsafe { *ip_slice.first().unwrap_unchecked() } == '0' as u8 {
                continue;
            }

            match unsafe { std::str::from_utf8_unchecked(ip_slice).parse::<u8>() } {
                Ok(ip_slice_to_u8) => {
                    restoring.push(ip_slice_to_u8);
                    Self::restore_ip_address_recurse(&s[i+1..], restoring, restored);
                    restoring.pop();
                },
                Err(_) => continue,
            };
        }
    }
}