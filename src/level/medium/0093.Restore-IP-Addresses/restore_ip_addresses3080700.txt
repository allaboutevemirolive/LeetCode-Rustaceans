// https://leetcode.com/problems/restore-ip-addresses/solutions/3080700/rust-backtracking-solution/
impl Solution {
    pub fn restore_ip_addresses(s: String) -> Vec<String> {
        if s.len() < 4 && 12 < s.len() {
            return vec![];
        }
        fn back_tracking(
            current: usize,
            dot_indices: &mut Vec<usize>,
            s: &str,
            result: &mut Vec<String>,
        ) {
            if dot_indices.len() >= 3 {
                let rest_len = s.len() - current;
                if rest_len > 0
                    && rest_len < 4
                    && (rest_len == 1 || s.as_bytes()[current] != b'0')
                    && s[current..].parse::<i32>().unwrap() <= 255
                {
                    result.push(format!(
                        "{}.{}.{}.{}",
                        String::from_utf8(s.as_bytes()[0..dot_indices[0]].to_vec()).unwrap(),
                        String::from_utf8(s.as_bytes()[dot_indices[0]..dot_indices[1]].to_vec())
                            .unwrap(),
                        String::from_utf8(s.as_bytes()[dot_indices[1]..dot_indices[2]].to_vec())
                            .unwrap(),
                        String::from_utf8(s.as_bytes()[dot_indices[2]..].to_vec()).unwrap(),
                    ));
                }
            } else {
                for i in 1..=3.min(s.len() - current) {
                    if i > 1
                        && (s.as_bytes()[current] == b'0'
                            || s[current..current + i].parse::<i32>().unwrap() > 255)
                    {
                        continue;
                    }
                    dot_indices.push(current + i);
                    back_tracking(current + i, dot_indices, s, result);
                    dot_indices.pop();
                }
            }
        }
        let mut result = vec![];
        back_tracking(0, &mut vec![], &s, &mut result);
        result
    }
}