// https://leetcode.com/problems/permutations-ii/solutions/2031996/rust-backtracking-vec-instead-of-hashmap/
impl Solution {
    fn backtrack(
        nums: &[i32],
        mask: &mut Vec<bool>,
        scratch: &mut Vec<i32>,
        rez: &mut Vec<Vec<i32>>,
        k: usize,
    ) {
        let n = nums.len();
        if k == n {
            rez.push(scratch.clone());
        } else {
            let mut used = Vec::<i32>::with_capacity(n);
            for i in 0..nums.len() {
                if !mask[i] && !used.iter().any(|v| *v == nums[i]) {
                    scratch[k] = nums[i];
                    mask[i] = true;
                    Solution::backtrack(nums, mask, scratch, rez, k + 1);
                    used.push(nums[i]);
                    mask[i] = false;
                }
            }
        }
    }

    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let n = nums.len();
        let mut rez = vec![];
        let mut scratch = vec![0; n];
        let mut mask = vec![false; n];

        Solution::backtrack(&nums, &mut mask, &mut scratch, &mut rez, 0);
        rez
    }
}