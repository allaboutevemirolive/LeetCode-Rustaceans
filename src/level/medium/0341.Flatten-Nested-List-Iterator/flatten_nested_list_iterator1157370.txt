// https://leetcode.com/problems/flatten-nested-list-iterator/solutions/1157370/rust-vecdeque-solution-lazy-expansion/
use std::collections::VecDeque;

struct NestedIterator {
    q: VecDeque<NestedInteger>,
}

#[allow(dead_code)]
impl NestedIterator {
    fn new(nested_list: Vec<NestedInteger>) -> Self {
        NestedIterator {
            q: VecDeque::from(nested_list),
        }
    }

    fn next(&mut self) -> i32 {
        if !self.has_next() {
            return -1;
        }
        let ni: NestedInteger = self.q.pop_front().unwrap();
        if let NestedInteger::Int(x) = ni {
            return x;
        }
        -1
    }

    fn has_next(&mut self) -> bool {
        while !self.q.is_empty() {
            if let NestedInteger::Int(_x) = self.q.front().unwrap() {
                return true;
            }
            if let NestedInteger::List(mut list) = self.q.pop_front().unwrap() {
                list.reverse();
                for x in list {
                    self.q.push_front(x);
                }
            }
        }
        false
    }
}