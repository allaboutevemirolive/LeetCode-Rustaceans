// https://leetcode.com/problems/flatten-nested-list-iterator/solutions/2019128/rust-with-vec-intoiter-nestedinteger/
// #[derive(Debug, PartialEq, Eq)]
// pub enum NestedInteger {
//   Int(i32),
//   List(Vec<NestedInteger>)
// }

use std::vec::IntoIter;

struct NestedIterator {
    stack: Vec<IntoIter<NestedInteger>>,
    item: Option<i32>,
    peeked: bool,
}

impl NestedIterator {
    fn new(nestedList: Vec<NestedInteger>) -> Self {
        Self {
            stack: vec![nestedList.into_iter()],
            item: None,
            peeked: false,
        }
    }
    
    fn next(&mut self) -> i32 {
        if !self.peeked {
            self.get_next();
        }
        self.peeked = false;
        self.item.unwrap()
    }
    
    fn has_next(&mut self) -> bool {
        if !self.peeked {
            self.get_next();
            self.peeked = true;
        }
        self.item.is_some()
    }
    
    fn get_next(&mut self) {
        match self.stack.last_mut() {
            None => self.item = None,
            Some(iter) => match iter.next() {
                None => {
                    self.stack.pop();
                    self.get_next();
                }
                Some(NestedInteger::List(v)) => {
                    self.stack.push(v.into_iter());
                    self.get_next();
                }
                Some(NestedInteger::Int(i)) => self.item = Some(i),
            }
        }
    }
}