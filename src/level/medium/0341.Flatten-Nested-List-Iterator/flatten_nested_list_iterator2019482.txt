// https://leetcode.com/problems/flatten-nested-list-iterator/solutions/2019482/rust-maximally-lazy/
use std::vec::IntoIter;
struct NestedIterator {
    stack: Vec<IntoIter<NestedInteger>>,
    next: Option<i32>,
}

impl NestedIterator {
    fn new(nested_list: Vec<NestedInteger>) -> Self {
        Self {
            stack: vec![nested_list.into_iter()],
            next: None,
        }
    }

    fn get_next(&mut self) -> Option<i32> {
        loop {
            match self.stack.last_mut() {
                Some(item) => match item.next() {
                    Some(ni) => match ni {
                        NestedInteger::Int(n) => return Some(n),
                        NestedInteger::List(list) => self.stack.push(list.into_iter()),
                    },
                    None => {
                        self.stack.pop();
                    }
                },
                None => {
                    return None;
                }
            }
        }
    }

    fn next(&mut self) -> i32 {
        match self.next.take() {
            Some(n) => n,
            None => self.get_next().unwrap(),
        }
    }

    fn has_next(&mut self) -> bool {
        match &mut self.next {
            Some(_) => true,
            None => {
                self.next = self.get_next();
                self.next.is_some()
            }
        }
    }
}