// https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solutions/1725164/rust-bitmask-using-iterators-with-slight-optimization-skipping-zeros-104-ms-85-4-1mb-57/
use std::collections::HashSet;

impl Solution {
    pub fn find_maximum_xor(nums: Vec<i32>) -> i32 {
        
        // naive solution: O(n^2)
        // nums.iter().enumerate().map(|(i, n)| nums[i+1..].iter().map(|n_j| n_j ^ n).max().unwrap_or(0)).max().unwrap()
        
        (0..31).rev().map( |bit| 1 << bit)
            .scan(0, |mask_acc, mask_check| {
                *mask_acc = *mask_acc | mask_check;
                Some((*mask_acc, mask_check))
            })
            .fold(0, |max_so_far, (prefix_mask, mcheck)| {
                let max_check = max_so_far | mcheck;
                let mut zero_in_set = false;
                let mut mset: HashSet<i32> = nums.iter()
                    .filter_map(|num| {
                        if (num & prefix_mask) != 0 { Some (num & prefix_mask) }
                        else { 
                            if !zero_in_set { zero_in_set = true; }
                            None
                        }
                    }).collect();
                if zero_in_set { mset.insert(0); }

                mset.iter()
                    .find(|&mask| mset.contains(&(mask ^ max_check)))
                    .map(|_| max_check)
                    .unwrap_or(max_so_far)
            })
    }
}

/*
[3,10,5,25,2,8]
[14,70,53,83,49,91,36,80,92,51,66,70]
[1]
[4,6,7]
*/