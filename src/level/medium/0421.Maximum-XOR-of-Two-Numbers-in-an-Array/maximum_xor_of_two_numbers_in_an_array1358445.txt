// https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solutions/1358445/rust-bitwise-trie-solution/
/// https://en.wikipedia.org/wiki/Trie#Bitwise_tries
#[derive(Default, Debug)]
struct Trie {
    left: Option<Box<Trie>>,
    right: Option<Box<Trie>>,
}

impl Trie {
    pub fn new() -> Trie {
        Default::default()
    }

    pub fn insert(&mut self, num: i32) {
        let mut cur = self;
        for i in (0..31).rev() {
            if (num >> i) & 1 > 0 {
                if let Some(ref mut r) = cur.right {
                    cur = r;
                } else {
                    cur.right = Some(Box::new(Trie::new()));
                    cur = cur.right.as_mut().unwrap();
                }
            } else {
                if let Some(ref mut l) = cur.left {
                    cur = l;
                } else {
                    cur.left = Some(Box::new(Trie::new()));
                    cur = cur.left.as_mut().unwrap();
                }
            }
        }
    }

    pub fn max_xor(&self, num: i32) -> i32 {
        let mut cur = self;
        let mut ans = 0;
        for i in (0..31).rev() {
            ans = ans << 1;
            if (num >> i) & 1 > 0 {
                if let Some(ref l) = cur.left {
                    cur = l;
                    ans += 1;
                } else {
                    cur = cur.right.as_ref().unwrap();
                }
            } else {
                if let Some(ref r) = cur.right {
                    cur = r;
                    ans += 1;
                } else {
                    cur = cur.left.as_ref().unwrap();
                }
            }
        }
        ans
    }
}

impl Solution {
    pub fn find_maximum_xor(nums: Vec<i32>) -> i32 {
        let mut trie = Trie::new();
        for &num in nums.iter() {
            trie.insert(num);
        }
        nums.into_iter().map(|a| trie.max_xor(a)).max().unwrap()
    }
}