// https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solutions/804241/rust-cheapest-best/
use std::collections::HashSet;
use std::iter::FromIterator;

impl Solution {
    pub fn find_maximum_xor(nums: Vec<i32>) -> i32 {
        (0..=31)
            .rev()
            .scan(0, |mask, i| {
                *mask = *mask | 1 << i;
                Some((*mask, 1 << i))
            })
            .fold(0, |result, (mask, bit)| {
                let greedy = result | bit;
                let s: HashSet<i32> = HashSet::from_iter(nums.iter().map(|n| n & mask));
                s.iter()
                    .find(|&left_part| s.contains(&(left_part ^ greedy)))
                    .map(|_| greedy)
                    .unwrap_or(result)
            })
    }
}