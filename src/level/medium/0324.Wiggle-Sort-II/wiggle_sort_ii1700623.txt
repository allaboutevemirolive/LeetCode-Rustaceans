// https://leetcode.com/problems/wiggle-sort-ii/solutions/1700623/rust-14ms-2-3mb/
use std::cmp::Ordering;

impl Solution {

pub fn wiggle_sort(nums: &mut Vec<i32>) {
    if nums.is_empty() {
        return;
    }
    // rust uses timsort: 
	//   merge + insertion 
	// 
    // https://en.wikipedia.org/wiki/Timsort
    nums.sort();

    let n = nums.len();
    let mut k = n - 1;

    // find median
    let median = *nums.iter().nth(n / 2).unwrap();

    // three-way partition
    let (mut i, mut j) = (0, 0);

    while j <= k {
        match (nums[index(j, n)]).cmp(&median) {
            Ordering::Less => {
                nums.swap(index(j, n), index(k, n));
                k -= 1;
            }
            Ordering::Greater => {
                nums.swap(index(j, n), index(i, n));
                j += 1;
                i += 1;
            }
            Ordering::Equal => j += 1,
        }
    }
}
}

// re-map index
//   [0,     mid] -> [1, 3, 5, 7,..]
//   [mid+1, n-1] -> [0, 2, 4, 6,..]
fn index(i: usize, n: usize) -> usize {
    (1 + 2 * i) % (n | 1)
}