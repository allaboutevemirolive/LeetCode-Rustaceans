// https://leetcode.com/problems/palindrome-partitioning/solutions/3083597/rust-backtracking/
impl Solution {
    pub fn partition(s: String) -> Vec<Vec<String>> {
        let mut ret = vec![];
        let mut t = vec![];
        let s: Vec<char> = s.chars().collect();

        Self::foo(0, &mut ret, &mut t, &s);
        ret
    }

    fn foo(i: usize, ret: &mut Vec<Vec<String>>, t: &mut Vec<usize>, s: &[char]) {
        if i == s.len() {
            let mut tt = Vec::with_capacity(t.len());
            for i in 1..t.len() {
                tt.push(s[t[i - 1]..t[i]].iter().collect());
            }
            tt.push(s[t[t.len() - 1]..].iter().collect());
            ret.push(tt);
            return;
        }

        t.push(i);
        for j in i..s.len() {
            if Self::is_palindrome(i, j, s) {
                Self::foo(j + 1, ret, t, s);
            }
        }
        t.pop();
    }

    fn is_palindrome(mut i: usize, mut j: usize, s: &[char]) -> bool {
        while i < j {
            if s[i] != s[j] {
                return false;
            }
            i += 1;
            j -= 1;
        }
        true
    }
}