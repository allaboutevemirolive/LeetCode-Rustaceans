// https://leetcode.com/problems/palindrome-partitioning/solutions/3086575/rust-backtracking-solution/
impl Solution {
    pub fn is_palindrome(s: &[u8]) -> bool {
        let s_len = s.len();
        if s_len <= 1 {
            return true;
        }
        
        unsafe {
            let first = s.first().unwrap_unchecked();
            let last = s.last().unwrap_unchecked();
            if first == last {
                Self::is_palindrome(&s[1..s_len-1])
            } else {
                false
            }
        }
    }

    pub fn get_all_palindrome_substr_partitions<'a>(s: &'a [u8], pseq: &mut Vec<&'a [u8]>, pseqs: &mut Vec<Vec<String>>) {
        let s_len = s.len();
        if s_len == 0 {
            let mut pseq_in_str = Vec::new();
            for p in pseq.iter() {
                pseq_in_str.push(unsafe {
                    String::from(std::str::from_utf8_unchecked(*p))
                });
            }
            pseqs.push(pseq_in_str);
        }

        for i in 1..(s_len + 1) {
            let (slice_front, slice_back) = s.split_at(i);
            if Self::is_palindrome(slice_front) {
                pseq.push(slice_front);
                Self::get_all_palindrome_substr_partitions(slice_back, pseq, pseqs);
                pseq.pop();
            }
        }
    }

    pub fn partition(s: String) -> Vec<Vec<String>> {
        let mut pseqs = vec![];
        Self::get_all_palindrome_substr_partitions(s.as_bytes(), &mut vec![], &mut pseqs);
        pseqs
    }
}