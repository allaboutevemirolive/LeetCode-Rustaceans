// https://leetcode.com/problems/palindrome-partitioning/solutions/2728422/rust-solution/
fn helper(s:&String, li:usize, ri:usize) -> bool {
    let mi = (li+ri) / 2;
    for i in li..=mi {
        if s[i..=i] != s[ri-(i-li)..=ri-(i-li)] {
            return false
        }
    }
    true
}

fn dfs(result: &mut Vec<Vec<String>>, arr:Vec<String>, s:&String, ci:usize) {
    let n = s.len();
    if ci == n {
        if !arr.is_empty() {
            result.push(arr);
        }
        return
    }

    for i in ci..n {
        if helper(&s, ci, i) {
            let mut cloned = arr.clone();
            cloned.push(s[ci..=i].to_string());
            dfs(result, cloned, &s, i+1);
        }
    }
}

impl Solution {
    pub fn partition(s: String) -> Vec<Vec<String>> {
        let mut result = vec![];
        dfs(&mut result, vec![], &s, 0);
        result
    }
}