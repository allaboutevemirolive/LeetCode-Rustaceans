// https://leetcode.com/problems/path-sum-ii/solutions/2616222/rust-0ms-2-5mb-iterative/
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn path_sum(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> Vec<Vec<i32>> {
        if let Some(root) = root {
            let mut res : Vec<Vec<i32>> = vec![];
            let mut frontier : Vec<(Rc<RefCell<TreeNode>>, i32, Vec<i32>)> = vec![(root, 0, vec![])];

            while let Some((node, mut sum, mut path)) = frontier.pop() {
                let val = node.borrow().val;
                let left = node.borrow_mut().left.take();
                let right = node.borrow_mut().right.take();
                path.push(val);
                sum += val;

                if left.is_none() && right.is_none() && sum == target_sum {
                    res.push(path);
                } else {
                    if let Some(left) = left {
                        frontier.push((left, sum, path.clone()));
                    }
                    if let Some(right) = right {
                        frontier.push((right, sum, path.clone()));
                    }
                }
            }

            res
        } else {
            vec![]
        }
    }
}