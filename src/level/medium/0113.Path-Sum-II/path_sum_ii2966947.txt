// https://leetcode.com/problems/path-sum-ii/solutions/2966947/rust-solution-using-dfs/
struct Helper {
  result: Vec<Vec<i32>>
}
impl Helper {
  fn dfs(&mut self, node: &Rc<RefCell<TreeNode>>, arr: &mut Vec<i32>, ctot:i32, sum:i32) {
    let mut is_leaf = true;
    if let Some(left) = &node.borrow().left {
      is_leaf = false;
      let lv = left.borrow().val;
      arr.push(lv);
      self.dfs(&left, arr, ctot+lv, sum);
      arr.pop();
    }

    if let Some(right) = &node.borrow().right {
      is_leaf = false;
      let lv = right.borrow().val;
      arr.push(lv);
      self.dfs(&right, arr, ctot+lv, sum);
      arr.pop();
    }

    if is_leaf && ctot == sum {
      self.result.push(arr.clone());
    }
  }
}

use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn path_sum(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> Vec<Vec<i32>> {
      if let Some(node) = root {
        let mut helper = Helper { result: vec![] };
        helper.dfs(&node, &mut vec![node.borrow().val], node.borrow().val, target_sum);
        helper.result
      } else {
        vec![]
      }

    }
}