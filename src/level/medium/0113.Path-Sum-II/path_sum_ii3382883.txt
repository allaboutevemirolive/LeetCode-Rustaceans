// https://leetcode.com/problems/path-sum-ii/solutions/3382883/rust-dfs-and-bfs/
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }

impl Solution {
    pub fn path_sum(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> Vec<Vec<i32>> {
        path_sum(root, target_sum, Algorithm::Bfs)
    }
}

use std::{cell::RefCell, collections::VecDeque, rc::Rc};

pub enum Algorithm {
    Dfs,
    Bfs,
}

pub fn path_sum(
    root: Option<Rc<RefCell<TreeNode>>>,
    target_sum: i32,
    alg: Algorithm,
) -> Vec<Vec<i32>> {
    match alg {
        Algorithm::Dfs => path_sum_dfs(root, target_sum),
        Algorithm::Bfs => path_sum_bfs(root, target_sum),
    }
}

fn path_sum_bfs(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> Vec<Vec<i32>> {
    let mut paths = vec![];
    let mut q = VecDeque::new();

    q.push_back((root, vec![], target_sum));

    while let Some((Some(node), mut path, mut target)) = q.pop_front() {
        let node_val = node.borrow().val;
        path.push(node_val);
        target -= node_val;

        let left_child = node.borrow().left.clone();
        let right_child = node.borrow().right.clone();

        if left_child.is_none() && right_child.is_none() && target == 0 {
            paths.push(path.clone());
        }

        if left_child.is_some() {
            q.push_back((left_child, path.clone(), target));
        }

        if right_child.is_some() {
            q.push_back((right_child, path, target));
        }
    }

    paths
}

pub fn path_sum_dfs(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> Vec<Vec<i32>> {
    let mut paths = vec![];

    path_sum_helper(root, target_sum, &mut paths, &mut vec![]);

    paths
}

fn path_sum_helper(
    node: Option<Rc<RefCell<TreeNode>>>,
    mut target: i32,
    paths: &mut Vec<Vec<i32>>,
    path: &mut Vec<i32>,
) {
    match node {
        None => (),
        Some(node) => {
            let node_val = node.borrow().val;

            target -= node_val;

            path.push(node_val);

            if node.borrow().left.is_none() && node.borrow().right.is_none() && target == 0 {
                paths.push(path.clone());
            }

            if node.borrow().left.is_some() {
                path_sum_helper(node.borrow().left.clone(), target, paths, path);
            }

            if node.borrow().right.is_some() {
                path_sum_helper(node.borrow().right.clone(), target, paths, path);
            }

            path.pop();
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_path_sum_dfs_1() {
        let root = TreeNode::from_arr(&[
            Some(5),
            Some(4),
            Some(8),
            Some(11),
            None,
            Some(13),
            Some(4),
            Some(7),
            Some(2),
            None,
            None,
            Some(5),
            Some(1),
        ]);

        assert_eq!(
            path_sum_dfs(root, 22),
            vec![vec![5, 4, 11, 2], vec![5, 8, 4, 5]]
        );
    }

    #[test]
    fn test_path_sum_dfs_2() {
        let root = TreeNode::from_arr(&[Some(1), Some(2), Some(3)]);

        assert_eq!(path_sum_dfs(root, 5), vec![vec![]; 0]);
    }

    #[test]
    fn test_path_sum_dfs_3() {
        let root = TreeNode::from_arr(&[Some(1), Some(2)]);

        assert_eq!(path_sum_dfs(root, 0), vec![vec![]; 0]);
    }

    #[test]
    fn test_path_sum_bfs_1() {
        let root = TreeNode::from_arr(&[
            Some(5),
            Some(4),
            Some(8),
            Some(11),
            None,
            Some(13),
            Some(4),
            Some(7),
            Some(2),
            None,
            None,
            Some(5),
            Some(1),
        ]);

        assert_eq!(
            path_sum_bfs(root, 22),
            vec![vec![5, 4, 11, 2], vec![5, 8, 4, 5]]
        );
    }

    #[test]
    fn test_path_sum_bfs_2() {
        let root = TreeNode::from_arr(&[Some(1), Some(2), Some(3)]);

        assert_eq!(path_sum_bfs(root, 5), vec![vec![]; 0]);
    }

    #[test]
    fn test_path_sum_bfs_3() {
        let root = TreeNode::from_arr(&[Some(1), Some(2)]);

        assert_eq!(path_sum_bfs(root, 0), vec![vec![]; 0]);
    }
}
