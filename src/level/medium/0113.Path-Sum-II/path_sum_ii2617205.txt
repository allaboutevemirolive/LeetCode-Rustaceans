// https://leetcode.com/problems/path-sum-ii/solutions/2617205/rust-backtrack-with-comments/
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

    fn backtrack(node_rc: Rc<RefCell<TreeNode>>, target_sum: i32, path: &mut Vec<i32>, sum: i32, mut rez: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let node_ref = node_rc.borrow();
        path.push(node_ref.val);
        let sum = sum + node_ref.val;
        match (node_ref.left.clone(), node_ref.right.clone()) {
            (None, None) => { if sum == target_sum { rez.push(path.clone()) } },
            (None, Some(right_rc)) => { rez = Self::backtrack(right_rc, target_sum , path, sum, rez) },
            (Some(left_rc), None) => { rez = Self::backtrack(left_rc, target_sum, path, sum, rez) },
            (Some(left_rc), Some(right_rc)) => { 
                rez = Self::backtrack(right_rc, target_sum, path, sum, rez);
                rez = Self::backtrack(left_rc, target_sum, path, sum, rez)
            },
        }
        path.pop();
        rez
    }

    pub fn path_sum(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> Vec<Vec<i32>> {
        match root {
            Some(root_rc) => Self::backtrack(root_rc, target_sum, &mut vec![], 0, vec![]),
            None => vec![],
        }
    }
}