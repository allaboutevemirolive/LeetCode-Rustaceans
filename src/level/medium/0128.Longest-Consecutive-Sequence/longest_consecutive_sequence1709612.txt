// https://leetcode.com/problems/longest-consecutive-sequence/solutions/1709612/rust-unionfind-beginner/
use std::collections::HashMap;

impl Solution {
    pub fn longest_consecutive(nums: Vec<i32>) -> i32 {
        
        if nums.len() < 2 {
            return nums.len() as i32;
        }
        
        let mut parent = Vec::with_capacity(nums.len());
        let mut size = Vec::with_capacity(nums.len());
        for i in 0..nums.len() {
            parent.push(i as i32);
            size.push(1);
        }
        
        let mut uf = UnionFind::new(parent, size);
        let mut map = HashMap::new();
        
        for i in 0..nums.len() {
            if !map.contains_key(&nums[i]) {
                let prev_idx = map.get(&((nums[i] - 1)  as i32));
                let next_idx = map.get(&((nums[i] + 1)  as i32));
                if map.contains_key(&(nums[i] - 1)) && map.contains_key(&(nums[i] + 1)) {
                    uf.union(*prev_idx.unwrap(), *next_idx.unwrap());
                } 
                if(map.contains_key(&(nums[i] - 1))){
                    uf.union(i as i32, *prev_idx.unwrap());
                }else if(map.contains_key(&(nums[i] + 1))){
                    uf.union(i as i32, *next_idx.unwrap());
                }
                map.insert(&nums[i], i as i32);
            }
        }
        
        uf.max_size()
    }
}

struct UnionFind {
    parent: Vec<i32>,
    size: Vec<i32>
}

impl UnionFind {
    
    fn new(parent: Vec<i32>, size: Vec<i32>) -> UnionFind {
        UnionFind {
            parent,
            size
        }
    }
    
    fn max_size(&self) -> i32{
        *self.size.iter().max().unwrap()
    }
    
    fn union(&mut self, n1: i32, n2: i32){
        let p1 = self.find(n1);
        let p2 = self.find(n2);
        if p1 != p2 {
            if self.size[p1 as usize] > self.size[p2 as usize] {
                self.parent[p2 as usize] = p1;
                self.size[p1 as usize] = self.size[p1 as usize] + self.size[p2 as usize];
            }else {
                self.parent[p1 as usize] = p2;
                self.size[p2 as usize] = self.size[p1 as usize] + self.size[p2 as usize];
            }
        }
    }
    
    fn find(&mut self, n: i32) -> i32 {
        let mut root = self.parent[n as usize];
        while root != self.parent[root as usize] {
            root = self.parent[root as usize];
        }
        let mut p = n;
        while p != root {
            let mut lp = self.parent[p as usize];
            self.parent[p as usize] = root;
            p = lp;
        }
        root
    }
    
}
