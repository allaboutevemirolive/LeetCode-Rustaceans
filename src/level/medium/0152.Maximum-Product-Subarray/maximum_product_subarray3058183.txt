// https://leetcode.com/problems/maximum-product-subarray/solutions/3058183/functional-style-o-n-solution-in-rust/
impl Solution {
    pub fn max_product(nums: Vec<i32>) -> i32 {
        nums.iter().fold((None, None, None),
            |(max, p1, p2), &num| (
                Some(max.map_or(num, |max| p1.map_or(num, |p1| p1*num).max(p2.map_or(num, |p2| p2*num)).max(max))),
                if num==0 { None } else { Some(p1.map_or(num, |p1| p1*num)) },
                if num==0 { None } else if num<0 && p2.is_none() { Some(1) } else { p2.map(|p2| p2*num) }
            )).0.unwrap()
    }
}