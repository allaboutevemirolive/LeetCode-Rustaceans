// https://leetcode.com/problems/maximum-product-subarray/solutions/841875/rust-o-n-kadane-like-solution/
use std::cmp::{max, min};

impl Solution {
    pub fn max_product(nums: Vec<i32>) -> i32 {
        let mut maxp = nums[0];
        let mut products = vec![(nums[0], 1i32)];
        for i in 1..nums.len() {
            let (pos, neg) = products[i-1];
            let b = min(min(neg * nums[i], pos * nums[i]), 1 * nums[i]);
            let a = max(max(neg * nums[i], pos * nums[i]), 1 * nums[i]);
            products.push((a,b));
            maxp = max(maxp, products[i].0);
        }
        maxp
    }
}