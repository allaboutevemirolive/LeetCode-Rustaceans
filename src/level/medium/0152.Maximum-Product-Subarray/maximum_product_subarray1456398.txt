// https://leetcode.com/problems/maximum-product-subarray/solutions/1456398/rust-100/
use std::mem::swap; 
use std::i32; 
impl Solution {
    pub fn max_product(nums: Vec<i32>) -> i32 {
        let mut res = nums[0]; 
        let (mut currMin, mut currMax) = (1, 1);
      
        
        for i in 0..nums.len() {
            
            let num = nums[i]; 
            if num.is_negative() {
                swap(&mut currMax, &mut currMin)
            }
            
            currMax = i32::max(num, currMax * num);
            currMin = i32::min(num, currMin * num);
            res = i32::max(res, currMax); 
            
             
        }
        res
        
        
        
        
        
    }
}