// https://leetcode.com/problems/maximum-product-subarray/solutions/309682/rust-0ms-solution/
use std::cmp;

impl Solution {
    pub fn max_product(nums: Vec<i32>) -> i32 {
        if nums.len() == 0 { return 0; }
        
	    // dp[x][0] max value, dp[x][1] min value
        let mut dp = vec![vec![0; 2]; 2];
        let mut result = nums[0];
        
        dp[0][0] = nums[0];
        dp[0][1] = nums[0];
        
        for i in 1..nums.len() {
		     // x, y is 0 or 1
            let (x, y) = (i % 2, (i - 1) % 2); 
            
            if nums[i] >= 0 {
                dp[x][0] = cmp::max(dp[y][0] * nums[i], nums[i]);
                dp[x][1] = cmp::min(dp[y][1] * nums[i], nums[i]);
            } else {
                dp[x][0] = cmp::max(dp[y][1] * nums[i], nums[i]);
                dp[x][1] = cmp::min(dp[y][0] * nums[i], nums[i]);
            }
            
            result = cmp::max(dp[x][0], result);
        }
        
        result
    }
}