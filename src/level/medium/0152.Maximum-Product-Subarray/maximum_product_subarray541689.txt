// https://leetcode.com/problems/maximum-product-subarray/solutions/541689/rust-0ms-one-pass/
impl Solution {
    pub fn max_product(nums: Vec<i32>) -> i32 {        
        let mut biggest_product = nums[0];
        let mut current = 1;
        let mut biggest_negative = 1;
        
        for value in nums {
            current *= value;
            
            if current > biggest_product {
                biggest_product = current;
            }
            
            if current / biggest_negative > biggest_product {
                biggest_product = current / biggest_negative;
            }
            
            if current < 0 && (current > biggest_negative || biggest_negative > 0) {
                biggest_negative = current;
            }
            
            if current == 0 {
                current = 1;
                biggest_negative = 1;
            }
        }
        
        return biggest_product;
    }
}