// https://leetcode.com/problems/maximum-product-of-word-lengths/solutions/2087880/rust-functional-style/
use std::collections::HashMap;

impl Solution {
    pub fn max_product(words: Vec<String>) -> i32 {
        let map = words
            .into_iter()
            .fold(HashMap::<u32, usize>::new(), |mut map, word| {
                let mask = word
                    .as_bytes()
                    .iter()
                    .fold(0, |m, c| m | (1 << (*c - b'a')));
                let entry = map.entry(mask).or_default();
                *entry = (*entry).max(word.len());
                map
            });
        map.iter()
            .flat_map(|(mask1, len1)| {
                map.iter()
                    .map(move |(mask2, len2)| (mask1, len1, mask2, len2))
            })
            .filter(|(mask1, _, mask2, _)| **mask1 & **mask2 == 0)
            .map(|(_, len1, _, len2)| len1 * len2)
            .max()
            .unwrap_or_default() as i32
    }
}