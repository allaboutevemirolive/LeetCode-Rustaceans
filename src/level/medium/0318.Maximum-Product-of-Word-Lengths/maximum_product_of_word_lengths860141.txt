// https://leetcode.com/problems/maximum-product-of-word-lengths/solutions/860141/rust-4ms-100/
impl Solution {
    pub fn max_product(words: Vec<String>) -> i32 {
        let n = words.len();
        let mut v = Vec::<i32>::new();

        for w in &words {
            let mut x= 0;
            for &ch in w.as_bytes() {
                x |= 1 << (ch - b'a');
            }
            v.push(x)
        }

        let mut ans = 0;
        for i in 0..n {
            for j in i + 1 ..n {
                if (v[i] & v[j] == 0) && words[i].len() * words[j].len() > ans  {
                    ans = words[i].len() * words[j].len();
                }
            }
        }
        ans as i32
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_max_product() {
        assert_eq!(
            Solution::max_product(vec![
                "abcw".to_owned(),
                "baz".to_owned(),
                "foo".to_owned(),
                "bar".to_owned(),
                "xtfn".to_owned(),
                "abcdef".to_owned()
            ]),
            16
        );
    }

    #[test]
    fn test_max_product_02() {
        assert_eq!(
            Solution::max_product(vec![
                "a".to_owned(),
                "ab".to_owned(),
                "abc".to_owned(),
                "d".to_owned(),
                "cd".to_owned(),
                "bcd".to_owned(),
                "abcd".to_owned()
            ]),
            4
        );
    }

    #[test]
    fn test_max_product_03() {
        assert_eq!(
            Solution::max_product(vec![
                "a".to_owned(),
                "aa".to_owned(),
                "aaa".to_owned(),
                "aaaa".to_owned()
            ]),
            0
        );
    }
}