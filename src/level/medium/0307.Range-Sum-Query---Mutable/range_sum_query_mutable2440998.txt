// https://leetcode.com/problems/range-sum-query-mutable/solutions/2440998/square-root-decomposition-in-rust-written-with-the-help-of-copilot/
#[derive(Debug)]
struct NumArray {
    nums: Vec<i32>,
    chunksums: Vec<i32>,
}


impl NumArray {

    fn len(&self) -> usize {
        self.nums.len()
    }

    fn chunksize(&self) -> usize {
        // square root of the length of the array
        (self.len() as f64).sqrt() as usize
    }

    fn i2chunk(&self, i: usize) -> usize {
        i / self.chunksize()
    }

    fn new(nums: Vec<i32>) -> Self {
        let chunksize = (nums.len() as f64).sqrt() as usize;
        NumArray {
            nums: nums.clone(),
            chunksums : nums.chunks(chunksize).map(|chunk| chunk.iter().sum()).collect()
        }
    }
    
    fn update(&mut self, index: i32, val: i32) {
        let diff = val - self.nums[index as usize];
        self.nums[index as usize] = val; 
        let chunki = self.i2chunk(index as usize);
        self.chunksums[chunki] += diff;
    }
    
    fn sum_range(&self, left: i32, right: i32) -> i32 {
        let leftchunk = self.i2chunk(left as usize);
        let rightchunk = self.i2chunk(right as usize);
        if leftchunk == rightchunk {
            return self.nums[left as usize..right as usize + 1].iter().sum();
        }
        // this does at most O(sqrt(n)) work since there are atmost O(sqrt(n)) chunks
        let chunksum : i32 = (leftchunk+1..rightchunk).map(|i| self.chunksums[i]).sum();
        // each of the following does at most O(sqrt(n)) work since there are at most O(sqrt(n)) elements in a chunk
        let leftcrumbs : i32 = self.nums[left as usize .. (leftchunk + 1) * self.chunksize()].iter().sum();
        let rightcrumbs : i32 = self.nums[(rightchunk * self.chunksize()).. right as usize + 1].iter().sum();
        leftcrumbs + chunksum + rightcrumbs
    }
}