// https://leetcode.com/problems/range-sum-query-mutable/solutions/1298239/rust-binaryindexedtree-solution/
/// https://en.wikipedia.org/wiki/Fenwick_tree
pub struct BinaryIndexedTree {
    sums: Vec<i32>,
}

impl BinaryIndexedTree {
    pub fn new(n: usize) -> Self {
        Self {
            sums: vec![0; n + 1],
        }
    }

    // O(logn)
    pub fn update(&mut self, mut i: usize, delta: i32) {
        while i < self.sums.len() {
            self.sums[i] += delta;
            i += Self::lsb(i);
        }
    }

    // O(logn)
    pub fn query(&self, mut i: usize) -> i32 {
        let mut sum = 0;
        while i > 0 {
            sum += self.sums[i];
            i -= Self::lsb(i);
        }
        sum
    }

    /// least significant bit
    fn lsb(num: usize) -> usize {
        let num = num as isize;
        (num & -num) as usize
    }
}


struct NumArray {
    tree: BinaryIndexedTree
}

impl NumArray {
    fn new(nums: Vec<i32>) -> Self {
        let n = nums.len();
        let mut tree = BinaryIndexedTree::new(n);
        for i in 0..n {
            tree.update(i + 1, nums[i]);
        }
        Self { tree }
    }
    
    fn update(&mut self, index: i32, val: i32) {
        let prev = self.tree.query(index as usize + 1) - self.tree.query(index as usize);
        let delta = val - prev;
        self.tree.update(index as usize + 1, delta);
    }
    
    fn sum_range(&self, left: i32, right: i32) -> i32 {
        self.tree.query(right as usize + 1) - self.tree.query(left as usize)
    }
}