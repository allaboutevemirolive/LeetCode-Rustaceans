// https://leetcode.com/problems/range-sum-query-mutable/solutions/224247/rust-16ms/
use std::rc::Rc;
use std::cell::RefCell;

type TreeNodeCell = Rc<RefCell<TreeNode>>;

#[derive(Debug, Default)]
struct TreeNode {
    start: usize,
    end: usize,
    
    value: i32,
    
    left: Option<TreeNodeCell>,
    right: Option<TreeNodeCell>,
}

impl TreeNode {
    fn new(start: usize, end: usize) -> TreeNodeCell {
        Rc::new(RefCell::new(TreeNode {
            start,
            end,
            
            ..Default::default()
        }))
    }
    
    fn build_tree(xs: &Vec<i32>, start: usize, end: usize) -> Option<TreeNodeCell> {
        if end < start {
            return None;
        }
        
        let root = TreeNode::new(start, end);
        {

            // return will occur after this "if"
            if start == end {
                // this is a leaf node
                root.borrow_mut().value = *xs.get(start).unwrap_or(&0);
            } else if start < end {

                // build children first and then add the sum
                let mid = (start + end) / 2;

                root.borrow_mut().left = TreeNode::build_tree(xs, start, mid);
                root.borrow_mut().right = TreeNode::build_tree(xs, mid + 1, end);
                
                let mut sum = 0;
                
                if let Some(left_rc) = root.clone().borrow().left.as_ref() {
                    sum += left_rc.borrow().value; 
                }

                if let Some(right_rc) = root.clone().borrow().right.as_ref() {
                    sum += right_rc.borrow().value; 
                }
                
                root.borrow_mut().value = sum;
            }
        }
        
        Some(root)
    }
    

    fn update(&mut self, i: usize, val: i32) {
        if self.start <= i && i <= self.end {
            // do something
            if self.start == self.end {
                self.value = val;
            } else {
                let mid = (self.start + self.end) / 2;
                
                if mid + 1 <= i {
                    // only interested in the right child
                    self.right.as_mut().map(|rc_node| rc_node.borrow_mut().update(i, val)); 
                } else if i <= mid {
                    // only interested in the left child
                    self.left.as_mut().map(|rc_node| rc_node.borrow_mut().update(i, val)); 
                } else {
                    // update both children
                    self.right.as_mut().map(|rc_node| rc_node.borrow_mut().update(i, val)); 
                    self.left.as_mut().map(|rc_node| rc_node.borrow_mut().update(i, val)); 
                }
                
                // after updating children, now it's time to update self
                self.value = 0; 
                
                if let Some(rc_left) = self.left.as_ref() {
                    self.value += rc_left.borrow().value;
                }
                
                if let Some(rc_right) = self.right.as_ref() {
                    self.value += rc_right.borrow().value;
                }
            }
        }    
    }
    
    fn sum_range(&self, i: usize, j: usize) -> i32 {
        if i <= self.start && self.end <= j {
            return self.value;
        } else {
            // valid
            let mid = (self.start + self.end) / 2;
            
            if mid + 1 <= i {
                return self.right.as_ref().map(|rc| rc.borrow().sum_range(i, j)).unwrap_or(0);    
            } else if j <= mid {
                return self.left.as_ref().map(|rc| rc.borrow().sum_range(i, j)).unwrap_or(0);
            } else {
                let mut sum = 0;
                
                if let Some(right_rc) =  self.right.as_ref() {
                    sum += right_rc.borrow().sum_range(i, j)
                }
                
                if let Some(left_rc) = self.left.as_ref() {
                    sum += left_rc.borrow().sum_range(i, j);
                }
                
                return sum;
            }
        } 
    }
}

struct NumArray {
    head: Option<TreeNodeCell>
}

impl NumArray {
    fn new(nums: Vec<i32>) -> Self {
        NumArray {
            head: if nums.is_empty() { None } else { TreeNode::build_tree(&nums, 0, nums.len() - 1) }
        }
    }
    
    fn update(&mut self, i: i32, val: i32) {
        self.head.as_mut().map(|rc_node| rc_node.borrow_mut().update(i as usize, val));
    }
    
    fn sum_range(&self, i: i32, j: i32) -> i32 {
        self.head.as_ref().map(|rc_node| rc_node.borrow().sum_range(i as usize, j as usize)).unwrap_or(0)
    }
}