// https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solutions/3346913/rust/
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn lowest_common_ancestor(root: Option<Rc<RefCell<TreeNode>>>, p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        let mut cur = root.clone();
        let (p_val, q_val) = (p.unwrap().borrow().val, q.unwrap().borrow().val);
        let min_val = p_val.min(q_val);
        let max_val = p_val.max(q_val);
        while let Some(node) = cur.clone() {
            let node = node.borrow();
            if node.val < min_val {
                cur = node.right.clone();
            } else if node.val > max_val {
                cur = node.left.clone();
            } else {
                return cur
            }
        }
        None
    }
}