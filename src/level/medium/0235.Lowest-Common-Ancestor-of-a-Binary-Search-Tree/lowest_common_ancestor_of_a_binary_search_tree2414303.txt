// https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solutions/2414303/rust-recursive/
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn lowest_common_ancestor(root: Option<Rc<RefCell<TreeNode>>>, p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        if let Some(r) = root.clone() {
            let ro = r.as_ref().borrow();
            let pval = Rc::clone(&p.unwrap());
            let qval = Rc::clone(&q.unwrap());
            if ro.val == pval.as_ref().borrow().val || ro.val == qval.as_ref().borrow().val {
                return root;
            }
            
            let left = Self::lowest_common_ancestor(ro.left.clone(), Some(Rc::clone(&pval)), Some(Rc::clone(&qval)));
            let right = Self::lowest_common_ancestor(ro.right.clone(), Some(Rc::clone(&pval)), Some(Rc::clone(&qval)));
            
            if left.is_some() && right.is_some() {
                return root;
            }
            
            if left.is_some() {
                return left;
            } else {
                return right;
            }
        }
        None
    }
}