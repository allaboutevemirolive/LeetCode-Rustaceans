// https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solutions/1080803/rust-iterative-solution/
use std::rc::Rc;
use std::cell::RefCell;

type Node = Rc<RefCell<TreeNode>>;

impl Solution {
    pub fn lowest_common_ancestor(mut root: Option<Node>, a: Option<Node>, b: Option<Node>) -> Option<Node> {
        match (a,b) {
            (Some(a), Some(b)) => {
                let (a,b) = (a.borrow(), b.borrow());
                while let Some(node) = root.clone() {
                    let node = node.borrow();
                    if i32::max(a.val,b.val) < node.val {root = node.left.clone();}
                    else if i32::min(a.val, b.val) > node.val {root = node.right.clone();}
                    else { return root; }
                }
                None        
            }
            _ => None
        }
    }
}