// https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solutions/2099452/rust-recursive-100/
use std::rc::Rc;
use std::cell::RefCell;
pub fn recurse(
    root: &Option<Rc<RefCell<TreeNode>>>,
    p: i32,
    q: i32,
) -> Option<Rc<RefCell<TreeNode>>> {
    if let Some(v) = root {
        if let (Some(ref left), Some(ref right)) =
            (&v.borrow().left, &v.borrow().right)
        {
            let node_val = v.borrow().val;
            if p > node_val && q > node_val {
                // Recurse right
                let right = Some(Rc::clone(right));
                return recurse(&right, p, q);
            } else if p < node_val && q < node_val {
                // Recurse left
                let left = Some(Rc::clone(left));
                return recurse(&left, p, q);
            }
        }
        // This is the lowest common ancestor
        return Some(Rc::new(RefCell::new(TreeNode::new(v.borrow().val))));
    } else {
        return None;
    }
}

impl Solution {
	pub fn lowest_common_ancestor(
		root: Option<Rc<RefCell<TreeNode>>>,
		p: Option<Rc<RefCell<TreeNode>>>,
		q: Option<Rc<RefCell<TreeNode>>>,
	) -> Option<Rc<RefCell<TreeNode>>> {
		if p.is_none() || q.is_none() || root.is_none() {
			return root;
		}

		let p_val = p.unwrap().borrow_mut().val;
		let q_val = q.unwrap().borrow_mut().val;
		return recurse(&root, p_val, q_val);
	}
}