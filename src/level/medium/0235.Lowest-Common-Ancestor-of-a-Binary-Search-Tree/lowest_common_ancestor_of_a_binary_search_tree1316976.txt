// https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solutions/1316976/rust-recursive/
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    fn helper(root: Option<&Rc<RefCell<TreeNode>>>, p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        match root {
            None => None,
            Some(node) => {
                let left = Self::helper(node.clone().borrow().left.as_ref(), p.clone(), q.clone());
                let right = Self::helper(node.clone().borrow().right.as_ref(), p.clone(), q.clone());
                if let Some(l) = left.clone() {
                    if let Some(r) = right.clone() {
                        return Some(node.clone());
                    }
                }
                if node.clone().borrow().val < p.clone().unwrap().borrow().val && node.clone().borrow().val < q.clone().unwrap().borrow().val {
                    return right;
                } else if node.clone().borrow().val > p.clone().unwrap().borrow().val && node.clone().borrow().val > q.clone().unwrap().borrow().val {
                    return left;
                } else {
                    return Some(node.clone());
                }
            },
        }
    }
    pub fn lowest_common_ancestor(root: Option<Rc<RefCell<TreeNode>>>, p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        Self::helper(root.as_ref(), p, q)
    }
}