// https://leetcode.com/problems/implement-trie-prefix-tree/solutions/2165513/rust-trie-with-hashmaps/

use std::collections::HashMap;

#[derive(Debug)]
struct Node(HashMap<char, Node>, bool);

#[derive(Debug)]
struct Trie {
    root: HashMap<char, Node>
}

impl Trie {

    fn new() -> Self {
        Self{
            root: HashMap::new()
        }
    }
    
    fn insert(&mut self, word: String) {
        let mut curr = &mut self.root;
        let len = word.len();
        let w = word.clone();
        
        for (i, c) in word.chars().enumerate(){
            
            if !curr.contains_key(&c){
                curr.insert(c, Node(HashMap::new(), i == len - 1));
            }else{
                if i == len - 1{
                    curr.get_mut(&c).unwrap().1 = true;
                }
            }
            curr = &mut curr.get_mut(&c).unwrap().0;
        }
        
    }
    
    fn search(&self, word: String) -> bool {
        let mut tuple = (&self.root, false);
        
        for c in word.chars(){
            if !tuple.0.contains_key(&c){
                return false;
            }
            let ref_tuple = &tuple.0.get(&c).unwrap();
            tuple = (&ref_tuple.0, ref_tuple.1);
        }
        
        return tuple.1;
    }
    
    fn starts_with(&self, prefix: String) -> bool {
        let mut map = &self.data;
        
        for c in prefix.chars(){
            if !map.contains_key(&c){
                return false;
            }
            let ref_map = &map.get(&c).unwrap();
            map = &ref_map.0;
        }
        
        return true;
    }
}
