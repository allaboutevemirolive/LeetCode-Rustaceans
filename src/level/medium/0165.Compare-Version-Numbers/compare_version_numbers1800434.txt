// https://leetcode.com/problems/compare-version-numbers/solutions/1800434/0ms-blazing-fast-well-structured-solution-in-rust/

// 'a is the lifetime specifier - specifying to rust compiler that an instance is valid 
// as long as all lifetimes  are in scope (removing danling pointer issues)
#[derive(Debug)]
struct Version<'a> {
  // original version string slice
  data: &'a str,
  // iterator over characters in the string slice
  chars: std::str::Chars<'a>,
  // current index in the slice
  index: usize,
}

// funcitons defined on Version struct
impl<'a> Version<'a> {
  // constructor
  fn new(data: &'a str) -> Self {
    let chars = data.chars();
    Version {
      data,
      chars,
      index: 0,
    }
  }

  // Get the next version. We convert the sequence of digits into a number till we hit a period '.'
  fn next(&mut self) -> i32 {
    let mut digit = 0;

	// Here we use pattern matching - iterator can return None but we continue only if it returns Some.
    while let Some(c) = self.chars.next() {
      self.index += 1;
      if c == '.' {
        break;
      }
	  // Add the current digit in the ones place
      digit = digit * 10 + (c as i32 - '0' as i32);
    }

    return digit;
  }

 // are all subversion processed? If the current index < number of characters we can still get a subversion
  fn has_next(&self) -> bool {
    return self.index < self.data.len();
  }
}