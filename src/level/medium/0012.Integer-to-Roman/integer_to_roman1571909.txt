// https://leetcode.com/problems/integer-to-roman/solutions/1571909/rust-elegant-match-solution/
impl Solution {
    pub fn int_to_roman(mut num: i32) -> String {
        let mut buf = Vec::new();
        let mut level = 0;
        while num > 0 {
            let digit = num % 10;
            Self::digit_to_roman(digit, level, &mut buf);
            num = num / 10;
            level += 1;
        }

        buf.reverse();
        unsafe { String::from_utf8_unchecked(buf) }
    }

    fn digit_to_roman(digit: i32, level: usize, buf: &mut Vec<u8>) {
        let ones = ['I' as u8, 'X' as u8, 'C' as u8, 'M' as u8];
        let fives = ['V' as u8, 'L' as u8, 'D' as u8];

        match digit {
            4 => {
                buf.push(fives[level]);
                buf.push(ones[level]);
            }
            9 => {
                buf.push(ones[level + 1]);
                buf.push(ones[level]);
            }
            1..=3 => {
                for _ in (0..digit).rev() {
                    buf.push(ones[level]);
                }
            }

            5..=8 => {
                for _ in (0..digit - 5).rev() {
                    buf.push(ones[level]);
                }
                buf.push(fives[level]);
            }
            0 => {}

            _ => unreachable!(),
        }
    }
}