// https://leetcode.com/problems/path-sum-iii/solutions/2861251/rust-prefix-sum-hashmap-backtrack-128th-test-case-passed/
use std::rc::Rc;
use std::cell::RefCell;
use std::collections::HashMap;

impl Solution {
    pub fn path_sum(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> i32 {
        fn path_sum_helper(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32, curr_sum: i32, prefix_sum: &mut HashMap<i32, i32>, result: &mut i32) {
            if let Some(node) = root {
                let val = node.borrow().val;

                // NOTE: check overflow in arithmetic addition
                // If overflow happens, all previous paths are invalid
                let curr = {
                    if let Some(n) = curr_sum.checked_add(val) {
                        // Update prefix sum
                        curr_sum + val
                    } else {
                        // Reset HashMap
                        prefix_sum.clear();
                        prefix_sum.insert(0, 1);
                        val
                    }
                };

                let prev = curr - target_sum;

                if let Some(num) = prefix_sum.get(&prev) {
                    *result += num;
                }

                prefix_sum.entry(curr).and_modify(|e|*e += 1).or_insert(1);

                path_sum_helper(node.borrow_mut().left.take(), target_sum, curr, prefix_sum, result);
                path_sum_helper(node.borrow_mut().right.take(), target_sum, curr, prefix_sum, result);

                prefix_sum.entry(curr).and_modify(|e|*e -= 1);
            }
        }

        let mut result = 0;
        let mut prefix_sum = HashMap::new();

        prefix_sum.insert(0, 1);
        path_sum_helper(root, target_sum, 0, &mut prefix_sum, &mut result);

        result
    }