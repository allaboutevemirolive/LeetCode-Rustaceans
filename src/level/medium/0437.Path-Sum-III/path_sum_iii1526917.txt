// https://leetcode.com/problems/path-sum-iii/solutions/1526917/rust-0ms-with-some-optimization/
impl Solution {
    fn dfs(data: &mut Vec<(i64, i32)>, root: &Option<Rc<RefCell<TreeNode>>>, target_sum: i64) -> i32 {
        let rc = root.as_ref().unwrap();
        let node = rc.borrow();
        let val = node.val as i64;
        // we need to know whether we add the count of self to existing node
        let mut is_reuse = false;
        let mut result = 0;

        for pair in data.into_iter() {
            let sum = pair.0;
            if sum == 0 {
                // we should only reuse once, otherwise something already went wrong
                // assert!(!is_reuse);
                // add itself
                pair.1 += 1;
                is_reuse = true;
            }
            pair.0 += val;
            if pair.0 == target_sum {
                result += pair.1;
            }
        }
        if !is_reuse {
            // push the val as normal dfs solution do
            data.push((val, 1));
            if val == target_sum {
                result += 1;
            }
        }

        // check in advance and try to save the time of function call
        if let Some(_) = node.left {
            result += Solution::dfs(data, &node.left, target_sum);
        }
        if let Some(_) = node.right {
            result += Solution::dfs(data, &node.right, target_sum);
        }

        // pop the node if we pushed it
        if !is_reuse {
            data.pop();
        }
        for pair in data.into_iter() {
            let sum = pair.0;
            if sum == val && is_reuse {
                // remove the count of itself
                pair.1 -= 1;
            }
            pair.0 -= val;
        }

        result
    }
    pub fn path_sum(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> i32 {
        // data stores (prev_sum, total count of prev_sum)
        let mut data = vec![];
        if let None = root {
            return 0;
        }
        Solution::dfs(&mut data, &root, target_sum as i64)
    }
}