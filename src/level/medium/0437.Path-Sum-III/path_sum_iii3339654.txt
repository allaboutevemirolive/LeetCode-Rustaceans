// https://leetcode.com/problems/path-sum-iii/solutions/3339654/rust-2-approaches/
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn path_sum(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> i32 {
        fn optimized_approach(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> i32 {
            fn dfs(
                root: Option<Rc<RefCell<TreeNode>>>,
                cur_path: &mut Vec<i64>,
                cur_sum: i64,
                target_sum: i64,
                path_count: &mut i32,
            ) {
                if let Some(r) = root {
                    let r = r.as_ref().borrow();
                    cur_path.push(r.val as i64);
                    let mut total_sum = cur_sum + r.val as i64;
                    if total_sum == target_sum {
                        *path_count += 1;
                    }
                    for i in 0..cur_path.len() - 1 {
                        total_sum -= cur_path[i];
                        if total_sum == target_sum {
                            *path_count += 1;
                        }
                    }
                    dfs(
                        r.left.clone(),
                        cur_path,
                        cur_sum + r.val as i64,
                        target_sum,
                        path_count,
                    );
                    dfs(
                        r.right.clone(),
                        cur_path,
                        cur_sum + r.val as i64,
                        target_sum,
                        path_count,
                    );
                    cur_path.pop();
                }
            }
            let mut cur_path = vec![];
            let mut path_count = 0;
            dfs(root, &mut cur_path, 0, target_sum as i64, &mut path_count);
            path_count
        }
        fn brute_force_approach(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> i32 {
            if root.is_none() {
                return 0;
            }
            fn dfs(
                root: Option<Rc<RefCell<TreeNode>>>,
                cur_sum: i64,
                target_sum: i64,
                path_count: &mut i32,
            ) {
                if let Some(r) = root {
                    let r = r.as_ref().borrow();
                    let sum = cur_sum + r.val as i64;
                    if sum == target_sum {
                        *path_count += 1;
                    }
                    dfs(r.left.clone(), sum, target_sum, path_count);
                    dfs(r.right.clone(), sum, target_sum, path_count);
                }
            }
            let mut path_count = 0;
            dfs(root.clone(), 0, target_sum as i64, &mut path_count);
            path_count += brute_force_approach(
                root.clone().and_then(|x| x.as_ref().borrow().left.clone()),
                target_sum,
            );
            path_count += brute_force_approach(
                root.and_then(|x| x.as_ref().borrow().right.clone()),
                target_sum,
            );
            path_count
        }
        brute_force_approach(root, target_sum)   
    }
}