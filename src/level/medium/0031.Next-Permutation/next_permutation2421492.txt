// https://leetcode.com/problems/next-permutation/solutions/2421492/idiomatic-rust-solution-with-comments/
struct Solution;

impl Solution {
    pub fn next_permutation(nums: &mut Vec<i32>) {
        let length = nums.len();
        
        // find the first element that is smaller than its next element
        let firstdec = (1 .. length)
                        .rev()
                        .find(|&i| nums[i - 1] < nums[i]);

       //println!("{:?}", firstdec);

       match firstdec {
           Some(firstdec) => {
               // among elements satisfying index >= firstdec, find the smallest one that is larger than nums[firstdec - 1]
               let j = (firstdec..length).fold(firstdec, |acc, i| {
                   if nums[i] <= nums[acc] && nums[i] > nums[firstdec - 1] {
                       i
                   } else {
                       acc
                   }
               });
               // swap nums[firstdec - 1] and nums[j]
               let tmp = nums[firstdec - 1];
               nums[firstdec - 1] = nums[j];
               nums[j] = tmp;
               // reverse the elements from firstdec to the end
               nums[firstdec .. length].reverse();
           }
           None => {
               nums.reverse();
           }
       }
    }
}

fn main() {
    let mut v = vec![1,2,3];
    for _ in 1..7 {
        Solution::next_permutation(&mut v);
        println!("{:?}", v);
    }
}