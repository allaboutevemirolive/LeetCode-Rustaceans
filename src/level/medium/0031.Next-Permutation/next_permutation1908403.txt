// https://leetcode.com/problems/next-permutation/solutions/1908403/rust-one-pass-solution-100-faster-explained/
impl Solution {
    pub fn next_permutation(nums: &mut Vec<i32>) {
        // These cases only have 1 permutation each, so we can't do anything.
        if nums.len() < 2 {
            return;
        }

        // Step 1: Identify the longest, rightmost weakly decreasing part of the vector
        let mut i = nums.len() - 1;
        while i > 0 && nums[i - 1] >= nums[i] {
            i -= 1;
        }

        // If that is the entire vector, this is the last-ordered permutation.
        if i == 0 {
            nums.reverse();
            return;
        }

        // Step 2: Find the rightmost element larger than the pivot (i-1)
        let mut j = nums.len() - 1;
        while j >= i && nums[j] <= nums[i - 1] {
            j -= 1;
        }

        // Step 3: Swap that element with the pivot
        nums.swap(j, i - 1);

        // Step 4: Reverse the (previously) weakly decreasing part
        nums[i..].reverse();
    }
}