// https://leetcode.com/problems/utf-8-validation/solutions/2570191/rust-functional-state-machine-with-comments/
#[derive(Clone, Copy, PartialEq)]
enum State {
    ExpectingHeader,
    ExpectingOne,
    ExpectingTwo,
    ExpectingThree,
    Error,
    Invalid,
}

impl Solution {
    pub fn valid_utf8(data: Vec<i32>) -> bool {
        data.into_iter().map(|i| (i as u8).leading_ones()).scan(State::ExpectingHeader, |state, lo| {
            *state = match (*state, lo) {
                (State::ExpectingHeader, 0) => State::ExpectingHeader,
                (State::ExpectingHeader, 2) => State::ExpectingOne,
                (State::ExpectingHeader, 3) => State::ExpectingTwo,
                (State::ExpectingHeader, 4) => State::ExpectingThree,
                (State::ExpectingOne, 1) => State::ExpectingHeader,
                (State::ExpectingTwo, 1) => State::ExpectingOne,
                (State::ExpectingThree, 1) => State::ExpectingTwo,
                (State::Error, _) => State::Invalid,
                _ => State::Error,

            };
            if *state == State::Invalid { None } else { Some(*state) }
        }).map(|state| state == State::ExpectingHeader).last().unwrap_or(true)
    }
}