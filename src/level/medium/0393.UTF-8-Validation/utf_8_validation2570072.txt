// https://leetcode.com/problems/utf-8-validation/solutions/2570072/rust-idiomatic-solution-100-runtime/
impl Solution {
    const M: [(u8, u8); 5] = [
        (0b11000000, 0b10000000),
        (0b10000000, 0b00000000),
        (0b11100000, 0b11000000),
        (0b11110000, 0b11100000),
        (0b11111000, 0b11110000),
    ];

    fn check(data: &[i32]) -> bool {
        let (mask, key) = M[data.len()];
        let head_matches = data[0].to_le_bytes()[0] & mask ^ key == 0;

        let (mask, key) = M[0];
        let tail_matches = data[1..]
            .iter()
            .all(|n| n.to_le_bytes()[0] & mask ^ key == 0);
        head_matches && tail_matches
    }

    pub fn valid_utf8(data: Vec<i32>) -> bool {
        let mut data = data.as_slice();

        while !data.is_empty() {
            match (1..=4.min(data.len()))
                .into_iter()
                .find(|&l| Self::check(&data[..l]))
            {
                Some(l) => data = &data[l..],
                None => return false,
            }
        }
        true
    }
}