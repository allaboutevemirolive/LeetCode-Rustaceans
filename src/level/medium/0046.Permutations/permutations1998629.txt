// https://leetcode.com/problems/permutations/solutions/1998629/rust-backtracking-two-solutions/
impl Solution {
    
    fn backtrack(nums: &mut Vec<i32>, rez: &mut Vec<Vec<i32>>, first: usize, mut next_rez: usize) -> usize {
        let n = nums.len();

        if first == n {
            rez[next_rez].copy_from_slice(&nums);
            next_rez + 1
        } else {
            for i in first..n {
                nums.swap(first, i);
                next_rez = Self::backtrack(nums, rez, first + 1, next_rez);
                nums.swap(first, i);
            }
            next_rez
        }
    }
    
    pub fn permute(mut nums: Vec<i32>) -> Vec<Vec<i32>> {
        let n = nums.len();
        let factorial = |n| (1..=n as u64).fold(1, |acc, x| acc*x) as usize;
        let mut rez = vec![vec![0; n]; factorial(n)];

        Self::backtrack(&mut nums, &mut rez, 0, 0);

        rez
    }
}