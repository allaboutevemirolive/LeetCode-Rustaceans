// https://leetcode.com/problems/binary-tree-level-order-traversal-ii/solutions/275591/my-rust-solution-0ms/
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn level_order_bottom(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {
        if root.is_none() {
            return vec![];
        }

        let mut v = vec![vec![root.unwrap().clone()]];

        loop {
            let level = v.last()
                         .unwrap()
                         .iter()
                         .map(|node| {
                             let node = node.borrow();
                             vec![node.left.clone(), node.right.clone()]
                          })
                         .flatten()
                         .filter_map(|node| node)
                         .collect::<Vec<_>>();

            if level.len() == 0 {
                break;
            } else {
                v.push(level);
            }
        }

        v.iter()
         .rev()
         .map(|level| {
             level.iter()
                  .map(|node| node.borrow().val)
                  .collect::<Vec<_>>()
          })
         .collect::<Vec<_>>()
    }
}