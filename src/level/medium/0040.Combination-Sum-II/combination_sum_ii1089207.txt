// https://leetcode.com/problems/combination-sum-ii/solutions/1089207/rust-backtracking-solution/
impl Solution {
    pub fn combination_sum2(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        fn backtrack(sub: &[i32], candidates: &[i32], target: i32, res: &mut Vec<Vec<i32>>) {
            let sum = sub.iter().sum::<i32>();
            if sum == target {
                res.push(sub.to_vec());
                return;
            } else if sum > target {
                return;
            }
            
            for (i, v) in candidates.iter().enumerate() {
                if i > 0 && candidates[i - 1] == *v {
                    continue;
                }
                let mut s = sub.to_vec();
                s.push(*v);
                backtrack(&s, &candidates[i + 1..], target, res);
            }
        }
        let mut candidates = candidates;
        candidates.sort();
        let mut res: Vec<Vec<i32>> = vec![];
        backtrack(&vec![], &candidates, target, &mut res);
        res
    }
}