// https://leetcode.com/problems/combination-sum-ii/solutions/3160820/rust-solution/
use std::collections::HashSet;

impl Solution {
    pub fn comn(candidates : & Vec<i32>,target : i32,ans : &mut Vec<Vec<i32>>,temp : &mut Vec<i32>,mut index : usize) {
    
        if target == 0 {
            if(!ans.contains(&temp.to_vec())){
                ans.push(temp.clone());
            }
            return ;
        }
        if index == candidates.len() || target < 0 {
            return;
        }
        let i = index;
        while index < candidates.len() {
            if index > i && candidates[index-1] == candidates[index] {
                index += 1;
                continue;
            }
            temp.push(candidates[index]);
            Self::comn(candidates,target - candidates[index],ans,temp, index + 1 );
            temp.pop();
            index += 1;
        }
    }


    pub fn combination_sum2(mut candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        candidates.sort();

        let mut ans : Vec<Vec<i32>> = Vec::new();
        let mut res : Vec<i32> = vec![];

        Self::comn( & candidates, target , &mut ans, &mut res,0);
        // let mut finalAns : Vec<Vec<i32>> = vec![];
        // for x in &ans {
        //     finalAns.push(x.to_vec());
        // }

        
        ans

    }
}   