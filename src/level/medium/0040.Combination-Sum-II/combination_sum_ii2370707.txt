// https://leetcode.com/problems/combination-sum-ii/solutions/2370707/rust-0ms-backtracking/
impl Solution {
    pub fn combination_sum2(mut candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        candidates.sort();
        let mut perms = Vec::new();
        let mut temp  = Vec::new();
        let mut visited = vec![false; candidates.len()];
        Self::perm(&mut perms, &mut temp, &candidates, &mut visited, target, 0, 0);
        perms
    }
    
    pub fn perm(res: &mut Vec<Vec<i32>>, temp: &mut Vec<i32>, nums: &Vec<i32>, visited: &mut Vec<bool>, target: i32, start: usize, mut sum: i32) {
        if sum > target {
            return;   
        }
        if sum == target{
            res.push(temp.to_vec());
        }
        
        for n in start..nums.len() {
            if visited[n] || n > 0 && nums[n] == nums[n-1] && !visited[n-1] {
                continue;
            }
            temp.push(nums[n]);
            sum += nums[n];
            visited[n] = true;
            Self::perm(res, temp, nums, visited, target, n, sum);
            temp.pop();
            visited[n] = false;
            sum -= nums[n];
        }
    }
}