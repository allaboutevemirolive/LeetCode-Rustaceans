// https://leetcode.com/problems/combination-sum-ii/solutions/2130642/rust-recursive-dfs/
use std::collections::HashMap;

impl Solution {
    fn dfs(bins: &[(i32, usize)], target: i32, i: usize, n: usize, curr: &mut Vec<i32>, sum: i32, mut rez: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        if sum == target {
            // Found a combination that has the target sum - add to result
            rez.push(curr.clone());
        } else if sum < target && i < n {
            // DFS for combinations without this candidate
            rez = Self::dfs(bins, target, i + 1, n, curr, sum, rez);
            let candidate = bins[i].0;
            let mut new_sum = sum;
            let old_curr_len = curr.len();
            // DFS with instances of current candidate appended
            for _ in 0..bins[i].1 {
                new_sum += candidate;
                if new_sum > target {
                    break;
                }
                curr.push(candidate);
                rez = Self::dfs(bins, target, i + 1, n, curr, new_sum, rez);
            }
            // Backtrack by resizing curr down to initial length
            curr.resize(old_curr_len, 0);
        }
        rez
    }

    pub fn combination_sum2(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        // Create histogram of candidates
        let bins = candidates
            .into_iter()
            .fold(HashMap::<i32, usize>::new(), |mut map, c| {
                *map.entry(c).or_default() += 1;
                map
            })
            .into_iter()
            .collect::<Vec<_>>();
        Self::dfs(&bins, target, 0, bins.len(), &mut vec![], 0, vec![])
    }
}