// https://leetcode.com/problems/queue-reconstruction-by-height/solutions/2352842/rust-easy-to-read-segment-tree/
impl Solution {
    pub fn reconstruct_queue(people: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let n = people.len();
        let mut tree: Vec<i32> = vec![0; 4 * n];
        for i in 1..n {
            Self::add(1, 0, n - 1, i, 1, &mut tree);
        }
        
        let mut people = people;
        people.sort_by(|a, b| { if a[0] == b[0] {return b[1].cmp(&a[1]) } a[0].cmp(&b[0]) } );
        
        let mut ret: Vec<Vec<i32>> = vec![vec![]; n]; 
        for p in people {
            let i = Self::find(1, 0, n - 1, p[1], &tree);
            ret[i] = p;
            Self::add(1, 0, n - 1, i, -1, &mut tree);
        }
        
        ret
    }
    
    fn add(u: usize, left: usize, right: usize, i: usize, val: i32, tree: &mut Vec<i32>) {
        tree[u] += val;
        if left == right { return }
        
        let mid = left + (right - left) / 2;
        if i <= mid { 
            Self::add(2 * u, left, mid, i, val, tree); 
        } else { 
            Self::add(2 * u + 1, mid + 1, right, i, val, tree); 
        }
    }
    
    fn find(u: usize, left: usize, right: usize, val: i32, tree: &Vec<i32>) -> usize {
        if left == right { return left }
    
        let mid = left + (right - left) / 2;
        if tree[2 * u] >= val { 
            return Self::find(2 * u, left, mid, val, tree) 
        } 
        
        Self::find(2 * u + 1, mid + 1, right, val - tree[2 * u], tree) 
    }
}