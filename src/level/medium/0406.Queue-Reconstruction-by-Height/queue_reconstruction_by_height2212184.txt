// https://leetcode.com/problems/queue-reconstruction-by-height/solutions/2212184/rust-o-nlogn-with-segment-tree/
// Used for getting the index to insert elements
struct IndexSegmentTree {
    size: usize, // size of ans Vec which elements are inserted into 
    start: usize, // the index in tree which is the leftmost leaf vertex
    tree: Vec<usize>, // initially contains 1 for all leaf vertices, and the subrange sums
}

impl IndexSegmentTree {
    fn new(size: usize) -> Self {
        let start = (1 << ((size as f32).log2().ceil() as usize)) - 1;
        let mut tree = vec![1; 2 * size - 1];
        for i in (0..size - 1).rev() {
            tree[i] = tree[2 * i + 1] + tree[2 * i + 2]; 
        }
        Self {
            size,
            start,
            tree,
        }
    }
	
	// mark one index of ans Vec from 1 to 0 (inserted)
    fn remove(&mut self, i: usize) {
        let mut j = i + self.start;
        if j >= self.tree.len() {
            j -= self.size;
        }
        while j > 0 {
            self.tree[j] -= 1;
            j = (j - 1) / 2;
        }
        self.tree[0] -= 1;
    }

	// given i = i-th(zero based) uninserted slot, find the actual index in the ans Vec
    fn find(&self, i: usize) -> usize {
        let mut i = i + 1;
        let mut j = 0;
        while j < self.tree.len() - self.size {
            if self.tree[j * 2 + 1] >= i {
                j = j * 2 + 1;
            }
            else {
                i -= self.tree[j * 2 + 1];
                j = j * 2 + 2;
            }
        }
        if j < self.start {
            j += self.size;
        }
        j - self.start
    }
}

impl Solution {
    pub fn reconstruct_queue(mut people: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let mut ans = vec![Vec::new(); people.len()];
        people.sort_unstable_by_key(|v| (v[0], -v[1]));
        let mut seg_tree = IndexSegmentTree::new(people.len());
        for v in people.iter() {
            let i = seg_tree.find(v[1] as usize);
            ans[i] = v.clone();
            seg_tree.remove(i);
        }
        ans
    }
}