// https://leetcode.com/problems/queue-reconstruction-by-height/solutions/2213413/rust-o-n-2-with-comments/
impl Solution {
    pub fn reconstruct_queue(mut people: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let n = people.len();
        // Sort people by increasing height (h), and by decreasing rank (k)
        people.sort_unstable_by_key(|p| (p[0], -p[1]));
        // Allocate output. Elements are constructed with 0 capacity to
        // avoid unnecessary heap allocations, as these elements will
        // be replaced by the moved elements from people.
        let mut rez = vec![Vec::<i32>::with_capacity(0); n];
        // We are inserting people from the sorted people vector. That
        // means that every person inserted must have k empty spaces before
        // them when they are inserted, as these places will later be filled
        // by k people who are equally tall or taller than themselves.
        for p in people {
            // Count the number of empty places until we find the
            // correct place for this person.
            let mut n_empty = 0;
            for i in 0..n {
                if rez[i].is_empty() {
                    if n_empty == p[1] {
                        rez[i] = p;
                        break;
                    } else {
                        n_empty += 1;
                    }
                }
            }
        }
        rez
    }
}