// https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2941422/rust-iteratively-modelling-recursion/
use std::collections::HashMap;

impl Solution {
    pub fn max_profit(prices: Vec<i32>) -> i32 {
        use Op::*;
        enum Op { 
            Call(usize, bool), 
            Decide(usize, bool), 
            Max(usize, i32, bool),
        }
        let mut memo = HashMap::new();
        let mut ret  = vec![];
        let mut exs  = vec![];

        exs.push(Call(0, true));

        while let Some(op) = exs.pop() {
            match op {
                Call(i, buying) => {
                    if i >= prices.len() {
                        ret.push(0);
                    } else if let Some(val) = memo.get(&(i, buying)) {
                        ret.push(*val);
                    } else {
                        exs.push(Decide(i, buying));
                        exs.push(Call(i + 1, buying));
                    }
                },
                Decide(i, buying) => {
                    let gain = ret.pop().unwrap();
                    exs.push(Max(i, gain, buying));
                    if buying { exs.push(Call(i + 1, !buying)); }
                    else      { exs.push(Call(i + 2, !buying)); }
                },
                Max(i, prior_gain, buying) => {
                    let mut gain = ret.pop().unwrap();
                    gain = prior_gain.max(
                        if buying { gain - prices[i] }
                        else      { gain + prices[i] }
                    );
                    memo.insert((i, buying), gain);
                    ret.push(gain);
                }
            }
        }
        ret.pop().unwrap()
    } 
}