// https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/solutions/2368399/rust-priority-queue-with-comments/
use std::collections::BinaryHeap;

impl Solution {
    pub fn kth_smallest(matrix: Vec<Vec<i32>>, k: i32) -> i32 {
        let n = matrix.len();
        // Build a min heap of the first matrix column.
        // Nicer to use iterators here rather than to manually push elements.
        // Reverse() is a bit verbose, so I am simply negating the matrix element.
        let mut heap = matrix
            .iter()
            .enumerate()
            .map(|(i, row)| (-*row.first().unwrap(), i, 0))
            .collect::<BinaryHeap<_>>();

        // Go through the k-1 smallest elements and replace
        // with next element on the same row if available.
        for _ in 1..k {
            let (_, i, j) = heap.pop().unwrap();
            if j + 1 < n {
                heap.push((-matrix[i][j + 1], i, j + 1));
            }
        }

        // Get the value of the sought element. No need to
        // pop, so just peek.
        -heap.peek().unwrap().0
    }
}