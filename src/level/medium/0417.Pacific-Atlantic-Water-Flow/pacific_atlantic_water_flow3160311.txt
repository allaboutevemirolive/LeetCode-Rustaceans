// https://leetcode.com/problems/pacific-atlantic-water-flow/solutions/3160311/rust-geeks/
impl Solution {
    const dirs: [[i32; 2]; 4] = [[1, 0], [-1, 0], [0, 1], [0, -1]];
    pub fn pacific_atlantic(heights: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let (n, m) = (heights.len() - 1, heights[0].len() - 1);

        let mut pac = vec![vec![(false, false); m + 1]; n + 1];
        let mut atl = vec![vec![(false, false); m + 1]; n + 1];

        for i in 0..=n {
            pac[i][0].0 = true;
            atl[i][m].0 = true;
        }
        for j in 0..=m {
            pac[0][j].0 = true;
            atl[n][j].0 = true;
        }

        Self::quantify((0, 0), &mut pac, &heights, 0);
        Self::quantify((0, m as i32), &mut atl, &heights, 0);

        let mut ans = Vec::new();
        for i in 0..=n {
            for j in 0..=m {
                if pac[i][j].0 && atl[i][j].0 {
                    let mut v = Vec::with_capacity(2);
                    v.push(i as i32);
                    v.push(j as i32);
                    ans.push(v);
                }
            }
        }

        ans
    }

    fn quantify(pos: (i32, i32), truth: &mut Vec<Vec<(bool, bool)>>, heights: &Vec<Vec<i32>>, prev: i32) {
        if pos.0 < 0 || pos.1 < 0 || pos.0 >= truth.len() as i32 || pos.1 >= truth[0].len() as i32 {
            return;
        }
        let (x, y) = (pos.0 as usize, pos.1 as usize);
        if truth[x][y].1 {
            return;
        }

        if !truth[x][y].0 && heights[x][y] < prev {
            return;
        }

        truth[x][y].1 = true;

        truth[x][y].0 = true;
        for dir in Self::dirs.iter() {
            Self::quantify(
                (pos.0 + dir[0], pos.1 + dir[1]),
                truth,
                heights,
                heights[x][y],
            );
        }
    }
}
