// https://leetcode.com/problems/pacific-atlantic-water-flow/solutions/2507484/rust-with-bit-flags/
const PAC_FLAG: u8 = 1;
const ATL_FLAG: u8 = 2;
const DIR: [i32; 5] = [0,1,0,-1,0];

impl Solution {
    pub fn pacific_atlantic(heights: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let m = heights.len();
        let n = heights[0].len();
        let mut dp = vec![vec![0; n]; m];
        for row in 0..m {
            Self::reverse_flow(PAC_FLAG, row, 0, &mut dp, &heights);
            Self::reverse_flow(ATL_FLAG, row, n - 1, &mut dp, &heights);
        }
        for col in 0..n {
            Self::reverse_flow(PAC_FLAG, 0, col, &mut dp, &heights);
            Self::reverse_flow(ATL_FLAG, m - 1, col, &mut dp, &heights);
        }
        let mut ans = Vec::new();
        for row in 0..m {
            for col in 0..n {
                if dp[row][col] & (PAC_FLAG | ATL_FLAG) == PAC_FLAG | ATL_FLAG {
                    ans.push(vec![row as i32, col as i32]);
                }
            }
        }
        ans
    }

    fn reverse_flow(flag: u8, row: usize, col: usize, dp: &mut Vec<Vec<u8>>, heights: &Vec<Vec<i32>>) {
        if dp[row][col] & flag == 0 {
            dp[row][col] |= flag;
            for win in DIR.windows(2) {
                let row2 = row as i32 + win[0];
                let col2 = col as i32 + win[1];
                if row2 >= 0 && row2 < dp.len() as i32
                && col2 >= 0 && col2 < dp[0].len() as i32
                && heights[row2 as usize][col2 as usize] >= heights[row][col] {
                    Self::reverse_flow(flag, row2 as usize, col2 as usize, dp, heights);
                }
            }
        }
    }
}