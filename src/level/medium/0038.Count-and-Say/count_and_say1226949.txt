// https://leetcode.com/problems/count-and-say/solutions/1226949/rust-solution/
impl Solution {
    pub fn count_and_say(n: i32) -> String {
        
        fn countnsay(n: i32) -> String {
            // input constraints in given problem are 1 <= n <= 30
            if n == 1 {
                return 1.to_string();
            }
            let n = countnsay(n - 1);
            let mut s = n.chars().fold(
                ("".to_string(), '&', 0),
                |(mut done, in_prog, count), char| {
                    match char == in_prog {
                        true => (done, in_prog, count + 1),
                        // Ampersand symbol used as a place filler for the first iteration.  There is no
                        // such thing as an empty char
                        false if in_prog != '&' => (format!("{}{}{}", done, count, in_prog), char, 1),
                        // The following is for first case situations
                        _ => (done, char, 1),
                    }
                },
            );
            format!("{}{}{}", s.0, s.2, s.1)
        }
        
        countnsay(n)
    }
}