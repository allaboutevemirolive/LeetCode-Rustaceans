// https://leetcode.com/problems/number-of-islands/solutions/1556965/rust-dfs/
impl Solution {
    fn dimensions(grid: &[Vec<char>]) -> (usize, usize) {
        let n_rows = grid.len();
        let n_cols = grid.get(0).map(|col| col.len()).unwrap_or(0);
        (n_rows, n_cols)
    }
    fn neighbours(
        point: (usize, usize),
        dimensions: (usize, usize),
    ) -> impl Iterator<Item = (usize, usize)> {
        let mut neighbours = Vec::new();
        if point.0 + 1 < dimensions.0 {
            neighbours.push((point.0 + 1, point.1));
        }
        if point.0 > 0 {
            neighbours.push((point.0 - 1, point.1));
        }
        if point.1 + 1 < dimensions.1 {
            neighbours.push((point.0, point.1 + 1));
        }
        if point.1 > 0 {
            neighbours.push((point.0, point.1 - 1));
        }
        neighbours.into_iter()
    }
    fn explore_island(row: usize, col: usize, grid: &mut Vec<Vec<char>>) {
        grid[row][col] = '0';
        for (row, col) in Self::neighbours((row, col), Self::dimensions(grid))
            .filter(|(row, col)| grid[*row][*col] == '1')
            .collect::<Vec<_>>()
            .into_iter()
        {
            Self::explore_island(row, col, grid);
        }
    }
    pub fn num_islands(mut grid: Vec<Vec<char>>) -> i32 {
        let (n_rows, n_cols) = Self::dimensions(&grid);
        (0..n_rows)
            .flat_map(move |row| {
                (0..n_cols)
                    .filter_map(|col| {
                        if grid[row][col] == '1' {
                            Self::explore_island(row, col, &mut grid);
                            Some(())
                        } else {
                            None
                        }
                    })
                    .collect::<Vec<_>>()
            })
            .count() as i32
    }
}