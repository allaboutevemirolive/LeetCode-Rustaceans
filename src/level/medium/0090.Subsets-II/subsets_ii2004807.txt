// https://leetcode.com/problems/subsets-ii/solutions/2004807/rust-backtracking/
fn backtrack(result: &mut Vec<Vec<i32>>, tmp: &mut Vec<i32>, nums: &Vec<i32>, start: usize) {
  result.push(tmp.to_vec());

  for i in start..nums.len() {
    if i > start && nums[i-1] == nums[i] {
      continue;
    }
    tmp.push(nums[i]);
    backtrack(result, tmp, nums, i+1);
    tmp.pop();
  }
}


impl Solution {
    pub fn subsets_with_dup(mut nums: Vec<i32>) -> Vec<Vec<i32>> {
        nums.sort_unstable();
        let mut result = vec![];
        let mut tmp = Vec::with_capacity(nums.len());
        backtrack(&mut result, &mut tmp, &nums, 0);
        result  
    }
}