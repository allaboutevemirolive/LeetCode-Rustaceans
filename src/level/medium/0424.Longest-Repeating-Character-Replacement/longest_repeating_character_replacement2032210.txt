// https://leetcode.com/problems/longest-repeating-character-replacement/solutions/2032210/intuitive-rust-solution-with-sliding-window/
use std::collections::HashMap;
use std::cmp::max;

impl Solution {
    pub fn character_replacement(s: String, k: i32) -> i32 {
        let mut l = 0;
        let mut longest_len = 0;
        let mut frequency: HashMap<char, usize> = HashMap::new();
        
        for r in 0..s.len() {
            let end = s.chars().nth(r).unwrap();
            *frequency.entry(end).or_insert(0) += 1;
            
            let max_frequency = frequency.values().max().unwrap();
            
			// If `window_length - max_frequency <= k`, there are 0 or more replacements
            // can be made so we can continue widen the window by incrementing `r`, and
            // update the longest length. Otherwise, slide the window by incrementing `l`.
            if r - l + 1 - max_frequency > k as usize {
                let start = s.chars().nth(l).unwrap();
				// update the frequency of the character that is about to move out of the 
                // window.
                *frequency.entry(start).or_default() -= 1;
                l += 1;
                
            }
            
            longest_len = max(r - l + 1, longest_len);   
        }
        
        longest_len as i32
    }
}
