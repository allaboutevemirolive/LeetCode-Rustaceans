// https://leetcode.com/problems/longest-repeating-character-replacement/solutions/925108/rust-4ms-sliding-window-o-n-runtime/
impl Solution {
    pub fn character_replacement(s: String, k: i32) -> i32 {
        match s.len() {
            0 | 1 => s.len() as i32,
            s_len => {
                let (mut start, mut end, s_bytes) = (0, 1, s.as_bytes());
                let mut max = 0;
                let mut helper = Helper::new();
                helper.inc(s_bytes[start]);
                loop {
                    helper.inc(s_bytes[end]);
                    while !helper.validate(k) {
                        helper.dec(s_bytes[start]);
                        start += 1;
                    }
                    
                    if max < helper.total {
                        max = helper.total;
                    }
                    
                    end += 1;
                    if end == s_len {
                        break max;
                    }
                }
            }
        }
    }
}

use std::collections::HashMap;
struct Helper {
    max: Option<u8>,
    max_total: i32,
    total: i32,
    map: HashMap::<u8, i32>,
}

impl Helper {
    fn new() -> Self {
        Self {
            max: None,
            max_total: 0,
            total: 0,
            map: HashMap::new(),
        }
    }
    
    fn inc(&mut self, key: u8) {
        let value = self.map.entry(key).or_default();
        *value += 1;
        
        self.total += 1;
        match self.max {
            None => self.find_max(),
            Some(m) if key != m => {
                if *value < self.max_total { return; }
                self.find_max();
            },
            _ => { self.max_total += 1 },
        }
        
    }
    
    fn find_max(&mut self) {
        if self.max_total > self.total / 2 {
            return;
        }
        
        if let Some((max, max_total)) = self.map.iter().fold(None, |acc, x| {
            match acc {
                None => Some(x),
                Some(cur) => {
                    if cur.1 < x.1 {
                        return Some(x)
                    } else {
                        return Some(cur)
                    }
                }
            }
        }) {
            self.max = Some(*max);
            self.max_total = *max_total;
        }
    }
    
    fn dec(&mut self, key: u8) {
        self.map.entry(key).and_modify(| e | *e -= 1);
        
        self.total -= 1;
        match self.max {
            None => self.find_max(),
            Some(m) if m == key => {
                self.max_total -= 1;
                self.find_max();
            }
            _ => {},
        }
    }
    
    fn validate(&self, k: i32) -> bool {
        self.total - self.max_total <= k
    }
}