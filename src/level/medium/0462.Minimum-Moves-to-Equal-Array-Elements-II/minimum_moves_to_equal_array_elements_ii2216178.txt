// https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/solutions/2216178/rust-sort-and-abs-diff/
impl Solution {
    pub fn min_moves2(mut nums: Vec<i32>) -> i32 {
        nums.sort_unstable();
        let mid = nums.len() / 2;
        let target = nums[mid];
		// If using std's abs_diff : n.abs_diff(target)
        nums.iter().map(|&n| abs_diff(n, target)).sum::<u32>() as i32
    }
}

// Copied from std - stable in Rust 1.60.0
pub const fn abs_diff(me: i32, other: i32) -> u32 {
    if me < other {
        // Converting a non-negative x from signed to unsigned by using
        // `x as U` is left unchanged, but a negative x is converted
        // to value x + 2^N. Thus if `s` and `o` are binary variables
        // respectively indicating whether `self` and `other` are
        // negative, we are computing the mathematical value:
        //
        //    (other + o*2^N) - (self + s*2^N)    mod  2^N
        //    other - self + (o-s)*2^N            mod  2^N
        //    other - self                        mod  2^N
        //
        // Finally, taking the mod 2^N of the mathematical value of
        // `other - self` does not change it as it already is
        // in the range [0, 2^N).
        (other as u32).wrapping_sub(me as u32)
    } else {
        (me as u32).wrapping_sub(other as u32)
    }
}