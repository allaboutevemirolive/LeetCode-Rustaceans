// https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/479332/rust-binary-search-annotated/
pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {
        Solution::search_inner(&nums, 0, nums.len() as i32 - 1, target)
        
    }
    
    fn search_inner(nums: &Vec<i32>, l: i32, r: i32, target: i32) -> Vec<i32> {
        if nums.len() == 0 || l > r {
            return vec![-1, -1];
        }

        let mid = l + (r - l) / 2; // avoid overflows rather than simply (l + r)/2

        match nums[mid as usize].cmp(&target) {
            Ordering::Less => return Solution::search_inner(nums, mid + 1, r, target),
            Ordering::Greater => return Solution::search_inner(nums, l, mid - 1, target),
            _ => {
                    let l = Solution::search_inner(nums, l, mid - 1, target); // if the midpoint has the target, search to the left of the midpoint for the first instance
                    let r = Solution::search_inner(nums, mid + 1, r, target); // if the midpoint has the target, search to the right of the midpoint for the last instance
                    match (l[0], r[1]) {
                        (-1, -1) => return vec!(mid, mid), // if no other instances are found then the first and last instance are the midpoint
                        (-1, rt) => return vec!(mid, rt), // if no other instance found to the left then the first instance is the midpoint
                        (lft, -1) => return vec!(lft, mid), // if no other instance found to the right then the last instance is the midpoint
                        (lft, rt) => return vec!(lft, rt) // this should be unreachable
                    }      
            }
        }
    }