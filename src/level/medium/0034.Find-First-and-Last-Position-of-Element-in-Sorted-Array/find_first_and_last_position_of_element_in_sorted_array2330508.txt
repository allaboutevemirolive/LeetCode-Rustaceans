// https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2330508/rust-binary-search/
impl Solution {
pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {

        if nums.len() < 1 {return vec!(-1,-1)}

        fn find_starting_point(n: &Vec<i32>, t: i32) -> i32 {
            use std::cmp::Ordering;
            let (mut lo, mut hi) = (0 as i32, (n.len()-1) as i32);
            let mut index = -1;
            while lo <= hi {
                let mi = (lo + (hi - lo) / 2);

                match n[mi as usize].cmp(&t) {
                    Ordering::Greater => { hi = mi - 1; },
                    Ordering::Less => { lo = mi + 1; },
                    Ordering::Equal => {
                        hi = mi - 1;
                        index = mi;
                    }
                }

            }
            index
        }

        fn find_ending_point(n: &Vec<i32>, t: i32) -> i32 {
            use std::cmp::Ordering;
            let (mut lo, mut hi) = (0 as i32, (n.len()-1) as i32);
            let mut index = -1;
            while lo <= hi {
                let mi = (lo + (hi - lo) / 2);
                match n[mi as usize].cmp(&t) {
                    Ordering::Less => { lo = mi + 1; },
                    Ordering::Greater => { hi = mi - 1; },
                    Ordering::Equal => {
                        lo = mi + 1;
                        index = mi;
                    }
                }
            }
            index
        }

        vec!(find_starting_point(&nums, target), find_ending_point(&nums, target))

    }
}