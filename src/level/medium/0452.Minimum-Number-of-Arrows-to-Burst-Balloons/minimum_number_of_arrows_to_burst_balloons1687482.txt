// https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/1687482/rust-greedy/
use std::cmp;
impl Solution {
    pub fn find_min_arrow_shots(mut points: Vec<Vec<i32>>) -> i32 {
        if points.is_empty() {
            return 0;
        }
        points.sort_by_key(|point| point[0]);

        let size = points.len();
        let mut count = 1;  // minimum 1 arrow if points is not empty

         for i in 1..size {
            if points[i][0] > points[i-1][1] {  // no overlap
                count += 1;
            } else {    
                points[i][1] = cmp::min(points[i][1], points[i-1][1]);  // update minimum right boundary 
            }
        }
        
        return count;
    }
}