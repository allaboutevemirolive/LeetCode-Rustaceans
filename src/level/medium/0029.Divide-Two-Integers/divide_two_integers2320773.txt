// https://leetcode.com/problems/divide-two-integers/solutions/2320773/rust-0ms-solution-only-using-i32/
impl Solution {
    pub fn divide(mut dividend: i32, divisor: i32) -> i32 {
         if divisor == i32::MIN {
            return (dividend == divisor) as i32;
        }
        
        let sign = 1 - ((((dividend > 0) ^ (divisor > 0)) as i32) << 1);

        if dividend == i32::MIN {
            match divisor {
                -1 => return i32::max_value(),
                1 => return i32::min_value(),
                -2 => return -(dividend >> 1),
                2 => return dividend >> 1,
                _ => {
                    
                    return sign+Solution::divide(dividend+divisor.abs() as i32,divisor)},
					//whst use dividend+=1 to solve the abs of i32::MIN is still itself, but can't pass.
					// if x/a =b, then (x+a)/a = b+1; but considering we use the abs of nums not the original nums, if |x|/|a| = b, x/a = sign *|x|/|a| = sign*b, then (x+|a|)/a = sign*b + ||a||/|a|*sign = sign*b + 1*sign.
            }
        }

        
        dividend = dividend.abs();
        let divisor = divisor.abs();
        let mut quotinent = 0;
        let mut shift = 0;

        while (dividend >> shift) >= divisor {
            shift += 1;
        }

        while dividend >= divisor {
            let diff = dividend - (divisor << shift);
            if diff >= 0 {
                dividend = diff;
                quotinent |= 1 << shift; 
            }
            shift -= 1;
        }

        sign * quotinent
    }
}


