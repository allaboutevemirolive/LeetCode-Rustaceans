// https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/1048930/dumb-rust-memoized-dfs/
impl Solution {
    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {
        use std::collections::HashMap;
        
        fn dfs(bottom_right: (usize, usize), matrix: &Vec<Vec<i32>>, target: i32, seen: &mut HashMap<(usize, usize), bool>) -> bool {
            let (row, col) = bottom_right;
            
            // boundary: illegal location is false
            if row < 0 || row >= matrix.len() || col < 0 || col >= matrix[0].len() || matrix[row][col] < target {
                return false;
            }
            
            // memoized case: this location is accessed before and its result is known
            if let Some(memoized_result) = seen.get(&bottom_right) {
                return *memoized_result;
            }
            
            
            // trivial case: this box is target
            if matrix[row][col] == target {
                return true;
            }
            
            // see if top child OR left child is >= target
            let result = dfs((row - 1, col), matrix, target, seen) || dfs((row, col - 1), matrix, target, seen);
            seen.insert((row, col), result);
            return result;
        }
        
        let mut seen = HashMap::new();
        dfs((matrix.len() - 1, matrix[0].len() - 1), &matrix, target, &mut seen)
    }
}