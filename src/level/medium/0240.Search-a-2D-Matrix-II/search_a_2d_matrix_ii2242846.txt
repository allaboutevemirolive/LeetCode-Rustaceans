// https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/2242846/rust-divide-and-conquer-and-iterative-with-comments/
use std::cmp::Ordering;

impl Solution {
    fn search_recursive(matrix: &[Vec<i32>], top: usize, left: usize, bottom: usize, right: usize, target: i32) -> bool {
        let m = matrix.len();
        let n = matrix[0].len();
        // Base cases - submatrix is empty, or target is outside the range of the numbers in the submatrix
        if top >= m || left >= n || bottom >= m || right >= n || target < matrix[top][left] || target > matrix[bottom][right] 
        || top > bottom || left > right {
            return false;
        }
        // Check the middle element
        let (mid_row, mid_col) = (top + (bottom - top)/2, left + (right - left)/2);
        match matrix[mid_row][mid_col].cmp(&target) {
            // found target
            Ordering::Equal => true,
            Ordering::Less => {
                // middle element less than target - can eliminate upper left submatrix
                Self::search_recursive(matrix, mid_row + 1, left, bottom, right, target)
                || Self::search_recursive(matrix, top, mid_col + 1, mid_row, right, target)
            }
            Ordering::Greater => {
                // middle element greater than target - can eliminate bottom right submatrix
                Self::search_recursive(matrix, top, left, mid_row.wrapping_sub(1), right, target)
                || Self::search_recursive(matrix, mid_row, left, bottom, mid_col.wrapping_sub(1), target)
            },
        }
    }

    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {
        Self::search_recursive(&matrix, 0, 0, matrix.len() - 1, matrix[0].len() - 1, target)
    }
}