// https://leetcode.com/problems/serialize-and-deserialize-bst/solutions/900493/recursive-rust-solution-flat-bytes-array/
// // Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//     pub val: i32,
//     pub left: Link,
//     pub right: Link,
// }
//
// impl TreeNode {
//     #[inline]
//     pub fn new(val: i32) -> Self {
//         TreeNode {
//             val,
//             left: None,
//             right: None,
//         }
//     }
// }

pub struct Codec;

impl Codec {
    pub fn new() -> Self {
        Self
    }

    pub fn serialize(&self, root: Link) -> String {
        let tree = Tree { root };
        tree.serialize()
    }

    pub fn deserialize(&self, data: String) -> Link {
        Tree::deserialize(data).root
    }
}

use std::cell::RefCell;
use std::i32;
use std::iter::Peekable;
use std::mem;
use std::rc::Rc;
use std::slice;
use std::str;

type Node = TreeNode;
type Link = Option<Rc<RefCell<Node>>>;

struct Tree {
    root: Link,
}

impl Tree {
    fn serialize(&self) -> String {
        let vals: Vec<i32> = self.preorder();

        // Get a byte slice, to later copy into a String.
        //
        // It's not clear if we could go straight to an owned Vec<u8>,
        // since there are deallocation / alignment pitfalls; see:
        // https://stackoverflow.com/a/49694475
        // https://www.reddit.com/r/rust/comments/aytyqv/converting_vecu32_into_vecu8/ei3ac4c
        let bytes: &[u8] = unsafe {
            slice::from_raw_parts(
                vals.as_ptr() as *const u8,
                vals.len() * mem::size_of::<i32>(),
            )
        };

        // We don't check, since the bytes might not even be UTF-8.
        // Really, the return type of this function should *not* be String.
        let s = unsafe { str::from_utf8_unchecked(bytes) };

        String::from(s)
    }

    fn preorder(&self) -> Vec<i32> {
        fn dfs(link: &Link, acc: &mut Vec<i32>) {
            if let Some(node) = link.as_ref() {
                acc.push(node.borrow().val);
                dfs(&node.borrow().left, acc);
                dfs(&node.borrow().right, acc);
            }
        }

        let mut acc = vec![];
        dfs(&self.root, &mut acc);
        acc
    }

    fn deserialize(data: String) -> Tree {
        // Groups of 4 bytes.
        let bytes: &[u8] = data.as_bytes();
        assert!(bytes.len() % mem::size_of::<i32>() == 0);

        // The endianness is hopefully the same on the machine that
        // serialized this, lol.
        let vals: &[i32] = unsafe {
            slice::from_raw_parts(
                bytes.as_ptr() as *const i32,
                bytes.len() / mem::size_of::<i32>(),
            )
        };

        Self::reconstruct(vals).unwrap()
    }

    /// Build a BST from its preorder traversal.
    fn reconstruct(vals: &[i32]) -> Result<Tree, String> {
        let mut root = None;
        let mut iter = vals.iter().copied().peekable();
        Self::build_tree(&mut root, i32::MIN, i32::MAX, &mut iter)?;
        Ok(Tree { root })
    }

    /// Recursive helper for `reconstruct`.
    ///
    /// Lower and upper are inclusive bounds on the valid range of
    /// values for this subtree.
    fn build_tree<I>(
        node: &mut Link,
        lower: i32,
        upper: i32,
        vals: &mut Peekable<I>,
    ) -> Result<(), String>
    where
        I: Iterator<Item = i32>,
    {
        assert!(node.is_none());

        match vals.peek() {
            None => return Ok(()),

            // v is too large, so backtrack up the tree.
            Some(&v) if v > upper => return Ok(()),

            // v is too small, but this means the input is malformed.
            Some(&v) if v < lower => return Err("Invalid preorder of BST".into()),

            _ => (),
        }

        // Allocate the root of this subtree.
        let v = vals.next().unwrap();
        *node = Some(Rc::new(RefCell::new(Node::new(v))));

        // All the values <= val go in the left subtree.
        Self::build_tree(
            &mut node.as_mut().unwrap().borrow_mut().left,
            lower,
            v,
            vals,
        )?;

        // The remaining vals go in the right subtree.
        Self::build_tree(
            &mut node.as_mut().unwrap().borrow_mut().right,
            v,
            upper,
            vals,
        )?;

        Ok(())
    }
}