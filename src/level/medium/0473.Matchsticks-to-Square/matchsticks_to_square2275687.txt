// https://leetcode.com/problems/matchsticks-to-square/solutions/2275687/rust-extensive-pruning-with-comments/
use std::collections::{HashMap, HashSet};

impl Solution {
    pub fn makesquare(mut matchsticks: Vec<i32>) -> bool {
        let n = matchsticks.len();
        // With less than 4 matchsticks, we cannot form a square
        if n < 4 {
            return false;
        }
        let perimeter: i32 = matchsticks.iter().sum();
        // If the perimiter isn't evenly divisible by 4, there is
        // no way to form a square.
        if perimeter % 4 != 0 {
            return false;
        }
        // Overall time complexity is n*2^n, so O(n*log(n)) sorting
        // is "for free". If the longest matchstick is longer
        // than the side of the square, we cannot form a square.
        matchsticks.sort_unstable_by_key(|length| -*length);
        if matchsticks[0] > perimeter/4 {
            return false;
        }
        // Hashmap to memoize lengths of combinations of matchsticks
        let mut len_memo = HashMap::<usize, i32>::new();

        // The bitmask corresponing to all the matchsticks (n lower bits set)
        let all_set = (1 << n) - 1;

        // A vector to collect all found combinations of matchsticks with
        // the right side length
        let mut candidates = Vec::<usize>::new();
        // Memoization set for all pairs of square side candidates
        let mut pair_memo = HashSet::<usize>::new();

        for bitmask in 1..all_set {
            if Self::len_from_mask(bitmask, 0, &matchsticks, &mut len_memo) == perimeter/4 {
                // We have a combination of matchsticks with the right length
                for candidate in candidates.iter() {
                    if candidate & bitmask == 0 {
                        // The two candiates do not share matches. Look for
                        // another found pair that does not share matches with
                        // this pair.
                        let pair = candidate | bitmask;
                        if pair_memo.contains(&(all_set ^ pair)) {
                            return true;
                        }
                        // Memoize this pair
                        pair_memo.insert(pair);
                    }
                }
                candidates.push(bitmask);        
            }
        }

        false
    }

    fn len_from_mask(mask: usize, i: usize, matchsticks: &[i32], memo: &mut HashMap<usize, i32>) -> i32 {
        if mask == 0 {
            // Base case - no selected matches => zero length
            return 0;
        }
        // Check if we have already computed the length for this bitmask
        if let Some(length) = memo.get(&mask) {
            return *length;
        }
        // Recursively compute the length of the remaining combination of matchsticks
        // after adding the length of this matchstick if selected
        let bit = 1 << i;
        let rez = if mask & bit != 0 { matchsticks[i] } else { 0 } + Self::len_from_mask(mask & !bit, i + 1, matchsticks, memo);
        memo.insert(mask, rez);
        rez
    }
}