// https://leetcode.com/problems/matchsticks-to-square/solutions/2273069/rust-backtracking-with-memoization/
use std::collections::HashSet;

pub fn makesquare(matchsticks: &[i32]) -> bool {
    const SIDES: i32 = 4;
    assert!(matchsticks.len() <= 16);

    let perimeter = matchsticks.iter().sum::<i32>();
    let side_len = perimeter / SIDES;

    // If the perimeter is not divisible by 4, then it's not possible to
    // make a square, because we can only use whole integers
    if perimeter % SIDES != 0 {
        return false;
    }

    let mut failure_cache = HashSet::new();
    backtrack(matchsticks, &mut failure_cache, side_len, 0, SIDES, 0)
}

fn backtrack(
    sticks: &[i32],
    failures: &mut HashSet<u16>,
    target: i32,
    used_sticks: u16,
    mut sides: i32,
    mut current: i32,
) -> bool {
    if failures.contains(&used_sticks) {
        return false;
    }

    if current == target {
        sides -= 1;

        match sides {
            0 => return true,
            _ => current = 0,
        }
    }

    for i in 0..sticks.len() {
        // Skip over any already used sticks
        if used_sticks & 1 << i != 0 {
            continue;
        }

        let next_len = current + sticks[i];

        // The current sum is larger than the square's side,
        // so skip the current match and try the next
        if next_len > target {
            continue;
        }

        let used_sticks = used_sticks | 1 << i;
        if backtrack(sticks, failures, target, used_sticks, sides, next_len) {
            return true;
        }
    }

    failures.insert(used_sticks);
    false
}