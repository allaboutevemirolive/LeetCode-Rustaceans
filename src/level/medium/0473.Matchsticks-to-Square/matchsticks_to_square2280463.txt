// https://leetcode.com/problems/matchsticks-to-square/solutions/2280463/rust-dfs-with-optimisations-3ms/
impl Solution {
    pub fn makesquare(matchsticks: Vec<i32>) -> bool {
       can_partition_k_subsets(matchsticks, 4)
    }
}

fn can_partition_k_subsets(mut nums: Vec<i32>, k: i32) -> bool {
    assert!(k > 0);
    assert!(k <= 16);
    assert!(k as usize <= nums.len());

    let sum = nums.iter().sum::<i32>();

    // If the sum of all numbers is not divisible by `k`, then
    // it is not possible to partition the array to `k` subsets
    if sum % k != 0 {
        return false;
    }

    // The expected sum of the elements of each subset
    let target = sum / k;

    // We need to sort the nums for two reasons:
    // * if it is sorted in descending order, negative states from the DFS
    //   will be reached faster, thus speeding up the algorithm
    // * we can also check if there are numbers larger than the subset sum
    //   Although this can be done in O(n) time, we can take advantage of
    //   the sorting we did for the previous point
    nums.sort_unstable_by(|a, b| a.cmp(b).reverse());

    // If there is a number that is larger than the subset sum,
    // then it is not possible to partition the array to `k` subsets
    if nums[0] > target {
        return false;
    }

    // If there are numbers that are equal to the target subset sum,
    // we can remove them early in order to have fewer elements for
    // the DFS
    let mut nums = &mut nums[..];
    let mut k = k as usize;
    while k > 0 && nums[0] == target {
        nums = &mut nums[1..];
        k -= 1;
    }

    // Fast path: all elements were equal to the target subset sum
    if k == 0 {
        return true;
    }

    let mut sums = vec![0; k as usize];
    dfs(&nums, &mut sums, target, 0)
}

fn dfs(nums: &[i32], sums: &mut [i32], target: i32, idx: usize) -> bool {
    if nums.len() == idx {
        return sums.iter().all(|&x| x == target);
    }

    for s in 0..sums.len() {
        if sums[s] + nums[idx] > target {
            continue;
        }

        // If the two subsets have an equal current value, then
        // we need to check if the next value can put in only one
        // of them. There is no need to check every subset, given that
        // they are equal.
        //
        // Note: Is the upper statement always true ? 
        if sums
            .iter()
            .copied()
            .enumerate()
            .filter(|&(pos, _)| pos < s)
            .any(|(_, val)| val == sums[s])
        {
            continue;
        }

        sums[s] += nums[idx];
        if dfs(nums, sums, target, idx + 1) {
            return true;
        }
        sums[s] -= nums[idx];
    }

    false
}