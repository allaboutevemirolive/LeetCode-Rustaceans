// https://leetcode.com/problems/largest-number/solutions/867951/rust-solution-without-strings/
impl Solution {
    fn log10(mut x: i32) -> usize {
        let mut c = 0;
        while x > 0 {
            x /= 10;
            c += 1;
        }
        c.max(1)
    }
    
    fn digit_at(x: i32, pow: usize) -> i32 {
        const POWS: &[i32] = &[
            1, 10, 100, 1000,
            10000, 100000,
            1000000, 10000000,
            100000000,
            1000000000,
        ];
        (x / POWS[pow]) % 10
    }

    pub fn largest_number(mut nums: Vec<i32>) -> String {
        if nums.iter().all(|&x| x == 0) {
            return "0".to_string();
        }
    
        nums.sort_by(|&x, &y| {
            let l_x = Self::log10(x);
            let l_y = Self::log10(y);
            
            if l_x == l_y {
                return y.cmp(&x);
            }
            
            for i in 0..l_x.max(l_y) {
                let a = Self::digit_at(x, l_x - (i % l_x) - 1);
                let b = Self::digit_at(y, l_y - (i % l_y) - 1);
                match a.cmp(&b) {
                    std::cmp::Ordering::Equal => {},
                    c => return c.reverse(),
                }
            }
            
            let a = Self::digit_at(x, 0);
            let b = Self::digit_at(y, 0);
            for i in (0..l_y.saturating_sub(l_x)).rev() {
                match a.cmp(&Self::digit_at(y, i)) {
                    std::cmp::Ordering::Equal => {},
                    c => return c.reverse(),
                }
            }
            for i in (0..l_x.saturating_sub(l_y)).rev() {
                match Self::digit_at(y, i).cmp(&b) {
                    std::cmp::Ordering::Equal => {},
                    c => return c.reverse(),
                }
            }
            
            std::cmp::Ordering::Equal
        });
        nums.into_iter().map(|n| n.to_string()).fold(String::new(), |mut s, t| {
            s.push_str(&t);
            s
        })
    }
}