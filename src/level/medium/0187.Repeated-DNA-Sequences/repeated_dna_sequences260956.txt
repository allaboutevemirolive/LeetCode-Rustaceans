// https://leetcode.com/problems/repeated-dna-sequences/solutions/260956/16ms-rust-bit-operation-solution-self-explanatory/
use std::collections::HashSet;
impl Solution {
	// we use 20 bits to record a 10 length DNA sequence
    pub fn find_repeated_dna_sequences(s: String) -> Vec<String> {
        let mut seq_code: u32 = 0;
        let mut set: HashSet<u32> = HashSet::new();
        let mut repeat: HashSet<u32> = HashSet::new();
        let mut count = 0;
        for ch in s.chars() {
            seq_code <<= 2;
            match ch {
                'A' => seq_code |= 0_u32,
                'C' => seq_code |= 1_u32,
                'G' => seq_code |= 2_u32,
                'T' => seq_code |= 3_u32,
                _ => unreachable!(),
            }
            // skip first 9 chars
            if count < 9 {
                count += 1; continue;
            }
            // mask high 12-bits
            seq_code &= 0b0000_0000_0000_1111_1111_1111_1111_1111;
            if !set.insert(seq_code) {
                repeat.insert(seq_code);
            }
        }
        // bits code to seq string
        repeat.iter().map(|&code| {
            let mut substr = String::new();
            let mut code = code;
            for _ in 0..10 {
                // take the first 2 bits each time
                substr.push(match code & 0b0000_0000_0000_1100_0000_0000_0000_0000 {
                    0b0000_0000_0000_0000_0000_0000_0000_0000 => 'A',
                    0b0000_0000_0000_0100_0000_0000_0000_0000 => 'C',
                    0b0000_0000_0000_1000_0000_0000_0000_0000 => 'G',
                    0b0000_0000_0000_1100_0000_0000_0000_0000 => 'T',
                    _ => unreachable!(),
                });
                code <<= 2;
            }
            substr
        }).collect()
    }
}