// https://leetcode.com/problems/repeated-dna-sequences/solutions/344208/rust-0ms-3-1mb-but-ugly-implementation-need-suggestions/
impl Solution {
    /* information is kSubstrLen * log(A,C,G,T) = `2 * kSubstrLen` bit,
     * if we use bit-manipulate mask, a 32-int can offer log(32) = 5 bit,
     * there remains `2 * kSubstrLen - 5`bit information. we'll use a mask array,
     *      and this remained information will be offer here, the array contains
     *      `1 << (2 * kSubstrLen - 5)` elements
     */

    pub fn find_repeated_dna_sequences(s: String) -> Vec<String> {
        const SUBSTR_LEN: usize = 10;
        const INFORMATION_ACGT: usize = 2; // ACGT: 4 * log(1/4) = 2 bit
        let information_int: usize = Self::get_int_len_log2(); // for 32_int: log(32) = 5 bit
        let array_len: usize = 1 << (INFORMATION_ACGT * SUBSTR_LEN - information_int);

        let mut res = vec![];
        let (mut records, mut already_in_res) = (vec![0; array_len], vec![0; array_len]);

        // A, C, G, Tâ€™s bit is distinct from each other at last 2 and 3 bits, so last bit is not used
        // so mask_str and mask_char is 1111...1110 and 110
        const MASK_STR: usize = (1 << (2 * 10 + 1)) - 2; // 1111...1110
        const MASK_CHAR: usize = 0x6; // 110
        let mut mask_cur: usize = 0;

        if s.len() <= SUBSTR_LEN {
            return vec![];
        }

        for i in 0..(SUBSTR_LEN - 1) {
            mask_cur = (mask_cur << 2) | (s.as_bytes()[i] as usize) & MASK_CHAR;
        }
        for i in (SUBSTR_LEN - 1)..s.len() {
            mask_cur = ((mask_cur << 2) | (s.as_bytes()[i] as usize) & MASK_CHAR) & MASK_STR;
            if Self::set_and_test(&mut records, mask_cur)
                && !Self::set_and_test(&mut already_in_res, mask_cur)
            {
                res.push(s[(i - 9)..(i + 1)].to_string());
            }
        }
        res
    }

    const fn get_int_len_log2() -> usize {
        //        (std::mem::size_of::<usize>() as f32).log2() as usize
        //        if std::mem::size_of::<usize>() == 32 {
        //            5
        //        } else {
        //            6
        //        }
        5
    }

    fn set_and_test(masks: &mut Vec<usize>, mut mask_cur: usize) -> bool {
        let information_int: usize = Self::get_int_len_log2(); // for 32_int: log(64) = 6 bit

        mask_cur >>= 1;
        let pos = mask_cur >> information_int;
        let mask_offset = mask_cur & ((1 << information_int) - 1);
        let mask_val = 1 << mask_offset;

        if masks[pos] & mask_val != 0 {
            true
        } else {
            masks[pos] |= mask_val;
            false
        }
    }
}