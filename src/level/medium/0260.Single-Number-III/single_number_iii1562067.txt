// https://leetcode.com/problems/single-number-iii/solutions/1562067/rust-xor-other-bitwise-tricks-applied-explained/
impl Solution {
    pub fn single_number(nums: Vec<i32>) -> Vec<i32> {
        let xor_all = nums.iter()
                          .fold(0, |acm, &n| acm ^ n); // XOR all numbers together.
        let lo_bit  = xor_all & -xor_all;              // Get the value of the lowest order bit;
                                                       // this will be the bitmask for filtering.
        let mut n1  = 0;                               // The XOR accumulator vars.
        let mut n2  = 0;
        
        for n in nums {
            if n & lo_bit == 0 { n1 ^= n; }            // Apply mask and branch on
            else               { n2 ^= n; }            // selected bit in `lo_bit`.
        }
        vec![n1, n2]
    }
}