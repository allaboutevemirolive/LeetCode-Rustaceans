// https://leetcode.com/problems/remove-duplicate-letters/solutions/1455763/rust-using-a-monotonic-stack-with-inline-comments/
const LETTERS: usize = (b'z' - b'a' + 1) as usize;

impl Solution {
    pub fn remove_duplicate_letters(s: String) -> String {
	    // how many times each letter is encountered
        let mut freq = [0; LETTERS]; 
      
	    // we'll store our result here
	    let mut string = String::with_capacity(s.len()); 
        
		// the stack
		let mut stack = Vec::with_capacity(s.len().min(64));
        
		// we'll use it as bit field - each bit corresponds to a letter. If it's 1, then we've already used that letter
		let mut used = 0u32;

        // calculate how many times each letter is encountered
        for &ch in s.as_bytes() {
            freq[(ch - b'a') as usize] += 1;
        }

        for ch in s.as_bytes().iter().map(|&b| b - b'a') { // map the ASCII to 0-based bytes in order to avoid confusing "- b'a'" index shifts all over the place
		    // We need to track how many times we can try to use a given letter.
			// Decrease its frequency each time it's encountered. When it becomes 0, then
			// we can no longer remove it from the string, otherwise we'll lose it
            freq[ch as usize] -= 1;

            // try to maintain the monotonic properties of the stack unless this will lead to a loss of a character:
			// 1. pop elements from the stack untill the current stack top becomes smaller than the current character
			// 2. do not pop from the stack if the top element has a frequency of 0, meaning that if we pop it, then it won't appear again in the string
			// 3. Do not pop from the stack if the current character is already pushed somewhere in the stack
            while let Some(&top) = stack.last() {  
                if top < ch || freq[top as usize] == 0 || used & (1u32 << ch) != 0 {
                    break;
                }

                stack.pop();
                used ^= 1u32 << top;  // clear the bitflag for the stack's top character
            }

            if used & (1u32 << ch) == 0 {  // if this character is not present in the stack, push it and mark it as pushed
                used |= 1u32 << ch;
                stack.push(ch);
            }
        }

        // the stack contains our string in reverse order, so we'll not pop() from it (ie take from End), but iterate it from Start->End
        stack 
            .iter()
            .map(|&b| (b + b'a') as char) // convert the 0-based bytes back to ASCII
            .for_each(|b| string.push(b));
        string
    }
}