// https://leetcode.com/problems/integer-replacement/solutions/2483567/rust-solution-using-dfs/
struct Helper {
    result:isize,
    memo:Vec<isize>
}

impl Helper {
    fn dfs(&mut self, n:usize, count:isize) {
        if n == 1 {
            self.result = std::cmp::min(count, self.result);
            return
        }

        for i in 0..33 {
            let diff = (self.memo[i] - n as isize).abs() as isize;
            let v = count + diff + i as isize;
            self.result = std::cmp::min(self.result, v);
        }

        if n % 2 == 1 {
            if n == 2 {
                self.result = std::cmp::min(count+1, self.result);
                return
            }
            self.dfs((n-1)/2, count+2);
            self.dfs((n+1)/2, count+2);
        } else {
            self.dfs(n/2, count+1);
        }
    }
}

impl Solution {
    pub fn integer_replacement(n: i32) -> i32 {
        if n == 1 { return 0 }
        let n = n as usize;
        let mut memo = vec![0;33];
        for i in 0..33 {
            memo[i] = 1 << i;
        }

        let mut helper = Helper { memo, result: 1000000 };
        helper.dfs(n, 0);

        helper.result as i32
    }
}