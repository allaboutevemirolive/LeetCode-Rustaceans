// https://leetcode.com/problems/integer-replacement/solutions/1510660/rust-solution-0ms-100-o-1-space-no-recursion-no-dp-no-bfs-commented/
impl Solution {
    pub fn integer_replacement(n: i32) -> i32 {
        let mut n = n as u32;
        let mut result = 0;
        
        while n > 1 {
            // Uncomment to see progress
            // println!("{}: {:>10} {:032b}", result, n, n);
            // Even
            if n & 1 == 0 {
				// We can divide by 2 as many times as we have trailing 0s
                let n_trailing_zeros = n.trailing_zeros();
                n >>= n_trailing_zeros;
				result += n_trailing_zeros as i32;
                
            // Odd
            } else {
				// We want as many trailing 0s as possible after adding/subtracting 1
				// For an odd number we have at least one trailing 1
				// If n & 2 == 0 we have exactly 1 trailing 1, so subtracting yields more 0s
				// With more than one trailing 1, adding would yield more 0s
				// n == 3 is an exception because there are no higher order digits in play,
				// so we don't care about having more trailing 0s in that case
                if n == 3 || n & 2 == 0 {
                    n -= 1;
                } else {
                    n += 1;
                }
                
                result += 1;
            }
        }
        
        result
    }
}