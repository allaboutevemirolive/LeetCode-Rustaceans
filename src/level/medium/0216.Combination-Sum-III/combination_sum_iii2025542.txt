// https://leetcode.com/problems/combination-sum-iii/solutions/2025542/rust-harder-pruning-iterative-fold-with-explanation/
impl Solution {
    pub fn combination_sum3(k: i32, n: i32) -> Vec<Vec<i32>> {
        (1..k)
            // Fold for each of the k - 1 positions remaining after the initial value.
            // The initial value is a Vec with tuples with a vector of the first digit i and the remainder n - i
            .fold(
                (1..=9).map(|i| (vec![i], n - i)).collect::<Vec<_>>(),
                |acc, j| {
                    // Create a new acc from acc
                    acc.into_iter()
                        // Filter out entries where the remainder is too low
                        .filter(|(v, remain)| {
                            // let x be the last digit added
                            let x = *v.last().unwrap();
                            // let y be the remaining number of positions to fill
                            let y = k - j;
                            // The sequence with the minimum sum that can be added
                            // in the remaining positions is
                            // min_needed = (x + 1) + (x + 2) + ... + (x + y)
                            // = x*y + (1 + 2 + ... + y)
                            // = x+y + (y*y + y)/2.
                            // So the remainder needs to be at least min_needed
                            // for this not to be a dead end
                            let min_needed = x*y + (y*y + y)/2;
                            *remain >= min_needed
                        })
                        // Create new vectors with added digits and the new remainder
                        .flat_map(|(v, remain)| {
                            // The digit we add is > the last digit to avoid duplicate entries
                            (*v.last().unwrap() + 1..=9)
                                .map(|i| {
                                    // Clone vector and add new digit
                                    let mut next = v.clone();
                                    next.push(i);
                                    // Return new vector and remainder
                                    (next, remain - i)
                                })
                                .collect::<Vec<_>>()
                        })
                        .collect()
                },
            )
            // Here we have vectors with k digits, but the remainder can be != 0, since we haven't checked
            // after the last digit added.
            .into_iter()
            // Filter out the vectors with the proper sum (remainder == 0) and map to strip away the remainder
            .filter_map(|(v, remain)| if remain == 0 { Some(v) } else { None })
            .collect()
    }
}