// https://leetcode.com/problems/house-robber-iii/solutions/946735/rust-simple-solution-dfs/
use std::rc::Rc;
use std::cell::RefCell;
use std::cmp;

impl Solution {
    pub fn rob(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        let (a, b) = Self::dfs(&root);
        return cmp::max(a, b);
    }    
    
    fn dfs(root: &Option<Rc<RefCell<TreeNode>>>) -> (i32, i32) {
        match root {
            Some(node) => {                
                let left = Self::dfs(&node.borrow().left);
                let right = Self::dfs(&node.borrow().right);
                return (
                    node.borrow().val + left.1 + right.1,  
                    cmp::max(left.0, left.1) + cmp::max(right.0, right.1),
                );
            },
            None => (0, 0),
        }
    }
}