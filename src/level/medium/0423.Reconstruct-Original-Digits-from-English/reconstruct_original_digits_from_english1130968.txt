// https://leetcode.com/problems/reconstruct-original-digits-from-english/solutions/1130968/rust-backtracking-time-exceeded/
impl Solution {
    pub fn original_digits(s: String) -> String {
        let num_dists: Vec<Vec<usize>> = [
            "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine",
        ]
        .iter()
        .map(|cs| Self::calc_dist(cs.as_bytes()))
        .collect();

        let mut to_consume = Self::calc_dist(s.as_bytes());
        let mut res = vec![];
        Self::backtracking(&num_dists, &mut to_consume, &mut res, 0);
        res.into_iter()
            .map(|a| std::char::from_digit(a as u32, 10).unwrap())
            .collect()
    }

    fn backtracking(
        num_dists: &[Vec<usize>],
        to_consume: &mut Vec<usize>,
        acc: &mut Vec<u8>,
        cur: usize,
    ) -> bool {
        if to_consume.iter().all(|&a| a == 0) {
            return true;
        }
        for i in cur..=9 {
            if Self::dist_subtractable(to_consume, &num_dists[i]) {
                Self::dist_subtract(to_consume, &num_dists[i]);
                acc.push(i as u8);
                let finished = Self::backtracking(num_dists, to_consume, acc, i);
                if finished {
                    return true;
                }
                Self::dist_add(to_consume, &num_dists[i]);
                acc.pop();
            }
        }
        false
    }

    // MARK: Helpers

    fn calc_dist(bytes: &[u8]) -> Vec<usize> {
        let mut dist = vec![0; 26];
        for byte in bytes {
            dist[(byte - b'a') as usize] += 1;
        }
        dist
    }

    fn dist_subtractable(dist1: &Vec<usize>, dist2: &[usize]) -> bool {
        (0..=25).all(|i| dist1[i] >= dist2[i])
    }

    fn dist_subtract(dist1: &mut Vec<usize>, dist2: &[usize]) {
        for i in 0..=25 {
            dist1[i] -= dist2[i];
        }
    }

    fn dist_add(dist1: &mut Vec<usize>, dist2: &[usize]) {
        for i in 0..=25 {
            dist1[i] += dist2[i];
        }
    }
}