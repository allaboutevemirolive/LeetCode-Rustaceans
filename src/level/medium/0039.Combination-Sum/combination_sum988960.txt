// https://leetcode.com/problems/combination-sum/solutions/988960/rust-backtracking-0ms/
/// backtracking DFS
/// constraint: tree next value <= target
impl Solution {
    fn dfs(src: &[i32], consumed: Vec<i32>, cur: usize, target: i32, res: &mut Vec<Vec<i32>>) {
        if target == 0 {
            res.push(consumed);
            return;
        }
        for i in cur..src.len() {
            let v = src[i];
            if v > target {
                continue;
            }
            let mut next_consumed = consumed.clone();
            next_consumed.push(v);
            Self::dfs(src, next_consumed, i, target - v, res);
        }
    }
    
    pub fn combination_sum(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        let mut res = vec![];
        Self::dfs(&candidates, vec![], 0, target, &mut res);
        res
    }
}