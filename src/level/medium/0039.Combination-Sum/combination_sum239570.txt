// https://leetcode.com/problems/combination-sum/solutions/239570/rust-solution/
impl Solution {
    pub fn combination_sum(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        let mut can = candidates;
        can.sort();
        let mut res: Vec<Vec<i32>> = vec![];
        let mut combination: Vec<i32> = vec![];
        
        Self::_combination_sum(&mut can, target, &mut res, &mut combination, 0);
        res
    }
    
    fn _combination_sum(candidates: &mut Vec<i32>, target: i32, res: &mut Vec<Vec<i32>>, combination: &mut Vec<i32>, cursor: usize) {
        if target == 0 {
            res.push(combination.to_vec());
            return
        }
        let mut i = cursor;
        while i < candidates.len() && target >= candidates[i] {
            combination.push(candidates[i]);
            Self::_combination_sum(candidates, target - candidates[i], res, combination, i);
            combination.pop();
            i = i + 1;
        }
    }
}