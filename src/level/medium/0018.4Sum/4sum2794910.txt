// https://leetcode.com/problems/4sum/solutions/2794910/concise-rust-solution-with-comments/
use std::cmp::Ordering;

impl Solution {
    pub fn four_sum(nums: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        let mut combinations: Vec<Vec<i32>> = vec![];
        let len = nums.len();
        
        if len < 4 { return combinations; } //cant have multiple of 4

        let mut nums = nums;
        nums.sort();  //sort to allow left/right crawling

        for i in 0..len - 3 {
            if nums[i] as i64 * 4 > target as i64 { break; } //no more solutions can be found if left most index (i) cannot divide/4 evenly or less than target
                                                             //considering all numbers right of (i) are either equal or larger!
            
            if i > 0 && nums[i] == nums[i - 1] { continue; } //traverse duplicates

            for j in i + 1..len - 2 {
                if nums[j] as i64 * 3 > target as i64 - nums[i] as i64 { continue; } // continue j loop if second left most index (j) cannot divide/3 evenly or less than target - i
                
                if j > i + 1 && nums[j] == nums[j - 1] { continue; }  //traverse duplicates

                let (mut left, mut right) = (j + 1, len - 1);

                while left < right {
                    let cur_val: i64 = nums[i] as i64 + nums[j] as i64 + nums[left] as i64 + nums[right] as i64;
                    match cur_val.cmp(&(target as i64)) {
                        Ordering::Equal => {  //if equal, push solution
                            combinations.push(vec![nums[i], nums[j], nums[left], nums[right]]);
                            
                            //pull left and right inwards
                            left += 1;
                            right -= 1;
                            
                            //then traverse any duplicates
                            while left < right && nums[left] == nums[left - 1] { left += 1; }
                            while left < right && nums[right] == nums[right + 1] { right -= 1; }
                        }
                        Ordering::Less =>    left += 1,  //if sum is less move left to find a larger sum
                        Ordering::Greater => right -= 1, //if sum is greater move right to find a smaller sum
                    }
                }
            }
        }
        combinations
    }
}