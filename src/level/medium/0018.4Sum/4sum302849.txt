// https://leetcode.com/problems/4sum/solutions/302849/intuitive-rust-solution-0ms/
impl Solution {
    pub fn four_sum(nums: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        let mut nums = nums;
        let len = nums.len();
        if len < 4 {
            return vec![];
        }
        
        nums.sort();
        
        let mut found = vec![];
        let mut pre: i32 = std::i32::MAX;
        
        for i in 0..(len - 3) {
            if nums[i] == pre { continue; }
            pre = nums[i];
            let n = Self::three_sum(&nums[(i + 1)..], target - nums[i]);
            for three in n {
                found.push(vec![nums[i], three[0], three[1], three[2]]);
            }
        }
        
        found
    }
    
    fn three_sum(nums: &[i32], target: i32) -> Vec<Vec<i32>> {
        let mut found = vec![];
        let len = nums.len();
        let mut pre: i32 = std::i32::MAX;
        
        if nums[0] + nums[1] + nums[2] > target { return found; }
        if nums[len - 1] + nums[len - 2] + nums[len - 3] < target { return found; }
        
        for i in 0..(len - 2) {
            if nums[i] == pre { continue; }
            pre = nums[i];
            let n = Self::two_sum(&nums[(i + 1)..], target - nums[i]);
            for two in n {
                found.push(vec![nums[i], two[0], two[1]]);
            }
        }
        
        found
    }
    
    fn two_sum(nums: &[i32], target: i32) -> Vec<Vec<i32>> {
        let mut found = vec![];
        let len = nums.len();
        let mut pre: i32 = std::i32::MAX;
        
        if nums[0] + nums[1] > target { return found; }
        if nums[len - 1] + nums[len - 2] < target { return found; }
        
        for i in 0..(len - 1) {
            if nums[i] == pre { continue; }
            pre = nums[i];
            if let Some(n) = Self::one(&nums[(i + 1)..], target - nums[i]) {
                found.push(vec![nums[i], n]);
            }
        }
        
        found
    }
    
    fn one(nums: &[i32], target: i32) -> Option<i32> {
        // b search
        let len = nums.len();
        if len == 0 || target > nums[len - 1] || target < nums[0] {
            return None;
        }
        let mid_index = (len - 1) / 2;
        let mid = nums[mid_index];
        if mid == target { return Some(mid); }
        else if mid > target { return Self::one(&nums[..mid_index], target); }
        else { return Self::one(&nums[(mid_index + 1)..], target); }
    }
}