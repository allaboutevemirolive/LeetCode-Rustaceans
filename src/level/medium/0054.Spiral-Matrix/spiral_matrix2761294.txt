// https://leetcode.com/problems/spiral-matrix/solutions/2761294/rust-with-custom-iterator/
use std::collections::HashSet;

struct Matrix<'a> {
    matrix: &'a Vec<Vec<i32>>,
    width: usize,
    height: usize,
}

impl<'a> Matrix<'a> {
    fn new(matrix: &'a Vec<Vec<i32>>) -> Self{
        Matrix{
            matrix,
            width: matrix[0].len(),
            height: matrix.len(),
        }
    }

    fn index(&self, x: usize, y: usize) -> i32{
        self.matrix[y][x]
    }

    fn iter_spiral(&self) -> SpiralIter {
        SpiralIter::new(self)
    }
}

struct SpiralIter<'a> {
    mat: &'a Matrix<'a>,
    x: usize,
    y: usize,
    vals_left: usize,
    dir: (i32, i32),
    visted: HashSet<(usize, usize)>,
}

impl<'a> SpiralIter<'a> {
    fn new(mat: &'a Matrix<'a>) -> Self {
        SpiralIter {
            mat,
            x: 0,
            y: 0,
            vals_left: mat.width * mat.height,
            dir: (1, 0),
            visted: HashSet::new(),
        }
    }

    fn next_dir(&self) -> (i32, i32) {
        (-self.dir.1, self.dir.0)
    }

    fn move_next(&mut self) {
        if self.vals_left == 0 {
            return;
        }
        let new_x = self.x + self.dir.0 as usize;
        let new_y = self.y + self.dir.1 as usize;
        if self.check_valid(new_x, new_y) {
            self.x = new_x;
            self.y = new_y;
            return;
        }
        self.dir = self.next_dir();
        self.move_next()
    }

    fn check_valid(&self, x: usize, y: usize) -> bool {
        if x < 0 || x >= self.mat.width {
            return false;
        }
        if y < 0 || y >= self.mat.height {
            return false;
        }
        !self.visted.contains(&(x, y))
    }
}


impl Iterator for SpiralIter<'_> {
    type Item = i32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.vals_left == 0 {
            return None;
        }
        self.vals_left -= 1;
        let val = self.mat.index(self.x, self.y);
        self.visted.insert((self.x, self.y));
        self.move_next();
        Some(val)
    }
}

impl Solution {
    pub fn spiral_order(matrix: Vec<Vec<i32>>) -> Vec<i32> {
        Matrix::new(&matrix).iter_spiral().collect()
    }
}